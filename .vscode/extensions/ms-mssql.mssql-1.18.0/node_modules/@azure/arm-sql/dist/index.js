'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure/core-client');
var tslib = require('tslib');
var coreLro = require('@azure/core-lro');

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
(function (KnownGeoBackupPolicyName) {
    KnownGeoBackupPolicyName["Default"] = "Default";
})(exports.KnownGeoBackupPolicyName || (exports.KnownGeoBackupPolicyName = {}));
(function (KnownUnitType) {
    KnownUnitType["Count"] = "count";
    KnownUnitType["Bytes"] = "bytes";
    KnownUnitType["Seconds"] = "seconds";
    KnownUnitType["Percent"] = "percent";
    KnownUnitType["CountPerSecond"] = "countPerSecond";
    KnownUnitType["BytesPerSecond"] = "bytesPerSecond";
})(exports.KnownUnitType || (exports.KnownUnitType = {}));
(function (KnownPrimaryAggregationType) {
    KnownPrimaryAggregationType["None"] = "None";
    KnownPrimaryAggregationType["Average"] = "Average";
    KnownPrimaryAggregationType["Count"] = "Count";
    KnownPrimaryAggregationType["Minimum"] = "Minimum";
    KnownPrimaryAggregationType["Maximum"] = "Maximum";
    KnownPrimaryAggregationType["Total"] = "Total";
})(exports.KnownPrimaryAggregationType || (exports.KnownPrimaryAggregationType = {}));
(function (KnownUnitDefinitionType) {
    KnownUnitDefinitionType["Count"] = "Count";
    KnownUnitDefinitionType["Bytes"] = "Bytes";
    KnownUnitDefinitionType["Seconds"] = "Seconds";
    KnownUnitDefinitionType["Percent"] = "Percent";
    KnownUnitDefinitionType["CountPerSecond"] = "CountPerSecond";
    KnownUnitDefinitionType["BytesPerSecond"] = "BytesPerSecond";
})(exports.KnownUnitDefinitionType || (exports.KnownUnitDefinitionType = {}));
(function (KnownRecommendedActionCurrentState) {
    KnownRecommendedActionCurrentState["Active"] = "Active";
    KnownRecommendedActionCurrentState["Pending"] = "Pending";
    KnownRecommendedActionCurrentState["Executing"] = "Executing";
    KnownRecommendedActionCurrentState["Verifying"] = "Verifying";
    KnownRecommendedActionCurrentState["PendingRevert"] = "PendingRevert";
    KnownRecommendedActionCurrentState["RevertCancelled"] = "RevertCancelled";
    KnownRecommendedActionCurrentState["Reverting"] = "Reverting";
    KnownRecommendedActionCurrentState["Reverted"] = "Reverted";
    KnownRecommendedActionCurrentState["Ignored"] = "Ignored";
    KnownRecommendedActionCurrentState["Expired"] = "Expired";
    KnownRecommendedActionCurrentState["Monitoring"] = "Monitoring";
    KnownRecommendedActionCurrentState["Resolved"] = "Resolved";
    KnownRecommendedActionCurrentState["Success"] = "Success";
    KnownRecommendedActionCurrentState["Error"] = "Error";
})(exports.KnownRecommendedActionCurrentState || (exports.KnownRecommendedActionCurrentState = {}));
(function (KnownColumnDataType) {
    KnownColumnDataType["Image"] = "image";
    KnownColumnDataType["Text"] = "text";
    KnownColumnDataType["Uniqueidentifier"] = "uniqueidentifier";
    KnownColumnDataType["Date"] = "date";
    KnownColumnDataType["Time"] = "time";
    KnownColumnDataType["Datetime2"] = "datetime2";
    KnownColumnDataType["Datetimeoffset"] = "datetimeoffset";
    KnownColumnDataType["Tinyint"] = "tinyint";
    KnownColumnDataType["Smallint"] = "smallint";
    KnownColumnDataType["Int"] = "int";
    KnownColumnDataType["Smalldatetime"] = "smalldatetime";
    KnownColumnDataType["Real"] = "real";
    KnownColumnDataType["Money"] = "money";
    KnownColumnDataType["Datetime"] = "datetime";
    KnownColumnDataType["Float"] = "float";
    KnownColumnDataType["SqlVariant"] = "sql_variant";
    KnownColumnDataType["Ntext"] = "ntext";
    KnownColumnDataType["Bit"] = "bit";
    KnownColumnDataType["Decimal"] = "decimal";
    KnownColumnDataType["Numeric"] = "numeric";
    KnownColumnDataType["Smallmoney"] = "smallmoney";
    KnownColumnDataType["Bigint"] = "bigint";
    KnownColumnDataType["Hierarchyid"] = "hierarchyid";
    KnownColumnDataType["Geometry"] = "geometry";
    KnownColumnDataType["Geography"] = "geography";
    KnownColumnDataType["Varbinary"] = "varbinary";
    KnownColumnDataType["Varchar"] = "varchar";
    KnownColumnDataType["Binary"] = "binary";
    KnownColumnDataType["Char"] = "char";
    KnownColumnDataType["Timestamp"] = "timestamp";
    KnownColumnDataType["Nvarchar"] = "nvarchar";
    KnownColumnDataType["Nchar"] = "nchar";
    KnownColumnDataType["Xml"] = "xml";
    KnownColumnDataType["Sysname"] = "sysname";
})(exports.KnownColumnDataType || (exports.KnownColumnDataType = {}));
(function (KnownTableTemporalType) {
    KnownTableTemporalType["NonTemporalTable"] = "NonTemporalTable";
    KnownTableTemporalType["HistoryTable"] = "HistoryTable";
    KnownTableTemporalType["SystemVersionedTemporalTable"] = "SystemVersionedTemporalTable";
})(exports.KnownTableTemporalType || (exports.KnownTableTemporalType = {}));
(function (KnownSecurityAlertPolicyName) {
    KnownSecurityAlertPolicyName["Default"] = "Default";
})(exports.KnownSecurityAlertPolicyName || (exports.KnownSecurityAlertPolicyName = {}));
(function (KnownCreatedByType) {
    KnownCreatedByType["User"] = "User";
    KnownCreatedByType["Application"] = "Application";
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
(function (KnownVulnerabilityAssessmentName) {
    KnownVulnerabilityAssessmentName["Default"] = "default";
})(exports.KnownVulnerabilityAssessmentName || (exports.KnownVulnerabilityAssessmentName = {}));
(function (KnownVulnerabilityAssessmentScanTriggerType) {
    KnownVulnerabilityAssessmentScanTriggerType["OnDemand"] = "OnDemand";
    KnownVulnerabilityAssessmentScanTriggerType["Recurring"] = "Recurring";
})(exports.KnownVulnerabilityAssessmentScanTriggerType || (exports.KnownVulnerabilityAssessmentScanTriggerType = {}));
(function (KnownVulnerabilityAssessmentScanState) {
    KnownVulnerabilityAssessmentScanState["Passed"] = "Passed";
    KnownVulnerabilityAssessmentScanState["Failed"] = "Failed";
    KnownVulnerabilityAssessmentScanState["FailedToRun"] = "FailedToRun";
    KnownVulnerabilityAssessmentScanState["InProgress"] = "InProgress";
})(exports.KnownVulnerabilityAssessmentScanState || (exports.KnownVulnerabilityAssessmentScanState = {}));
(function (KnownDataWarehouseUserActivityName) {
    KnownDataWarehouseUserActivityName["Current"] = "current";
})(exports.KnownDataWarehouseUserActivityName || (exports.KnownDataWarehouseUserActivityName = {}));
(function (KnownElasticPoolState) {
    KnownElasticPoolState["Creating"] = "Creating";
    KnownElasticPoolState["Ready"] = "Ready";
    KnownElasticPoolState["Disabled"] = "Disabled";
})(exports.KnownElasticPoolState || (exports.KnownElasticPoolState = {}));
(function (KnownElasticPoolLicenseType) {
    KnownElasticPoolLicenseType["LicenseIncluded"] = "LicenseIncluded";
    KnownElasticPoolLicenseType["BasePrice"] = "BasePrice";
})(exports.KnownElasticPoolLicenseType || (exports.KnownElasticPoolLicenseType = {}));
(function (KnownServerKeyType) {
    KnownServerKeyType["ServiceManaged"] = "ServiceManaged";
    KnownServerKeyType["AzureKeyVault"] = "AzureKeyVault";
})(exports.KnownServerKeyType || (exports.KnownServerKeyType = {}));
(function (KnownEncryptionProtectorName) {
    KnownEncryptionProtectorName["Current"] = "current";
})(exports.KnownEncryptionProtectorName || (exports.KnownEncryptionProtectorName = {}));
(function (KnownReadWriteEndpointFailoverPolicy) {
    KnownReadWriteEndpointFailoverPolicy["Manual"] = "Manual";
    KnownReadWriteEndpointFailoverPolicy["Automatic"] = "Automatic";
})(exports.KnownReadWriteEndpointFailoverPolicy || (exports.KnownReadWriteEndpointFailoverPolicy = {}));
(function (KnownReadOnlyEndpointFailoverPolicy) {
    KnownReadOnlyEndpointFailoverPolicy["Disabled"] = "Disabled";
    KnownReadOnlyEndpointFailoverPolicy["Enabled"] = "Enabled";
})(exports.KnownReadOnlyEndpointFailoverPolicy || (exports.KnownReadOnlyEndpointFailoverPolicy = {}));
(function (KnownFailoverGroupReplicationRole) {
    KnownFailoverGroupReplicationRole["Primary"] = "Primary";
    KnownFailoverGroupReplicationRole["Secondary"] = "Secondary";
})(exports.KnownFailoverGroupReplicationRole || (exports.KnownFailoverGroupReplicationRole = {}));
(function (KnownInstanceFailoverGroupReplicationRole) {
    KnownInstanceFailoverGroupReplicationRole["Primary"] = "Primary";
    KnownInstanceFailoverGroupReplicationRole["Secondary"] = "Secondary";
})(exports.KnownInstanceFailoverGroupReplicationRole || (exports.KnownInstanceFailoverGroupReplicationRole = {}));
(function (KnownInstancePoolLicenseType) {
    KnownInstancePoolLicenseType["LicenseIncluded"] = "LicenseIncluded";
    KnownInstancePoolLicenseType["BasePrice"] = "BasePrice";
})(exports.KnownInstancePoolLicenseType || (exports.KnownInstancePoolLicenseType = {}));
(function (KnownJobAgentState) {
    KnownJobAgentState["Creating"] = "Creating";
    KnownJobAgentState["Ready"] = "Ready";
    KnownJobAgentState["Updating"] = "Updating";
    KnownJobAgentState["Deleting"] = "Deleting";
    KnownJobAgentState["Disabled"] = "Disabled";
})(exports.KnownJobAgentState || (exports.KnownJobAgentState = {}));
(function (KnownJobExecutionLifecycle) {
    KnownJobExecutionLifecycle["Created"] = "Created";
    KnownJobExecutionLifecycle["InProgress"] = "InProgress";
    KnownJobExecutionLifecycle["WaitingForChildJobExecutions"] = "WaitingForChildJobExecutions";
    KnownJobExecutionLifecycle["WaitingForRetry"] = "WaitingForRetry";
    KnownJobExecutionLifecycle["Succeeded"] = "Succeeded";
    KnownJobExecutionLifecycle["SucceededWithSkipped"] = "SucceededWithSkipped";
    KnownJobExecutionLifecycle["Failed"] = "Failed";
    KnownJobExecutionLifecycle["TimedOut"] = "TimedOut";
    KnownJobExecutionLifecycle["Canceled"] = "Canceled";
    KnownJobExecutionLifecycle["Skipped"] = "Skipped";
})(exports.KnownJobExecutionLifecycle || (exports.KnownJobExecutionLifecycle = {}));
(function (KnownProvisioningState) {
    KnownProvisioningState["Created"] = "Created";
    KnownProvisioningState["InProgress"] = "InProgress";
    KnownProvisioningState["Succeeded"] = "Succeeded";
    KnownProvisioningState["Failed"] = "Failed";
    KnownProvisioningState["Canceled"] = "Canceled";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
(function (KnownJobTargetType) {
    KnownJobTargetType["TargetGroup"] = "TargetGroup";
    KnownJobTargetType["SqlDatabase"] = "SqlDatabase";
    KnownJobTargetType["SqlElasticPool"] = "SqlElasticPool";
    KnownJobTargetType["SqlShardMap"] = "SqlShardMap";
    KnownJobTargetType["SqlServer"] = "SqlServer";
})(exports.KnownJobTargetType || (exports.KnownJobTargetType = {}));
(function (KnownJobStepActionType) {
    KnownJobStepActionType["TSql"] = "TSql";
})(exports.KnownJobStepActionType || (exports.KnownJobStepActionType = {}));
(function (KnownJobStepActionSource) {
    KnownJobStepActionSource["Inline"] = "Inline";
})(exports.KnownJobStepActionSource || (exports.KnownJobStepActionSource = {}));
(function (KnownJobStepOutputType) {
    KnownJobStepOutputType["SqlDatabase"] = "SqlDatabase";
})(exports.KnownJobStepOutputType || (exports.KnownJobStepOutputType = {}));
(function (KnownCapabilityGroup) {
    KnownCapabilityGroup["SupportedEditions"] = "supportedEditions";
    KnownCapabilityGroup["SupportedElasticPoolEditions"] = "supportedElasticPoolEditions";
    KnownCapabilityGroup["SupportedManagedInstanceVersions"] = "supportedManagedInstanceVersions";
    KnownCapabilityGroup["SupportedInstancePoolEditions"] = "supportedInstancePoolEditions";
    KnownCapabilityGroup["SupportedManagedInstanceEditions"] = "supportedManagedInstanceEditions";
})(exports.KnownCapabilityGroup || (exports.KnownCapabilityGroup = {}));
(function (KnownMaxSizeUnit) {
    KnownMaxSizeUnit["Megabytes"] = "Megabytes";
    KnownMaxSizeUnit["Gigabytes"] = "Gigabytes";
    KnownMaxSizeUnit["Terabytes"] = "Terabytes";
    KnownMaxSizeUnit["Petabytes"] = "Petabytes";
})(exports.KnownMaxSizeUnit || (exports.KnownMaxSizeUnit = {}));
(function (KnownLogSizeUnit) {
    KnownLogSizeUnit["Megabytes"] = "Megabytes";
    KnownLogSizeUnit["Gigabytes"] = "Gigabytes";
    KnownLogSizeUnit["Terabytes"] = "Terabytes";
    KnownLogSizeUnit["Petabytes"] = "Petabytes";
    KnownLogSizeUnit["Percent"] = "Percent";
})(exports.KnownLogSizeUnit || (exports.KnownLogSizeUnit = {}));
(function (KnownPerformanceLevelUnit) {
    KnownPerformanceLevelUnit["DTU"] = "DTU";
    KnownPerformanceLevelUnit["VCores"] = "VCores";
})(exports.KnownPerformanceLevelUnit || (exports.KnownPerformanceLevelUnit = {}));
(function (KnownPauseDelayTimeUnit) {
    KnownPauseDelayTimeUnit["Minutes"] = "Minutes";
})(exports.KnownPauseDelayTimeUnit || (exports.KnownPauseDelayTimeUnit = {}));
(function (KnownStorageCapabilityStorageAccountType) {
    KnownStorageCapabilityStorageAccountType["GRS"] = "GRS";
    KnownStorageCapabilityStorageAccountType["LRS"] = "LRS";
    KnownStorageCapabilityStorageAccountType["ZRS"] = "ZRS";
})(exports.KnownStorageCapabilityStorageAccountType || (exports.KnownStorageCapabilityStorageAccountType = {}));
(function (KnownLongTermRetentionPolicyName) {
    KnownLongTermRetentionPolicyName["Default"] = "default";
})(exports.KnownLongTermRetentionPolicyName || (exports.KnownLongTermRetentionPolicyName = {}));
(function (KnownDayOfWeek) {
    KnownDayOfWeek["Sunday"] = "Sunday";
    KnownDayOfWeek["Monday"] = "Monday";
    KnownDayOfWeek["Tuesday"] = "Tuesday";
    KnownDayOfWeek["Wednesday"] = "Wednesday";
    KnownDayOfWeek["Thursday"] = "Thursday";
    KnownDayOfWeek["Friday"] = "Friday";
    KnownDayOfWeek["Saturday"] = "Saturday";
})(exports.KnownDayOfWeek || (exports.KnownDayOfWeek = {}));
(function (KnownManagedShortTermRetentionPolicyName) {
    KnownManagedShortTermRetentionPolicyName["Default"] = "default";
})(exports.KnownManagedShortTermRetentionPolicyName || (exports.KnownManagedShortTermRetentionPolicyName = {}));
(function (KnownQueryTimeGrainType) {
    KnownQueryTimeGrainType["PT1H"] = "PT1H";
    KnownQueryTimeGrainType["P1D"] = "P1D";
})(exports.KnownQueryTimeGrainType || (exports.KnownQueryTimeGrainType = {}));
(function (KnownQueryMetricUnitType) {
    KnownQueryMetricUnitType["Percentage"] = "percentage";
    KnownQueryMetricUnitType["KB"] = "KB";
    KnownQueryMetricUnitType["Microseconds"] = "microseconds";
    KnownQueryMetricUnitType["Count"] = "count";
})(exports.KnownQueryMetricUnitType || (exports.KnownQueryMetricUnitType = {}));
(function (KnownRestoreDetailsName) {
    KnownRestoreDetailsName["Default"] = "Default";
})(exports.KnownRestoreDetailsName || (exports.KnownRestoreDetailsName = {}));
(function (KnownManagedDatabaseStatus) {
    KnownManagedDatabaseStatus["Online"] = "Online";
    KnownManagedDatabaseStatus["Offline"] = "Offline";
    KnownManagedDatabaseStatus["Shutdown"] = "Shutdown";
    KnownManagedDatabaseStatus["Creating"] = "Creating";
    KnownManagedDatabaseStatus["Inaccessible"] = "Inaccessible";
    KnownManagedDatabaseStatus["Restoring"] = "Restoring";
    KnownManagedDatabaseStatus["Updating"] = "Updating";
})(exports.KnownManagedDatabaseStatus || (exports.KnownManagedDatabaseStatus = {}));
(function (KnownCatalogCollationType) {
    KnownCatalogCollationType["DatabaseDefault"] = "DATABASE_DEFAULT";
    KnownCatalogCollationType["SQLLatin1GeneralCP1CIAS"] = "SQL_Latin1_General_CP1_CI_AS";
})(exports.KnownCatalogCollationType || (exports.KnownCatalogCollationType = {}));
(function (KnownManagedDatabaseCreateMode) {
    KnownManagedDatabaseCreateMode["Default"] = "Default";
    KnownManagedDatabaseCreateMode["RestoreExternalBackup"] = "RestoreExternalBackup";
    KnownManagedDatabaseCreateMode["PointInTimeRestore"] = "PointInTimeRestore";
    KnownManagedDatabaseCreateMode["Recovery"] = "Recovery";
    KnownManagedDatabaseCreateMode["RestoreLongTermRetentionBackup"] = "RestoreLongTermRetentionBackup";
})(exports.KnownManagedDatabaseCreateMode || (exports.KnownManagedDatabaseCreateMode = {}));
(function (KnownTransparentDataEncryptionName) {
    KnownTransparentDataEncryptionName["Current"] = "current";
})(exports.KnownTransparentDataEncryptionName || (exports.KnownTransparentDataEncryptionName = {}));
(function (KnownManagedInstanceAdministratorType) {
    KnownManagedInstanceAdministratorType["ActiveDirectory"] = "ActiveDirectory";
})(exports.KnownManagedInstanceAdministratorType || (exports.KnownManagedInstanceAdministratorType = {}));
(function (KnownAdministratorName) {
    KnownAdministratorName["ActiveDirectory"] = "ActiveDirectory";
})(exports.KnownAdministratorName || (exports.KnownAdministratorName = {}));
(function (KnownAuthenticationName) {
    KnownAuthenticationName["Default"] = "Default";
})(exports.KnownAuthenticationName || (exports.KnownAuthenticationName = {}));
(function (KnownManagedInstanceLongTermRetentionPolicyName) {
    KnownManagedInstanceLongTermRetentionPolicyName["Default"] = "default";
})(exports.KnownManagedInstanceLongTermRetentionPolicyName || (exports.KnownManagedInstanceLongTermRetentionPolicyName = {}));
(function (KnownManagementOperationState) {
    KnownManagementOperationState["Pending"] = "Pending";
    KnownManagementOperationState["InProgress"] = "InProgress";
    KnownManagementOperationState["Succeeded"] = "Succeeded";
    KnownManagementOperationState["Failed"] = "Failed";
    KnownManagementOperationState["CancelInProgress"] = "CancelInProgress";
    KnownManagementOperationState["Cancelled"] = "Cancelled";
})(exports.KnownManagementOperationState || (exports.KnownManagementOperationState = {}));
(function (KnownUpsertManagedServerOperationStepStatus) {
    KnownUpsertManagedServerOperationStepStatus["NotStarted"] = "NotStarted";
    KnownUpsertManagedServerOperationStepStatus["InProgress"] = "InProgress";
    KnownUpsertManagedServerOperationStepStatus["SlowedDown"] = "SlowedDown";
    KnownUpsertManagedServerOperationStepStatus["Completed"] = "Completed";
    KnownUpsertManagedServerOperationStepStatus["Failed"] = "Failed";
    KnownUpsertManagedServerOperationStepStatus["Canceled"] = "Canceled";
})(exports.KnownUpsertManagedServerOperationStepStatus || (exports.KnownUpsertManagedServerOperationStepStatus = {}));
(function (KnownOperationOrigin) {
    KnownOperationOrigin["User"] = "user";
    KnownOperationOrigin["System"] = "system";
})(exports.KnownOperationOrigin || (exports.KnownOperationOrigin = {}));
(function (KnownPrivateLinkServiceConnectionStateStatus) {
    KnownPrivateLinkServiceConnectionStateStatus["Approved"] = "Approved";
    KnownPrivateLinkServiceConnectionStateStatus["Pending"] = "Pending";
    KnownPrivateLinkServiceConnectionStateStatus["Rejected"] = "Rejected";
    KnownPrivateLinkServiceConnectionStateStatus["Disconnected"] = "Disconnected";
})(exports.KnownPrivateLinkServiceConnectionStateStatus || (exports.KnownPrivateLinkServiceConnectionStateStatus = {}));
(function (KnownPrivateLinkServiceConnectionStateActionsRequire) {
    KnownPrivateLinkServiceConnectionStateActionsRequire["None"] = "None";
})(exports.KnownPrivateLinkServiceConnectionStateActionsRequire || (exports.KnownPrivateLinkServiceConnectionStateActionsRequire = {}));
(function (KnownPrivateEndpointProvisioningState) {
    KnownPrivateEndpointProvisioningState["Approving"] = "Approving";
    KnownPrivateEndpointProvisioningState["Ready"] = "Ready";
    KnownPrivateEndpointProvisioningState["Dropping"] = "Dropping";
    KnownPrivateEndpointProvisioningState["Failed"] = "Failed";
    KnownPrivateEndpointProvisioningState["Rejecting"] = "Rejecting";
})(exports.KnownPrivateEndpointProvisioningState || (exports.KnownPrivateEndpointProvisioningState = {}));
(function (KnownAdministratorType) {
    KnownAdministratorType["ActiveDirectory"] = "ActiveDirectory";
})(exports.KnownAdministratorType || (exports.KnownAdministratorType = {}));
(function (KnownServerTrustGroupPropertiesTrustScopesItem) {
    KnownServerTrustGroupPropertiesTrustScopesItem["GlobalTransactions"] = "GlobalTransactions";
    KnownServerTrustGroupPropertiesTrustScopesItem["ServiceBroker"] = "ServiceBroker";
})(exports.KnownServerTrustGroupPropertiesTrustScopesItem || (exports.KnownServerTrustGroupPropertiesTrustScopesItem = {}));
(function (KnownSqlAgentConfigurationPropertiesState) {
    KnownSqlAgentConfigurationPropertiesState["Enabled"] = "Enabled";
    KnownSqlAgentConfigurationPropertiesState["Disabled"] = "Disabled";
})(exports.KnownSqlAgentConfigurationPropertiesState || (exports.KnownSqlAgentConfigurationPropertiesState = {}));
(function (KnownSyncAgentState) {
    KnownSyncAgentState["Online"] = "Online";
    KnownSyncAgentState["Offline"] = "Offline";
    KnownSyncAgentState["NeverConnected"] = "NeverConnected";
})(exports.KnownSyncAgentState || (exports.KnownSyncAgentState = {}));
(function (KnownSyncMemberDbType) {
    KnownSyncMemberDbType["AzureSqlDatabase"] = "AzureSqlDatabase";
    KnownSyncMemberDbType["SqlServerDatabase"] = "SqlServerDatabase";
})(exports.KnownSyncMemberDbType || (exports.KnownSyncMemberDbType = {}));
(function (KnownEnum60) {
    KnownEnum60["All"] = "All";
    KnownEnum60["Error"] = "Error";
    KnownEnum60["Warning"] = "Warning";
    KnownEnum60["Success"] = "Success";
})(exports.KnownEnum60 || (exports.KnownEnum60 = {}));
(function (KnownSyncGroupLogType) {
    KnownSyncGroupLogType["All"] = "All";
    KnownSyncGroupLogType["Error"] = "Error";
    KnownSyncGroupLogType["Warning"] = "Warning";
    KnownSyncGroupLogType["Success"] = "Success";
})(exports.KnownSyncGroupLogType || (exports.KnownSyncGroupLogType = {}));
(function (KnownSyncConflictResolutionPolicy) {
    KnownSyncConflictResolutionPolicy["HubWin"] = "HubWin";
    KnownSyncConflictResolutionPolicy["MemberWin"] = "MemberWin";
})(exports.KnownSyncConflictResolutionPolicy || (exports.KnownSyncConflictResolutionPolicy = {}));
(function (KnownSyncGroupState) {
    KnownSyncGroupState["NotReady"] = "NotReady";
    KnownSyncGroupState["Error"] = "Error";
    KnownSyncGroupState["Warning"] = "Warning";
    KnownSyncGroupState["Progressing"] = "Progressing";
    KnownSyncGroupState["Good"] = "Good";
})(exports.KnownSyncGroupState || (exports.KnownSyncGroupState = {}));
(function (KnownSyncDirection) {
    KnownSyncDirection["Bidirectional"] = "Bidirectional";
    KnownSyncDirection["OneWayMemberToHub"] = "OneWayMemberToHub";
    KnownSyncDirection["OneWayHubToMember"] = "OneWayHubToMember";
})(exports.KnownSyncDirection || (exports.KnownSyncDirection = {}));
(function (KnownSyncMemberState) {
    KnownSyncMemberState["SyncInProgress"] = "SyncInProgress";
    KnownSyncMemberState["SyncSucceeded"] = "SyncSucceeded";
    KnownSyncMemberState["SyncFailed"] = "SyncFailed";
    KnownSyncMemberState["DisabledTombstoneCleanup"] = "DisabledTombstoneCleanup";
    KnownSyncMemberState["DisabledBackupRestore"] = "DisabledBackupRestore";
    KnownSyncMemberState["SyncSucceededWithWarnings"] = "SyncSucceededWithWarnings";
    KnownSyncMemberState["SyncCancelling"] = "SyncCancelling";
    KnownSyncMemberState["SyncCancelled"] = "SyncCancelled";
    KnownSyncMemberState["UnProvisioned"] = "UnProvisioned";
    KnownSyncMemberState["Provisioning"] = "Provisioning";
    KnownSyncMemberState["Provisioned"] = "Provisioned";
    KnownSyncMemberState["ProvisionFailed"] = "ProvisionFailed";
    KnownSyncMemberState["DeProvisioning"] = "DeProvisioning";
    KnownSyncMemberState["DeProvisioned"] = "DeProvisioned";
    KnownSyncMemberState["DeProvisionFailed"] = "DeProvisionFailed";
    KnownSyncMemberState["Reprovisioning"] = "Reprovisioning";
    KnownSyncMemberState["ReprovisionFailed"] = "ReprovisionFailed";
    KnownSyncMemberState["UnReprovisioned"] = "UnReprovisioned";
})(exports.KnownSyncMemberState || (exports.KnownSyncMemberState = {}));
(function (KnownDnsRefreshConfigurationPropertiesStatus) {
    KnownDnsRefreshConfigurationPropertiesStatus["Succeeded"] = "Succeeded";
    KnownDnsRefreshConfigurationPropertiesStatus["Failed"] = "Failed";
})(exports.KnownDnsRefreshConfigurationPropertiesStatus || (exports.KnownDnsRefreshConfigurationPropertiesStatus = {}));
(function (KnownVirtualNetworkRuleState) {
    KnownVirtualNetworkRuleState["Initializing"] = "Initializing";
    KnownVirtualNetworkRuleState["InProgress"] = "InProgress";
    KnownVirtualNetworkRuleState["Ready"] = "Ready";
    KnownVirtualNetworkRuleState["Failed"] = "Failed";
    KnownVirtualNetworkRuleState["Deleting"] = "Deleting";
    KnownVirtualNetworkRuleState["Unknown"] = "Unknown";
})(exports.KnownVirtualNetworkRuleState || (exports.KnownVirtualNetworkRuleState = {}));
(function (KnownShortTermRetentionPolicyName) {
    KnownShortTermRetentionPolicyName["Default"] = "default";
})(exports.KnownShortTermRetentionPolicyName || (exports.KnownShortTermRetentionPolicyName = {}));
(function (KnownDiffBackupIntervalInHours) {
    KnownDiffBackupIntervalInHours[KnownDiffBackupIntervalInHours["Twelve"] = 12] = "Twelve";
    KnownDiffBackupIntervalInHours[KnownDiffBackupIntervalInHours["TwentyFour"] = 24] = "TwentyFour";
})(exports.KnownDiffBackupIntervalInHours || (exports.KnownDiffBackupIntervalInHours = {}));
(function (KnownOperationMode) {
    KnownOperationMode["PolybaseImport"] = "PolybaseImport";
})(exports.KnownOperationMode || (exports.KnownOperationMode = {}));
(function (KnownStorageKeyType) {
    KnownStorageKeyType["SharedAccessKey"] = "SharedAccessKey";
    KnownStorageKeyType["StorageAccessKey"] = "StorageAccessKey";
})(exports.KnownStorageKeyType || (exports.KnownStorageKeyType = {}));
(function (KnownLedgerDigestUploadsName) {
    KnownLedgerDigestUploadsName["Current"] = "current";
})(exports.KnownLedgerDigestUploadsName || (exports.KnownLedgerDigestUploadsName = {}));
(function (KnownReplicationState) {
    KnownReplicationState["Pending"] = "PENDING";
    KnownReplicationState["Seeding"] = "SEEDING";
    KnownReplicationState["CatchUP"] = "CATCH_UP";
    KnownReplicationState["Suspended"] = "SUSPENDED";
})(exports.KnownReplicationState || (exports.KnownReplicationState = {}));
(function (KnownReplicationLinkType) {
    KnownReplicationLinkType["GEO"] = "GEO";
    KnownReplicationLinkType["Named"] = "NAMED";
})(exports.KnownReplicationLinkType || (exports.KnownReplicationLinkType = {}));
(function (KnownIdentityType) {
    KnownIdentityType["None"] = "None";
    KnownIdentityType["SystemAssigned"] = "SystemAssigned";
    KnownIdentityType["UserAssigned"] = "UserAssigned";
    KnownIdentityType["SystemAssignedUserAssigned"] = "SystemAssigned,UserAssigned";
})(exports.KnownIdentityType || (exports.KnownIdentityType = {}));
(function (KnownServerNetworkAccessFlag) {
    KnownServerNetworkAccessFlag["Enabled"] = "Enabled";
    KnownServerNetworkAccessFlag["Disabled"] = "Disabled";
})(exports.KnownServerNetworkAccessFlag || (exports.KnownServerNetworkAccessFlag = {}));
(function (KnownServerWorkspaceFeature) {
    KnownServerWorkspaceFeature["Connected"] = "Connected";
    KnownServerWorkspaceFeature["Disconnected"] = "Disconnected";
})(exports.KnownServerWorkspaceFeature || (exports.KnownServerWorkspaceFeature = {}));
(function (KnownPrincipalType) {
    KnownPrincipalType["User"] = "User";
    KnownPrincipalType["Group"] = "Group";
    KnownPrincipalType["Application"] = "Application";
})(exports.KnownPrincipalType || (exports.KnownPrincipalType = {}));
(function (KnownDatabaseIdentityType) {
    KnownDatabaseIdentityType["None"] = "None";
    KnownDatabaseIdentityType["UserAssigned"] = "UserAssigned";
})(exports.KnownDatabaseIdentityType || (exports.KnownDatabaseIdentityType = {}));
(function (KnownCreateMode) {
    KnownCreateMode["Default"] = "Default";
    KnownCreateMode["Copy"] = "Copy";
    KnownCreateMode["Secondary"] = "Secondary";
    KnownCreateMode["PointInTimeRestore"] = "PointInTimeRestore";
    KnownCreateMode["Restore"] = "Restore";
    KnownCreateMode["Recovery"] = "Recovery";
    KnownCreateMode["RestoreExternalBackup"] = "RestoreExternalBackup";
    KnownCreateMode["RestoreExternalBackupSecondary"] = "RestoreExternalBackupSecondary";
    KnownCreateMode["RestoreLongTermRetentionBackup"] = "RestoreLongTermRetentionBackup";
    KnownCreateMode["OnlineSecondary"] = "OnlineSecondary";
})(exports.KnownCreateMode || (exports.KnownCreateMode = {}));
(function (KnownSampleName) {
    KnownSampleName["AdventureWorksLT"] = "AdventureWorksLT";
    KnownSampleName["WideWorldImportersStd"] = "WideWorldImportersStd";
    KnownSampleName["WideWorldImportersFull"] = "WideWorldImportersFull";
})(exports.KnownSampleName || (exports.KnownSampleName = {}));
(function (KnownDatabaseStatus) {
    KnownDatabaseStatus["Online"] = "Online";
    KnownDatabaseStatus["Restoring"] = "Restoring";
    KnownDatabaseStatus["RecoveryPending"] = "RecoveryPending";
    KnownDatabaseStatus["Recovering"] = "Recovering";
    KnownDatabaseStatus["Suspect"] = "Suspect";
    KnownDatabaseStatus["Offline"] = "Offline";
    KnownDatabaseStatus["Standby"] = "Standby";
    KnownDatabaseStatus["Shutdown"] = "Shutdown";
    KnownDatabaseStatus["EmergencyMode"] = "EmergencyMode";
    KnownDatabaseStatus["AutoClosed"] = "AutoClosed";
    KnownDatabaseStatus["Copying"] = "Copying";
    KnownDatabaseStatus["Creating"] = "Creating";
    KnownDatabaseStatus["Inaccessible"] = "Inaccessible";
    KnownDatabaseStatus["OfflineSecondary"] = "OfflineSecondary";
    KnownDatabaseStatus["Pausing"] = "Pausing";
    KnownDatabaseStatus["Paused"] = "Paused";
    KnownDatabaseStatus["Resuming"] = "Resuming";
    KnownDatabaseStatus["Scaling"] = "Scaling";
    KnownDatabaseStatus["OfflineChangingDwPerformanceTiers"] = "OfflineChangingDwPerformanceTiers";
    KnownDatabaseStatus["OnlineChangingDwPerformanceTiers"] = "OnlineChangingDwPerformanceTiers";
    KnownDatabaseStatus["Disabled"] = "Disabled";
    KnownDatabaseStatus["Stopping"] = "Stopping";
    KnownDatabaseStatus["Stopped"] = "Stopped";
    KnownDatabaseStatus["Starting"] = "Starting";
})(exports.KnownDatabaseStatus || (exports.KnownDatabaseStatus = {}));
(function (KnownDatabaseLicenseType) {
    KnownDatabaseLicenseType["LicenseIncluded"] = "LicenseIncluded";
    KnownDatabaseLicenseType["BasePrice"] = "BasePrice";
})(exports.KnownDatabaseLicenseType || (exports.KnownDatabaseLicenseType = {}));
(function (KnownDatabaseReadScale) {
    KnownDatabaseReadScale["Enabled"] = "Enabled";
    KnownDatabaseReadScale["Disabled"] = "Disabled";
})(exports.KnownDatabaseReadScale || (exports.KnownDatabaseReadScale = {}));
(function (KnownSecondaryType) {
    KnownSecondaryType["Geo"] = "Geo";
    KnownSecondaryType["Named"] = "Named";
})(exports.KnownSecondaryType || (exports.KnownSecondaryType = {}));
(function (KnownBackupStorageRedundancy) {
    KnownBackupStorageRedundancy["Geo"] = "Geo";
    KnownBackupStorageRedundancy["Local"] = "Local";
    KnownBackupStorageRedundancy["Zone"] = "Zone";
    KnownBackupStorageRedundancy["GeoZone"] = "GeoZone";
})(exports.KnownBackupStorageRedundancy || (exports.KnownBackupStorageRedundancy = {}));
(function (KnownReplicaType) {
    KnownReplicaType["Primary"] = "Primary";
    KnownReplicaType["ReadableSecondary"] = "ReadableSecondary";
})(exports.KnownReplicaType || (exports.KnownReplicaType = {}));
(function (KnownDatabaseState) {
    KnownDatabaseState["All"] = "All";
    KnownDatabaseState["Live"] = "Live";
    KnownDatabaseState["Deleted"] = "Deleted";
})(exports.KnownDatabaseState || (exports.KnownDatabaseState = {}));
(function (KnownManagedInstancePropertiesProvisioningState) {
    KnownManagedInstancePropertiesProvisioningState["Creating"] = "Creating";
    KnownManagedInstancePropertiesProvisioningState["Deleting"] = "Deleting";
    KnownManagedInstancePropertiesProvisioningState["Updating"] = "Updating";
    KnownManagedInstancePropertiesProvisioningState["Unknown"] = "Unknown";
    KnownManagedInstancePropertiesProvisioningState["Succeeded"] = "Succeeded";
    KnownManagedInstancePropertiesProvisioningState["Failed"] = "Failed";
    KnownManagedInstancePropertiesProvisioningState["Accepted"] = "Accepted";
    KnownManagedInstancePropertiesProvisioningState["Created"] = "Created";
    KnownManagedInstancePropertiesProvisioningState["Deleted"] = "Deleted";
    KnownManagedInstancePropertiesProvisioningState["Unrecognized"] = "Unrecognized";
    KnownManagedInstancePropertiesProvisioningState["Running"] = "Running";
    KnownManagedInstancePropertiesProvisioningState["Canceled"] = "Canceled";
    KnownManagedInstancePropertiesProvisioningState["NotSpecified"] = "NotSpecified";
    KnownManagedInstancePropertiesProvisioningState["Registering"] = "Registering";
    KnownManagedInstancePropertiesProvisioningState["TimedOut"] = "TimedOut";
})(exports.KnownManagedInstancePropertiesProvisioningState || (exports.KnownManagedInstancePropertiesProvisioningState = {}));
(function (KnownManagedServerCreateMode) {
    KnownManagedServerCreateMode["Default"] = "Default";
    KnownManagedServerCreateMode["PointInTimeRestore"] = "PointInTimeRestore";
})(exports.KnownManagedServerCreateMode || (exports.KnownManagedServerCreateMode = {}));
(function (KnownManagedInstanceLicenseType) {
    KnownManagedInstanceLicenseType["LicenseIncluded"] = "LicenseIncluded";
    KnownManagedInstanceLicenseType["BasePrice"] = "BasePrice";
})(exports.KnownManagedInstanceLicenseType || (exports.KnownManagedInstanceLicenseType = {}));
(function (KnownManagedInstanceProxyOverride) {
    KnownManagedInstanceProxyOverride["Proxy"] = "Proxy";
    KnownManagedInstanceProxyOverride["Redirect"] = "Redirect";
    KnownManagedInstanceProxyOverride["Default"] = "Default";
})(exports.KnownManagedInstanceProxyOverride || (exports.KnownManagedInstanceProxyOverride = {}));
(function (KnownServicePrincipalType) {
    KnownServicePrincipalType["None"] = "None";
    KnownServicePrincipalType["SystemAssigned"] = "SystemAssigned";
})(exports.KnownServicePrincipalType || (exports.KnownServicePrincipalType = {}));
(function (KnownAggregationFunctionType) {
    KnownAggregationFunctionType["Avg"] = "avg";
    KnownAggregationFunctionType["Min"] = "min";
    KnownAggregationFunctionType["Max"] = "max";
    KnownAggregationFunctionType["Stdev"] = "stdev";
    KnownAggregationFunctionType["Sum"] = "sum";
})(exports.KnownAggregationFunctionType || (exports.KnownAggregationFunctionType = {}));
(function (KnownMetricType) {
    KnownMetricType["Cpu"] = "cpu";
    KnownMetricType["Io"] = "io";
    KnownMetricType["LogIo"] = "logIo";
    KnownMetricType["Duration"] = "duration";
    KnownMetricType["Dtu"] = "dtu";
})(exports.KnownMetricType || (exports.KnownMetricType = {}));
(function (KnownConnectionPolicyName) {
    KnownConnectionPolicyName["Default"] = "default";
})(exports.KnownConnectionPolicyName || (exports.KnownConnectionPolicyName = {}));
(function (KnownServerConnectionType) {
    KnownServerConnectionType["Default"] = "Default";
    KnownServerConnectionType["Redirect"] = "Redirect";
    KnownServerConnectionType["Proxy"] = "Proxy";
})(exports.KnownServerConnectionType || (exports.KnownServerConnectionType = {}));
(function (KnownServiceObjectiveName) {
    KnownServiceObjectiveName["System"] = "System";
    KnownServiceObjectiveName["System0"] = "System0";
    KnownServiceObjectiveName["System1"] = "System1";
    KnownServiceObjectiveName["System2"] = "System2";
    KnownServiceObjectiveName["System3"] = "System3";
    KnownServiceObjectiveName["System4"] = "System4";
    KnownServiceObjectiveName["System2L"] = "System2L";
    KnownServiceObjectiveName["System3L"] = "System3L";
    KnownServiceObjectiveName["System4L"] = "System4L";
    KnownServiceObjectiveName["Free"] = "Free";
    KnownServiceObjectiveName["Basic"] = "Basic";
    KnownServiceObjectiveName["S0"] = "S0";
    KnownServiceObjectiveName["S1"] = "S1";
    KnownServiceObjectiveName["S2"] = "S2";
    KnownServiceObjectiveName["S3"] = "S3";
    KnownServiceObjectiveName["S4"] = "S4";
    KnownServiceObjectiveName["S6"] = "S6";
    KnownServiceObjectiveName["S7"] = "S7";
    KnownServiceObjectiveName["S9"] = "S9";
    KnownServiceObjectiveName["S12"] = "S12";
    KnownServiceObjectiveName["P1"] = "P1";
    KnownServiceObjectiveName["P2"] = "P2";
    KnownServiceObjectiveName["P3"] = "P3";
    KnownServiceObjectiveName["P4"] = "P4";
    KnownServiceObjectiveName["P6"] = "P6";
    KnownServiceObjectiveName["P11"] = "P11";
    KnownServiceObjectiveName["P15"] = "P15";
    KnownServiceObjectiveName["PRS1"] = "PRS1";
    KnownServiceObjectiveName["PRS2"] = "PRS2";
    KnownServiceObjectiveName["PRS4"] = "PRS4";
    KnownServiceObjectiveName["PRS6"] = "PRS6";
    KnownServiceObjectiveName["DW100"] = "DW100";
    KnownServiceObjectiveName["DW200"] = "DW200";
    KnownServiceObjectiveName["DW300"] = "DW300";
    KnownServiceObjectiveName["DW400"] = "DW400";
    KnownServiceObjectiveName["DW500"] = "DW500";
    KnownServiceObjectiveName["DW600"] = "DW600";
    KnownServiceObjectiveName["DW1000"] = "DW1000";
    KnownServiceObjectiveName["DW1200"] = "DW1200";
    KnownServiceObjectiveName["DW1000C"] = "DW1000c";
    KnownServiceObjectiveName["DW1500"] = "DW1500";
    KnownServiceObjectiveName["DW1500C"] = "DW1500c";
    KnownServiceObjectiveName["DW2000"] = "DW2000";
    KnownServiceObjectiveName["DW2000C"] = "DW2000c";
    KnownServiceObjectiveName["DW3000"] = "DW3000";
    KnownServiceObjectiveName["DW2500C"] = "DW2500c";
    KnownServiceObjectiveName["DW3000C"] = "DW3000c";
    KnownServiceObjectiveName["DW6000"] = "DW6000";
    KnownServiceObjectiveName["DW5000C"] = "DW5000c";
    KnownServiceObjectiveName["DW6000C"] = "DW6000c";
    KnownServiceObjectiveName["DW7500C"] = "DW7500c";
    KnownServiceObjectiveName["DW10000C"] = "DW10000c";
    KnownServiceObjectiveName["DW15000C"] = "DW15000c";
    KnownServiceObjectiveName["DW30000C"] = "DW30000c";
    KnownServiceObjectiveName["DS100"] = "DS100";
    KnownServiceObjectiveName["DS200"] = "DS200";
    KnownServiceObjectiveName["DS300"] = "DS300";
    KnownServiceObjectiveName["DS400"] = "DS400";
    KnownServiceObjectiveName["DS500"] = "DS500";
    KnownServiceObjectiveName["DS600"] = "DS600";
    KnownServiceObjectiveName["DS1000"] = "DS1000";
    KnownServiceObjectiveName["DS1200"] = "DS1200";
    KnownServiceObjectiveName["DS1500"] = "DS1500";
    KnownServiceObjectiveName["DS2000"] = "DS2000";
    KnownServiceObjectiveName["ElasticPool"] = "ElasticPool";
})(exports.KnownServiceObjectiveName || (exports.KnownServiceObjectiveName = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RecoverableDatabaseListResult = {
    type: {
        name: "Composite",
        className: "RecoverableDatabaseListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecoverableDatabase"
                        }
                    }
                }
            }
        }
    }
};
const DataMaskingRuleListResult = {
    type: {
        name: "Composite",
        className: "DataMaskingRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataMaskingRule"
                        }
                    }
                }
            }
        }
    }
};
const GeoBackupPolicyListResult = {
    type: {
        name: "Composite",
        className: "GeoBackupPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GeoBackupPolicy"
                        }
                    }
                }
            }
        }
    }
};
const MetricListResult = {
    type: {
        name: "Composite",
        className: "MetricListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Metric"
                        }
                    }
                }
            }
        }
    }
};
const Metric = {
    type: {
        name: "Composite",
        className: "Metric",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            timeGrain: {
                serializedName: "timeGrain",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "MetricName"
                }
            },
            metricValues: {
                serializedName: "metricValues",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricValue"
                        }
                    }
                }
            }
        }
    }
};
const MetricName = {
    type: {
        name: "Composite",
        className: "MetricName",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetricValue = {
    type: {
        name: "Composite",
        className: "MetricValue",
        modelProperties: {
            count: {
                serializedName: "count",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            average: {
                serializedName: "average",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maximum: {
                serializedName: "maximum",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            minimum: {
                serializedName: "minimum",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            timestamp: {
                serializedName: "timestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            total: {
                serializedName: "total",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const MetricDefinitionListResult = {
    type: {
        name: "Composite",
        className: "MetricDefinitionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricDefinition"
                        }
                    }
                }
            }
        }
    }
};
const MetricDefinition = {
    type: {
        name: "Composite",
        className: "MetricDefinition",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "MetricName"
                }
            },
            primaryAggregationType: {
                serializedName: "primaryAggregationType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourceUri: {
                serializedName: "resourceUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            metricAvailabilities: {
                serializedName: "metricAvailabilities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricAvailability"
                        }
                    }
                }
            }
        }
    }
};
const MetricAvailability = {
    type: {
        name: "Composite",
        className: "MetricAvailability",
        modelProperties: {
            retention: {
                serializedName: "retention",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            timeGrain: {
                serializedName: "timeGrain",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UnlinkParameters = {
    type: {
        name: "Composite",
        className: "UnlinkParameters",
        modelProperties: {
            forcedTermination: {
                serializedName: "forcedTermination",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ServerCommunicationLinkListResult = {
    type: {
        name: "Composite",
        className: "ServerCommunicationLinkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerCommunicationLink"
                        }
                    }
                }
            }
        }
    }
};
const ServiceObjectiveListResult = {
    type: {
        name: "Composite",
        className: "ServiceObjectiveListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceObjective"
                        }
                    }
                }
            }
        }
    }
};
const ElasticPoolActivityListResult = {
    type: {
        name: "Composite",
        className: "ElasticPoolActivityListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ElasticPoolActivity"
                        }
                    }
                }
            }
        }
    }
};
const ElasticPoolDatabaseActivityListResult = {
    type: {
        name: "Composite",
        className: "ElasticPoolDatabaseActivityListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ElasticPoolDatabaseActivity"
                        }
                    }
                }
            }
        }
    }
};
const ServerUsageListResult = {
    type: {
        name: "Composite",
        className: "ServerUsageListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerUsage"
                        }
                    }
                }
            }
        }
    }
};
const ServerUsage = {
    type: {
        name: "Composite",
        className: "ServerUsage",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourceName: {
                serializedName: "resourceName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            nextResetTime: {
                serializedName: "nextResetTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ExtendedDatabaseBlobAuditingPolicyListResult = {
    type: {
        name: "Composite",
        className: "ExtendedDatabaseBlobAuditingPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExtendedDatabaseBlobAuditingPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExtendedServerBlobAuditingPolicyListResult = {
    type: {
        name: "Composite",
        className: "ExtendedServerBlobAuditingPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExtendedServerBlobAuditingPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerBlobAuditingPolicyListResult = {
    type: {
        name: "Composite",
        className: "ServerBlobAuditingPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerBlobAuditingPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseBlobAuditingPolicyListResult = {
    type: {
        name: "Composite",
        className: "DatabaseBlobAuditingPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseBlobAuditingPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RecommendedActionStateInfo = {
    type: {
        name: "Composite",
        className: "RecommendedActionStateInfo",
        modelProperties: {
            currentValue: {
                serializedName: "currentValue",
                required: true,
                type: {
                    name: "String"
                }
            },
            actionInitiatedBy: {
                serializedName: "actionInitiatedBy",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["User", "System"]
                }
            },
            lastModified: {
                serializedName: "lastModified",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const RecommendedActionImplementationInfo = {
    type: {
        name: "Composite",
        className: "RecommendedActionImplementationInfo",
        modelProperties: {
            method: {
                serializedName: "method",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["TSql", "AzurePowerShell"]
                }
            },
            script: {
                serializedName: "script",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RecommendedActionErrorInfo = {
    type: {
        name: "Composite",
        className: "RecommendedActionErrorInfo",
        modelProperties: {
            errorCode: {
                serializedName: "errorCode",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            isRetryable: {
                serializedName: "isRetryable",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Yes", "No"]
                }
            }
        }
    }
};
const RecommendedActionImpactRecord = {
    type: {
        name: "Composite",
        className: "RecommendedActionImpactRecord",
        modelProperties: {
            dimensionName: {
                serializedName: "dimensionName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            absoluteValue: {
                serializedName: "absoluteValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            changeValueAbsolute: {
                serializedName: "changeValueAbsolute",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            changeValueRelative: {
                serializedName: "changeValueRelative",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const RecommendedActionMetricInfo = {
    type: {
        name: "Composite",
        className: "RecommendedActionMetricInfo",
        modelProperties: {
            metricName: {
                serializedName: "metricName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            timeGrain: {
                serializedName: "timeGrain",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AutomaticTuningOptions = {
    type: {
        name: "Composite",
        className: "AutomaticTuningOptions",
        modelProperties: {
            desiredState: {
                serializedName: "desiredState",
                type: {
                    name: "Enum",
                    allowedValues: ["Off", "On", "Default"]
                }
            },
            actualState: {
                serializedName: "actualState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Off", "On"]
                }
            },
            reasonCode: {
                serializedName: "reasonCode",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            reasonDesc: {
                serializedName: "reasonDesc",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Default",
                        "Disabled",
                        "AutoConfigured",
                        "InheritedFromServer",
                        "QueryStoreOff",
                        "QueryStoreReadOnly",
                        "NotSupported"
                    ]
                }
            }
        }
    }
};
const DatabaseColumnListResult = {
    type: {
        name: "Composite",
        className: "DatabaseColumnListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseColumn"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseSchemaListResult = {
    type: {
        name: "Composite",
        className: "DatabaseSchemaListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseSchema"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const DatabaseSecurityAlertListResult = {
    type: {
        name: "Composite",
        className: "DatabaseSecurityAlertListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseSecurityAlertPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseTableListResult = {
    type: {
        name: "Composite",
        className: "DatabaseTableListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseTable"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseVulnerabilityAssessmentRuleBaselineItem = {
    type: {
        name: "Composite",
        className: "DatabaseVulnerabilityAssessmentRuleBaselineItem",
        modelProperties: {
            result: {
                serializedName: "result",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VulnerabilityAssessmentRecurringScansProperties = {
    type: {
        name: "Composite",
        className: "VulnerabilityAssessmentRecurringScansProperties",
        modelProperties: {
            isEnabled: {
                serializedName: "isEnabled",
                type: {
                    name: "Boolean"
                }
            },
            emailSubscriptionAdmins: {
                defaultValue: true,
                serializedName: "emailSubscriptionAdmins",
                type: {
                    name: "Boolean"
                }
            },
            emails: {
                serializedName: "emails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const DatabaseVulnerabilityAssessmentListResult = {
    type: {
        name: "Composite",
        className: "DatabaseVulnerabilityAssessmentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseVulnerabilityAssessment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VulnerabilityAssessmentScanRecordListResult = {
    type: {
        name: "Composite",
        className: "VulnerabilityAssessmentScanRecordListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VulnerabilityAssessmentScanRecord"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VulnerabilityAssessmentScanError = {
    type: {
        name: "Composite",
        className: "VulnerabilityAssessmentScanError",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataWarehouseUserActivitiesListResult = {
    type: {
        name: "Composite",
        className: "DataWarehouseUserActivitiesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataWarehouseUserActivities"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedServerListResult = {
    type: {
        name: "Composite",
        className: "DeletedServerListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedServer"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ElasticPoolOperationListResult = {
    type: {
        name: "Composite",
        className: "ElasticPoolOperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ElasticPoolOperation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ElasticPoolListResult = {
    type: {
        name: "Composite",
        className: "ElasticPoolListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ElasticPool"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ElasticPoolPerDatabaseSettings = {
    type: {
        name: "Composite",
        className: "ElasticPoolPerDatabaseSettings",
        modelProperties: {
            minCapacity: {
                serializedName: "minCapacity",
                type: {
                    name: "Number"
                }
            },
            maxCapacity: {
                serializedName: "maxCapacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ElasticPoolUpdate = {
    type: {
        name: "Composite",
        className: "ElasticPoolUpdate",
        modelProperties: {
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            maxSizeBytes: {
                serializedName: "properties.maxSizeBytes",
                type: {
                    name: "Number"
                }
            },
            perDatabaseSettings: {
                serializedName: "properties.perDatabaseSettings",
                type: {
                    name: "Composite",
                    className: "ElasticPoolPerDatabaseSettings"
                }
            },
            zoneRedundant: {
                serializedName: "properties.zoneRedundant",
                type: {
                    name: "Boolean"
                }
            },
            licenseType: {
                serializedName: "properties.licenseType",
                type: {
                    name: "String"
                }
            },
            maintenanceConfigurationId: {
                serializedName: "properties.maintenanceConfigurationId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EncryptionProtectorListResult = {
    type: {
        name: "Composite",
        className: "EncryptionProtectorListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EncryptionProtector"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FailoverGroupReadWriteEndpoint = {
    type: {
        name: "Composite",
        className: "FailoverGroupReadWriteEndpoint",
        modelProperties: {
            failoverPolicy: {
                serializedName: "failoverPolicy",
                required: true,
                type: {
                    name: "String"
                }
            },
            failoverWithDataLossGracePeriodMinutes: {
                serializedName: "failoverWithDataLossGracePeriodMinutes",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const FailoverGroupReadOnlyEndpoint = {
    type: {
        name: "Composite",
        className: "FailoverGroupReadOnlyEndpoint",
        modelProperties: {
            failoverPolicy: {
                serializedName: "failoverPolicy",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PartnerInfo = {
    type: {
        name: "Composite",
        className: "PartnerInfo",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            replicationRole: {
                serializedName: "replicationRole",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FailoverGroupUpdate = {
    type: {
        name: "Composite",
        className: "FailoverGroupUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            readWriteEndpoint: {
                serializedName: "properties.readWriteEndpoint",
                type: {
                    name: "Composite",
                    className: "FailoverGroupReadWriteEndpoint"
                }
            },
            readOnlyEndpoint: {
                serializedName: "properties.readOnlyEndpoint",
                type: {
                    name: "Composite",
                    className: "FailoverGroupReadOnlyEndpoint"
                }
            },
            databases: {
                serializedName: "properties.databases",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const FailoverGroupListResult = {
    type: {
        name: "Composite",
        className: "FailoverGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FailoverGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceWithWritableName = {
    type: {
        name: "Composite",
        className: "ResourceWithWritableName",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallRuleListResult = {
    type: {
        name: "Composite",
        className: "FirewallRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallRuleList = {
    type: {
        name: "Composite",
        className: "FirewallRuleList",
        modelProperties: {
            values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallRule"
                        }
                    }
                }
            }
        }
    }
};
const InstanceFailoverGroupReadWriteEndpoint = {
    type: {
        name: "Composite",
        className: "InstanceFailoverGroupReadWriteEndpoint",
        modelProperties: {
            failoverPolicy: {
                serializedName: "failoverPolicy",
                required: true,
                type: {
                    name: "String"
                }
            },
            failoverWithDataLossGracePeriodMinutes: {
                serializedName: "failoverWithDataLossGracePeriodMinutes",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const InstanceFailoverGroupReadOnlyEndpoint = {
    type: {
        name: "Composite",
        className: "InstanceFailoverGroupReadOnlyEndpoint",
        modelProperties: {
            failoverPolicy: {
                serializedName: "failoverPolicy",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PartnerRegionInfo = {
    type: {
        name: "Composite",
        className: "PartnerRegionInfo",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            replicationRole: {
                serializedName: "replicationRole",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstancePairInfo = {
    type: {
        name: "Composite",
        className: "ManagedInstancePairInfo",
        modelProperties: {
            primaryManagedInstanceId: {
                serializedName: "primaryManagedInstanceId",
                type: {
                    name: "String"
                }
            },
            partnerManagedInstanceId: {
                serializedName: "partnerManagedInstanceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InstanceFailoverGroupListResult = {
    type: {
        name: "Composite",
        className: "InstanceFailoverGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstanceFailoverGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InstancePoolUpdate = {
    type: {
        name: "Composite",
        className: "InstancePoolUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const InstancePoolListResult = {
    type: {
        name: "Composite",
        className: "InstancePoolListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstancePool"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobAgentListResult = {
    type: {
        name: "Composite",
        className: "JobAgentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JobAgent"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobAgentUpdate = {
    type: {
        name: "Composite",
        className: "JobAgentUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const JobCredentialListResult = {
    type: {
        name: "Composite",
        className: "JobCredentialListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JobCredential"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobExecutionListResult = {
    type: {
        name: "Composite",
        className: "JobExecutionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JobExecution"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobExecutionTarget = {
    type: {
        name: "Composite",
        className: "JobExecutionTarget",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            serverName: {
                serializedName: "serverName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            databaseName: {
                serializedName: "databaseName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobListResult = {
    type: {
        name: "Composite",
        className: "JobListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Job"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobSchedule = {
    type: {
        name: "Composite",
        className: "JobSchedule",
        modelProperties: {
            startTime: {
                defaultValue: "0001-01-01T00:00:00+00:00",
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                defaultValue: "9999-12-31T11:59:59+00:00",
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            type: {
                defaultValue: "Once",
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["Once", "Recurring"]
                }
            },
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            interval: {
                serializedName: "interval",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobStepListResult = {
    type: {
        name: "Composite",
        className: "JobStepListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JobStep"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobStepAction = {
    type: {
        name: "Composite",
        className: "JobStepAction",
        modelProperties: {
            type: {
                defaultValue: "TSql",
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            source: {
                defaultValue: "Inline",
                serializedName: "source",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobStepOutput = {
    type: {
        name: "Composite",
        className: "JobStepOutput",
        modelProperties: {
            type: {
                defaultValue: "SqlDatabase",
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            subscriptionId: {
                serializedName: "subscriptionId",
                type: {
                    name: "Uuid"
                }
            },
            resourceGroupName: {
                serializedName: "resourceGroupName",
                type: {
                    name: "String"
                }
            },
            serverName: {
                serializedName: "serverName",
                required: true,
                type: {
                    name: "String"
                }
            },
            databaseName: {
                serializedName: "databaseName",
                required: true,
                type: {
                    name: "String"
                }
            },
            schemaName: {
                defaultValue: "dbo",
                serializedName: "schemaName",
                type: {
                    name: "String"
                }
            },
            tableName: {
                serializedName: "tableName",
                required: true,
                type: {
                    name: "String"
                }
            },
            credential: {
                serializedName: "credential",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobStepExecutionOptions = {
    type: {
        name: "Composite",
        className: "JobStepExecutionOptions",
        modelProperties: {
            timeoutSeconds: {
                defaultValue: 43200,
                serializedName: "timeoutSeconds",
                type: {
                    name: "Number"
                }
            },
            retryAttempts: {
                defaultValue: 10,
                serializedName: "retryAttempts",
                type: {
                    name: "Number"
                }
            },
            initialRetryIntervalSeconds: {
                defaultValue: 1,
                serializedName: "initialRetryIntervalSeconds",
                type: {
                    name: "Number"
                }
            },
            maximumRetryIntervalSeconds: {
                defaultValue: 120,
                serializedName: "maximumRetryIntervalSeconds",
                type: {
                    name: "Number"
                }
            },
            retryIntervalBackoffMultiplier: {
                defaultValue: 2,
                serializedName: "retryIntervalBackoffMultiplier",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const JobTargetGroupListResult = {
    type: {
        name: "Composite",
        className: "JobTargetGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JobTargetGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobTarget = {
    type: {
        name: "Composite",
        className: "JobTarget",
        modelProperties: {
            membershipType: {
                defaultValue: "Include",
                serializedName: "membershipType",
                type: {
                    name: "Enum",
                    allowedValues: ["Include", "Exclude"]
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            serverName: {
                serializedName: "serverName",
                type: {
                    name: "String"
                }
            },
            databaseName: {
                serializedName: "databaseName",
                type: {
                    name: "String"
                }
            },
            elasticPoolName: {
                serializedName: "elasticPoolName",
                type: {
                    name: "String"
                }
            },
            shardMapName: {
                serializedName: "shardMapName",
                type: {
                    name: "String"
                }
            },
            refreshCredential: {
                serializedName: "refreshCredential",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobVersionListResult = {
    type: {
        name: "Composite",
        className: "JobVersionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JobVersion"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LocationCapabilities = {
    type: {
        name: "Composite",
        className: "LocationCapabilities",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportedServerVersions: {
                serializedName: "supportedServerVersions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerVersionCapability"
                        }
                    }
                }
            },
            supportedManagedInstanceVersions: {
                serializedName: "supportedManagedInstanceVersions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstanceVersionCapability"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerVersionCapability = {
    type: {
        name: "Composite",
        className: "ServerVersionCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportedEditions: {
                serializedName: "supportedEditions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EditionCapability"
                        }
                    }
                }
            },
            supportedElasticPoolEditions: {
                serializedName: "supportedElasticPoolEditions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ElasticPoolEditionCapability"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EditionCapability = {
    type: {
        name: "Composite",
        className: "EditionCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportedServiceLevelObjectives: {
                serializedName: "supportedServiceLevelObjectives",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceObjectiveCapability"
                        }
                    }
                }
            },
            zoneRedundant: {
                serializedName: "zoneRedundant",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            readScale: {
                serializedName: "readScale",
                type: {
                    name: "Composite",
                    className: "ReadScaleCapability"
                }
            },
            supportedStorageCapabilities: {
                serializedName: "supportedStorageCapabilities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageCapability"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceObjectiveCapability = {
    type: {
        name: "Composite",
        className: "ServiceObjectiveCapability",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportedMaxSizes: {
                serializedName: "supportedMaxSizes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MaxSizeRangeCapability"
                        }
                    }
                }
            },
            performanceLevel: {
                serializedName: "performanceLevel",
                type: {
                    name: "Composite",
                    className: "PerformanceLevelCapability"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            supportedLicenseTypes: {
                serializedName: "supportedLicenseTypes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LicenseTypeCapability"
                        }
                    }
                }
            },
            includedMaxSize: {
                serializedName: "includedMaxSize",
                type: {
                    name: "Composite",
                    className: "MaxSizeCapability"
                }
            },
            zoneRedundant: {
                serializedName: "zoneRedundant",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            supportedAutoPauseDelay: {
                serializedName: "supportedAutoPauseDelay",
                type: {
                    name: "Composite",
                    className: "AutoPauseDelayTimeRange"
                }
            },
            supportedMinCapacities: {
                serializedName: "supportedMinCapacities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MinCapacityCapability"
                        }
                    }
                }
            },
            computeModel: {
                serializedName: "computeModel",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportedMaintenanceConfigurations: {
                serializedName: "supportedMaintenanceConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MaintenanceConfigurationCapability"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MaxSizeRangeCapability = {
    type: {
        name: "Composite",
        className: "MaxSizeRangeCapability",
        modelProperties: {
            minValue: {
                serializedName: "minValue",
                type: {
                    name: "Composite",
                    className: "MaxSizeCapability"
                }
            },
            maxValue: {
                serializedName: "maxValue",
                type: {
                    name: "Composite",
                    className: "MaxSizeCapability"
                }
            },
            scaleSize: {
                serializedName: "scaleSize",
                type: {
                    name: "Composite",
                    className: "MaxSizeCapability"
                }
            },
            logSize: {
                serializedName: "logSize",
                type: {
                    name: "Composite",
                    className: "LogSizeCapability"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MaxSizeCapability = {
    type: {
        name: "Composite",
        className: "MaxSizeCapability",
        modelProperties: {
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LogSizeCapability = {
    type: {
        name: "Composite",
        className: "LogSizeCapability",
        modelProperties: {
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PerformanceLevelCapability = {
    type: {
        name: "Composite",
        className: "PerformanceLevelCapability",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LicenseTypeCapability = {
    type: {
        name: "Composite",
        className: "LicenseTypeCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutoPauseDelayTimeRange = {
    type: {
        name: "Composite",
        className: "AutoPauseDelayTimeRange",
        modelProperties: {
            minValue: {
                serializedName: "minValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maxValue: {
                serializedName: "maxValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            stepSize: {
                serializedName: "stepSize",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            default: {
                serializedName: "default",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            doNotPauseValue: {
                serializedName: "doNotPauseValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const MinCapacityCapability = {
    type: {
        name: "Composite",
        className: "MinCapacityCapability",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MaintenanceConfigurationCapability = {
    type: {
        name: "Composite",
        className: "MaintenanceConfigurationCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            zoneRedundant: {
                serializedName: "zoneRedundant",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReadScaleCapability = {
    type: {
        name: "Composite",
        className: "ReadScaleCapability",
        modelProperties: {
            maxNumberOfReplicas: {
                serializedName: "maxNumberOfReplicas",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageCapability = {
    type: {
        name: "Composite",
        className: "StorageCapability",
        modelProperties: {
            storageAccountType: {
                serializedName: "storageAccountType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ElasticPoolEditionCapability = {
    type: {
        name: "Composite",
        className: "ElasticPoolEditionCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportedElasticPoolPerformanceLevels: {
                serializedName: "supportedElasticPoolPerformanceLevels",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ElasticPoolPerformanceLevelCapability"
                        }
                    }
                }
            },
            zoneRedundant: {
                serializedName: "zoneRedundant",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ElasticPoolPerformanceLevelCapability = {
    type: {
        name: "Composite",
        className: "ElasticPoolPerformanceLevelCapability",
        modelProperties: {
            performanceLevel: {
                serializedName: "performanceLevel",
                type: {
                    name: "Composite",
                    className: "PerformanceLevelCapability"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            supportedLicenseTypes: {
                serializedName: "supportedLicenseTypes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LicenseTypeCapability"
                        }
                    }
                }
            },
            maxDatabaseCount: {
                serializedName: "maxDatabaseCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            includedMaxSize: {
                serializedName: "includedMaxSize",
                type: {
                    name: "Composite",
                    className: "MaxSizeCapability"
                }
            },
            supportedMaxSizes: {
                serializedName: "supportedMaxSizes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MaxSizeRangeCapability"
                        }
                    }
                }
            },
            supportedPerDatabaseMaxSizes: {
                serializedName: "supportedPerDatabaseMaxSizes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MaxSizeRangeCapability"
                        }
                    }
                }
            },
            supportedPerDatabaseMaxPerformanceLevels: {
                serializedName: "supportedPerDatabaseMaxPerformanceLevels",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ElasticPoolPerDatabaseMaxPerformanceLevelCapability"
                        }
                    }
                }
            },
            zoneRedundant: {
                serializedName: "zoneRedundant",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            supportedMaintenanceConfigurations: {
                serializedName: "supportedMaintenanceConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MaintenanceConfigurationCapability"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ElasticPoolPerDatabaseMaxPerformanceLevelCapability = {
    type: {
        name: "Composite",
        className: "ElasticPoolPerDatabaseMaxPerformanceLevelCapability",
        modelProperties: {
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportedPerDatabaseMinPerformanceLevels: {
                serializedName: "supportedPerDatabaseMinPerformanceLevels",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ElasticPoolPerDatabaseMinPerformanceLevelCapability"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ElasticPoolPerDatabaseMinPerformanceLevelCapability = {
    type: {
        name: "Composite",
        className: "ElasticPoolPerDatabaseMinPerformanceLevelCapability",
        modelProperties: {
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceVersionCapability = {
    type: {
        name: "Composite",
        className: "ManagedInstanceVersionCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportedEditions: {
                serializedName: "supportedEditions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstanceEditionCapability"
                        }
                    }
                }
            },
            supportedInstancePoolEditions: {
                serializedName: "supportedInstancePoolEditions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstancePoolEditionCapability"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceEditionCapability = {
    type: {
        name: "Composite",
        className: "ManagedInstanceEditionCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportedFamilies: {
                serializedName: "supportedFamilies",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstanceFamilyCapability"
                        }
                    }
                }
            },
            supportedStorageCapabilities: {
                serializedName: "supportedStorageCapabilities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageCapability"
                        }
                    }
                }
            },
            zoneRedundant: {
                serializedName: "zoneRedundant",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceFamilyCapability = {
    type: {
        name: "Composite",
        className: "ManagedInstanceFamilyCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportedLicenseTypes: {
                serializedName: "supportedLicenseTypes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LicenseTypeCapability"
                        }
                    }
                }
            },
            supportedVcoresValues: {
                serializedName: "supportedVcoresValues",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstanceVcoresCapability"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceVcoresCapability = {
    type: {
        name: "Composite",
        className: "ManagedInstanceVcoresCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            includedMaxSize: {
                serializedName: "includedMaxSize",
                type: {
                    name: "Composite",
                    className: "MaxSizeCapability"
                }
            },
            supportedStorageSizes: {
                serializedName: "supportedStorageSizes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MaxSizeRangeCapability"
                        }
                    }
                }
            },
            instancePoolSupported: {
                serializedName: "instancePoolSupported",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            standaloneSupported: {
                serializedName: "standaloneSupported",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            supportedMaintenanceConfigurations: {
                serializedName: "supportedMaintenanceConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstanceMaintenanceConfigurationCapability"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceMaintenanceConfigurationCapability = {
    type: {
        name: "Composite",
        className: "ManagedInstanceMaintenanceConfigurationCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InstancePoolEditionCapability = {
    type: {
        name: "Composite",
        className: "InstancePoolEditionCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportedFamilies: {
                serializedName: "supportedFamilies",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstancePoolFamilyCapability"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InstancePoolFamilyCapability = {
    type: {
        name: "Composite",
        className: "InstancePoolFamilyCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportedLicenseTypes: {
                serializedName: "supportedLicenseTypes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LicenseTypeCapability"
                        }
                    }
                }
            },
            supportedVcoresValues: {
                serializedName: "supportedVcoresValues",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InstancePoolVcoresCapability"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InstancePoolVcoresCapability = {
    type: {
        name: "Composite",
        className: "InstancePoolVcoresCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            storageLimit: {
                serializedName: "storageLimit",
                type: {
                    name: "Composite",
                    className: "MaxSizeCapability"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Visible", "Available", "Default", "Disabled"]
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LongTermRetentionPolicyListResult = {
    type: {
        name: "Composite",
        className: "LongTermRetentionPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LongTermRetentionPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MaintenanceWindowTimeRange = {
    type: {
        name: "Composite",
        className: "MaintenanceWindowTimeRange",
        modelProperties: {
            dayOfWeek: {
                serializedName: "dayOfWeek",
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "String"
                }
            },
            duration: {
                serializedName: "duration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedBackupShortTermRetentionPolicyListResult = {
    type: {
        name: "Composite",
        className: "ManagedBackupShortTermRetentionPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedBackupShortTermRetentionPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceQueryStatistics = {
    type: {
        name: "Composite",
        className: "ManagedInstanceQueryStatistics",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryStatistics"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QueryStatisticsProperties = {
    type: {
        name: "Composite",
        className: "QueryStatisticsProperties",
        modelProperties: {
            databaseName: {
                serializedName: "databaseName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            queryId: {
                serializedName: "queryId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            endTime: {
                serializedName: "endTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            intervals: {
                serializedName: "intervals",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryMetricInterval"
                        }
                    }
                }
            }
        }
    }
};
const QueryMetricInterval = {
    type: {
        name: "Composite",
        className: "QueryMetricInterval",
        modelProperties: {
            intervalStartTime: {
                serializedName: "intervalStartTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            intervalType: {
                serializedName: "intervalType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            executionCount: {
                serializedName: "executionCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            metrics: {
                serializedName: "metrics",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryMetricProperties"
                        }
                    }
                }
            }
        }
    }
};
const QueryMetricProperties = {
    type: {
        name: "Composite",
        className: "QueryMetricProperties",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            min: {
                serializedName: "min",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            max: {
                serializedName: "max",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            avg: {
                serializedName: "avg",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            sum: {
                serializedName: "sum",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            stdev: {
                serializedName: "stdev",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ManagedDatabaseListResult = {
    type: {
        name: "Composite",
        className: "ManagedDatabaseListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedDatabase"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedDatabaseUpdate = {
    type: {
        name: "Composite",
        className: "ManagedDatabaseUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            collation: {
                serializedName: "properties.collation",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            earliestRestorePoint: {
                serializedName: "properties.earliestRestorePoint",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            restorePointInTime: {
                serializedName: "properties.restorePointInTime",
                type: {
                    name: "DateTime"
                }
            },
            defaultSecondaryLocation: {
                serializedName: "properties.defaultSecondaryLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            catalogCollation: {
                serializedName: "properties.catalogCollation",
                type: {
                    name: "String"
                }
            },
            createMode: {
                serializedName: "properties.createMode",
                type: {
                    name: "String"
                }
            },
            storageContainerUri: {
                serializedName: "properties.storageContainerUri",
                type: {
                    name: "String"
                }
            },
            sourceDatabaseId: {
                serializedName: "properties.sourceDatabaseId",
                type: {
                    name: "String"
                }
            },
            restorableDroppedDatabaseId: {
                serializedName: "properties.restorableDroppedDatabaseId",
                type: {
                    name: "String"
                }
            },
            storageContainerSasToken: {
                serializedName: "properties.storageContainerSasToken",
                type: {
                    name: "String"
                }
            },
            failoverGroupId: {
                serializedName: "properties.failoverGroupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            recoverableDatabaseId: {
                serializedName: "properties.recoverableDatabaseId",
                type: {
                    name: "String"
                }
            },
            longTermRetentionBackupResourceId: {
                serializedName: "properties.longTermRetentionBackupResourceId",
                type: {
                    name: "String"
                }
            },
            autoCompleteRestore: {
                serializedName: "properties.autoCompleteRestore",
                type: {
                    name: "Boolean"
                }
            },
            lastBackupName: {
                serializedName: "properties.lastBackupName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CompleteDatabaseRestoreDefinition = {
    type: {
        name: "Composite",
        className: "CompleteDatabaseRestoreDefinition",
        modelProperties: {
            lastBackupName: {
                serializedName: "lastBackupName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedDatabaseSecurityAlertPolicyListResult = {
    type: {
        name: "Composite",
        className: "ManagedDatabaseSecurityAlertPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedDatabaseSecurityAlertPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityEventCollection = {
    type: {
        name: "Composite",
        className: "SecurityEventCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityEvent"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityEventSqlInjectionAdditionalProperties = {
    type: {
        name: "Composite",
        className: "SecurityEventSqlInjectionAdditionalProperties",
        modelProperties: {
            threatId: {
                serializedName: "threatId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            statement: {
                serializedName: "statement",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            statementHighlightOffset: {
                serializedName: "statementHighlightOffset",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            statementHighlightLength: {
                serializedName: "statementHighlightLength",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            errorCode: {
                serializedName: "errorCode",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            errorSeverity: {
                serializedName: "errorSeverity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SensitivityLabelListResult = {
    type: {
        name: "Composite",
        className: "SensitivityLabelListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SensitivityLabel"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SensitivityLabelUpdateList = {
    type: {
        name: "Composite",
        className: "SensitivityLabelUpdateList",
        modelProperties: {
            operations: {
                serializedName: "operations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SensitivityLabelUpdate"
                        }
                    }
                }
            }
        }
    }
};
const RecommendedSensitivityLabelUpdateList = {
    type: {
        name: "Composite",
        className: "RecommendedSensitivityLabelUpdateList",
        modelProperties: {
            operations: {
                serializedName: "operations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecommendedSensitivityLabelUpdate"
                        }
                    }
                }
            }
        }
    }
};
const ManagedTransparentDataEncryptionListResult = {
    type: {
        name: "Composite",
        className: "ManagedTransparentDataEncryptionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedTransparentDataEncryption"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceAdministratorListResult = {
    type: {
        name: "Composite",
        className: "ManagedInstanceAdministratorListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstanceAdministrator"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceAzureADOnlyAuthListResult = {
    type: {
        name: "Composite",
        className: "ManagedInstanceAzureADOnlyAuthListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstanceAzureADOnlyAuthentication"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceEncryptionProtectorListResult = {
    type: {
        name: "Composite",
        className: "ManagedInstanceEncryptionProtectorListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstanceEncryptionProtector"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceKeyListResult = {
    type: {
        name: "Composite",
        className: "ManagedInstanceKeyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstanceKey"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceLongTermRetentionPolicyListResult = {
    type: {
        name: "Composite",
        className: "ManagedInstanceLongTermRetentionPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstanceLongTermRetentionPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceOperationListResult = {
    type: {
        name: "Composite",
        className: "ManagedInstanceOperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstanceOperation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceOperationParametersPair = {
    type: {
        name: "Composite",
        className: "ManagedInstanceOperationParametersPair",
        modelProperties: {
            currentParameters: {
                serializedName: "currentParameters",
                type: {
                    name: "Composite",
                    className: "UpsertManagedServerOperationParameters"
                }
            },
            requestedParameters: {
                serializedName: "requestedParameters",
                type: {
                    name: "Composite",
                    className: "UpsertManagedServerOperationParameters"
                }
            }
        }
    }
};
const UpsertManagedServerOperationParameters = {
    type: {
        name: "Composite",
        className: "UpsertManagedServerOperationParameters",
        modelProperties: {
            family: {
                serializedName: "family",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            },
            vCores: {
                serializedName: "vCores",
                type: {
                    name: "Number"
                }
            },
            storageSizeInGB: {
                serializedName: "storageSizeInGB",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ManagedInstanceOperationSteps = {
    type: {
        name: "Composite",
        className: "ManagedInstanceOperationSteps",
        modelProperties: {
            totalSteps: {
                serializedName: "totalSteps",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            currentStep: {
                serializedName: "currentStep",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            stepsList: {
                serializedName: "stepsList",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UpsertManagedServerOperationStep"
                        }
                    }
                }
            }
        }
    }
};
const UpsertManagedServerOperationStep = {
    type: {
        name: "Composite",
        className: "UpsertManagedServerOperationStep",
        modelProperties: {
            order: {
                serializedName: "order",
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstancePrivateEndpointConnectionProperties = {
    type: {
        name: "Composite",
        className: "ManagedInstancePrivateEndpointConnectionProperties",
        modelProperties: {
            privateEndpoint: {
                serializedName: "privateEndpoint",
                type: {
                    name: "Composite",
                    className: "ManagedInstancePrivateEndpointProperty"
                }
            },
            privateLinkServiceConnectionState: {
                serializedName: "privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "ManagedInstancePrivateLinkServiceConnectionStateProperty"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstancePrivateEndpointProperty = {
    type: {
        name: "Composite",
        className: "ManagedInstancePrivateEndpointProperty",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstancePrivateLinkServiceConnectionStateProperty = {
    type: {
        name: "Composite",
        className: "ManagedInstancePrivateLinkServiceConnectionStateProperty",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                required: true,
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstancePrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "ManagedInstancePrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstancePrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstancePrivateLinkListResult = {
    type: {
        name: "Composite",
        className: "ManagedInstancePrivateLinkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstancePrivateLink"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstancePrivateLinkProperties = {
    type: {
        name: "Composite",
        className: "ManagedInstancePrivateLinkProperties",
        modelProperties: {
            groupId: {
                serializedName: "groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            requiredMembers: {
                serializedName: "requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ManagedInstanceVulnerabilityAssessmentListResult = {
    type: {
        name: "Composite",
        className: "ManagedInstanceVulnerabilityAssessmentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstanceVulnerabilityAssessment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedServerSecurityAlertPolicyListResult = {
    type: {
        name: "Composite",
        className: "ManagedServerSecurityAlertPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedServerSecurityAlertPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationsHealthListResult = {
    type: {
        name: "Composite",
        className: "OperationsHealthListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationsHealth"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionProperties = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionProperties",
        modelProperties: {
            privateEndpoint: {
                serializedName: "privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpointProperty"
                }
            },
            privateLinkServiceConnectionState: {
                serializedName: "privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionStateProperty"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointProperty = {
    type: {
        name: "Composite",
        className: "PrivateEndpointProperty",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionStateProperty = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionStateProperty",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                required: true,
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkResourceProperties = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceProperties",
        modelProperties: {
            groupId: {
                serializedName: "groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            requiredMembers: {
                serializedName: "requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            requiredZoneNames: {
                serializedName: "requiredZoneNames",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RecoverableManagedDatabaseListResult = {
    type: {
        name: "Composite",
        className: "RecoverableManagedDatabaseListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecoverableManagedDatabase"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RestorePointListResult = {
    type: {
        name: "Composite",
        className: "RestorePointListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorePoint"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CreateDatabaseRestorePointDefinition = {
    type: {
        name: "Composite",
        className: "CreateDatabaseRestorePointDefinition",
        modelProperties: {
            restorePointLabel: {
                serializedName: "restorePointLabel",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutomaticTuningServerOptions = {
    type: {
        name: "Composite",
        className: "AutomaticTuningServerOptions",
        modelProperties: {
            desiredState: {
                serializedName: "desiredState",
                type: {
                    name: "Enum",
                    allowedValues: ["Off", "On", "Default"]
                }
            },
            actualState: {
                serializedName: "actualState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Off", "On"]
                }
            },
            reasonCode: {
                serializedName: "reasonCode",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            reasonDesc: {
                serializedName: "reasonDesc",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Default", "Disabled", "AutoConfigured"]
                }
            }
        }
    }
};
const AdministratorListResult = {
    type: {
        name: "Composite",
        className: "AdministratorListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerAzureADAdministrator"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureADOnlyAuthListResult = {
    type: {
        name: "Composite",
        className: "AzureADOnlyAuthListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerAzureADOnlyAuthentication"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerDevOpsAuditSettingsListResult = {
    type: {
        name: "Composite",
        className: "ServerDevOpsAuditSettingsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerDevOpsAuditingSettings"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerDnsAliasListResult = {
    type: {
        name: "Composite",
        className: "ServerDnsAliasListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerDnsAlias"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerDnsAliasAcquisition = {
    type: {
        name: "Composite",
        className: "ServerDnsAliasAcquisition",
        modelProperties: {
            oldServerDnsAliasId: {
                serializedName: "oldServerDnsAliasId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerKeyListResult = {
    type: {
        name: "Composite",
        className: "ServerKeyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerKey"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerOperationListResult = {
    type: {
        name: "Composite",
        className: "ServerOperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerOperation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LogicalServerSecurityAlertPolicyListResult = {
    type: {
        name: "Composite",
        className: "LogicalServerSecurityAlertPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerSecurityAlertPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerInfo = {
    type: {
        name: "Composite",
        className: "ServerInfo",
        modelProperties: {
            serverId: {
                serializedName: "serverId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerTrustGroupListResult = {
    type: {
        name: "Composite",
        className: "ServerTrustGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerTrustGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerVulnerabilityAssessmentListResult = {
    type: {
        name: "Composite",
        className: "ServerVulnerabilityAssessmentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerVulnerabilityAssessment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubscriptionUsageListResult = {
    type: {
        name: "Composite",
        className: "SubscriptionUsageListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubscriptionUsage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncAgentListResult = {
    type: {
        name: "Composite",
        className: "SyncAgentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SyncAgent"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncAgentKeyProperties = {
    type: {
        name: "Composite",
        className: "SyncAgentKeyProperties",
        modelProperties: {
            syncAgentKey: {
                serializedName: "syncAgentKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncAgentLinkedDatabaseListResult = {
    type: {
        name: "Composite",
        className: "SyncAgentLinkedDatabaseListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SyncAgentLinkedDatabase"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncDatabaseIdListResult = {
    type: {
        name: "Composite",
        className: "SyncDatabaseIdListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SyncDatabaseIdProperties"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncDatabaseIdProperties = {
    type: {
        name: "Composite",
        className: "SyncDatabaseIdProperties",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncFullSchemaPropertiesListResult = {
    type: {
        name: "Composite",
        className: "SyncFullSchemaPropertiesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SyncFullSchemaProperties"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncFullSchemaProperties = {
    type: {
        name: "Composite",
        className: "SyncFullSchemaProperties",
        modelProperties: {
            tables: {
                serializedName: "tables",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SyncFullSchemaTable"
                        }
                    }
                }
            },
            lastUpdateTime: {
                serializedName: "lastUpdateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const SyncFullSchemaTable = {
    type: {
        name: "Composite",
        className: "SyncFullSchemaTable",
        modelProperties: {
            columns: {
                serializedName: "columns",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SyncFullSchemaTableColumn"
                        }
                    }
                }
            },
            errorId: {
                serializedName: "errorId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            hasError: {
                serializedName: "hasError",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            quotedName: {
                serializedName: "quotedName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncFullSchemaTableColumn = {
    type: {
        name: "Composite",
        className: "SyncFullSchemaTableColumn",
        modelProperties: {
            dataSize: {
                serializedName: "dataSize",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dataType: {
                serializedName: "dataType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            errorId: {
                serializedName: "errorId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            hasError: {
                serializedName: "hasError",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            isPrimaryKey: {
                serializedName: "isPrimaryKey",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            quotedName: {
                serializedName: "quotedName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncGroupLogListResult = {
    type: {
        name: "Composite",
        className: "SyncGroupLogListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SyncGroupLogProperties"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncGroupLogProperties = {
    type: {
        name: "Composite",
        className: "SyncGroupLogProperties",
        modelProperties: {
            timestamp: {
                serializedName: "timestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            source: {
                serializedName: "source",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tracingId: {
                serializedName: "tracingId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            operationStatus: {
                serializedName: "operationStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncGroupSchema = {
    type: {
        name: "Composite",
        className: "SyncGroupSchema",
        modelProperties: {
            tables: {
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SyncGroupSchemaTable"
                        }
                    }
                }
            },
            masterSyncMemberName: {
                serializedName: "masterSyncMemberName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncGroupSchemaTable = {
    type: {
        name: "Composite",
        className: "SyncGroupSchemaTable",
        modelProperties: {
            columns: {
                serializedName: "columns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SyncGroupSchemaTableColumn"
                        }
                    }
                }
            },
            quotedName: {
                serializedName: "quotedName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncGroupSchemaTableColumn = {
    type: {
        name: "Composite",
        className: "SyncGroupSchemaTableColumn",
        modelProperties: {
            quotedName: {
                serializedName: "quotedName",
                type: {
                    name: "String"
                }
            },
            dataSize: {
                serializedName: "dataSize",
                type: {
                    name: "String"
                }
            },
            dataType: {
                serializedName: "dataType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncGroupListResult = {
    type: {
        name: "Composite",
        className: "SyncGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SyncGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncMemberListResult = {
    type: {
        name: "Composite",
        className: "SyncMemberListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SyncMember"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TimeZoneListResult = {
    type: {
        name: "Composite",
        className: "TimeZoneListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TimeZone"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualClusterListResult = {
    type: {
        name: "Composite",
        className: "VirtualClusterListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualCluster"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualClusterUpdate = {
    type: {
        name: "Composite",
        className: "VirtualClusterUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            subnetId: {
                serializedName: "properties.subnetId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "properties.family",
                type: {
                    name: "String"
                }
            },
            childResources: {
                serializedName: "properties.childResources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            maintenanceConfigurationId: {
                serializedName: "properties.maintenanceConfigurationId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkRuleListResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadClassifierListResult = {
    type: {
        name: "Composite",
        className: "WorkloadClassifierListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadClassifier"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadGroupListResult = {
    type: {
        name: "Composite",
        className: "WorkloadGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LogicalDatabaseTransparentDataEncryptionListResult = {
    type: {
        name: "Composite",
        className: "LogicalDatabaseTransparentDataEncryptionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LogicalDatabaseTransparentDataEncryption"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackupShortTermRetentionPolicyListResult = {
    type: {
        name: "Composite",
        className: "BackupShortTermRetentionPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackupShortTermRetentionPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImportExportExtensionsOperationListResult = {
    type: {
        name: "Composite",
        className: "ImportExportExtensionsOperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ImportExportExtensionsOperationResult"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseOperationListResult = {
    type: {
        name: "Composite",
        className: "DatabaseOperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseOperation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseUsageListResult = {
    type: {
        name: "Composite",
        className: "DatabaseUsageListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseUsage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LedgerDigestUploadsListResult = {
    type: {
        name: "Composite",
        className: "LedgerDigestUploadsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LedgerDigestUploads"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OutboundFirewallRuleListResult = {
    type: {
        name: "Composite",
        className: "OutboundFirewallRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OutboundFirewallRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReplicationLinkListResult = {
    type: {
        name: "Composite",
        className: "ReplicationLinkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ReplicationLink"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerListResult = {
    type: {
        name: "Composite",
        className: "ServerListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Server"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceIdentity = {
    type: {
        name: "Composite",
        className: "ResourceIdentity",
        modelProperties: {
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "UserIdentity" } }
                }
            },
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const UserIdentity = {
    type: {
        name: "Composite",
        className: "UserIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const ServerPrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "ServerPrivateEndpointConnection",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "PrivateEndpointConnectionProperties"
                }
            }
        }
    }
};
const ServerExternalAdministrator = {
    type: {
        name: "Composite",
        className: "ServerExternalAdministrator",
        modelProperties: {
            administratorType: {
                serializedName: "administratorType",
                type: {
                    name: "String"
                }
            },
            principalType: {
                serializedName: "principalType",
                type: {
                    name: "String"
                }
            },
            login: {
                serializedName: "login",
                type: {
                    name: "String"
                }
            },
            sid: {
                serializedName: "sid",
                type: {
                    name: "Uuid"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "Uuid"
                }
            },
            azureADOnlyAuthentication: {
                serializedName: "azureADOnlyAuthentication",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ServerUpdate = {
    type: {
        name: "Composite",
        className: "ServerUpdate",
        modelProperties: {
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ResourceIdentity"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            administratorLogin: {
                serializedName: "properties.administratorLogin",
                type: {
                    name: "String"
                }
            },
            administratorLoginPassword: {
                serializedName: "properties.administratorLoginPassword",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "properties.version",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            fullyQualifiedDomainName: {
                serializedName: "properties.fullyQualifiedDomainName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerPrivateEndpointConnection"
                        }
                    }
                }
            },
            minimalTlsVersion: {
                serializedName: "properties.minimalTlsVersion",
                type: {
                    name: "String"
                }
            },
            publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            workspaceFeature: {
                serializedName: "properties.workspaceFeature",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            primaryUserAssignedIdentityId: {
                serializedName: "properties.primaryUserAssignedIdentityId",
                type: {
                    name: "String"
                }
            },
            federatedClientId: {
                serializedName: "properties.federatedClientId",
                type: {
                    name: "Uuid"
                }
            },
            keyId: {
                serializedName: "properties.keyId",
                type: {
                    name: "String"
                }
            },
            administrators: {
                serializedName: "properties.administrators",
                type: {
                    name: "Composite",
                    className: "ServerExternalAdministrator"
                }
            },
            restrictOutboundNetworkAccess: {
                serializedName: "properties.restrictOutboundNetworkAccess",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImportNewDatabaseDefinition = {
    type: {
        name: "Composite",
        className: "ImportNewDatabaseDefinition",
        modelProperties: {
            databaseName: {
                serializedName: "databaseName",
                type: {
                    name: "String"
                }
            },
            edition: {
                serializedName: "edition",
                type: {
                    name: "String"
                }
            },
            serviceObjectiveName: {
                serializedName: "serviceObjectiveName",
                type: {
                    name: "String"
                }
            },
            maxSizeBytes: {
                serializedName: "maxSizeBytes",
                type: {
                    name: "String"
                }
            },
            storageKeyType: {
                serializedName: "storageKeyType",
                required: true,
                type: {
                    name: "String"
                }
            },
            storageKey: {
                serializedName: "storageKey",
                required: true,
                type: {
                    name: "String"
                }
            },
            storageUri: {
                serializedName: "storageUri",
                required: true,
                type: {
                    name: "String"
                }
            },
            administratorLogin: {
                serializedName: "administratorLogin",
                required: true,
                type: {
                    name: "String"
                }
            },
            administratorLoginPassword: {
                serializedName: "administratorLoginPassword",
                required: true,
                type: {
                    name: "String"
                }
            },
            authenticationType: {
                serializedName: "authenticationType",
                type: {
                    name: "String"
                }
            },
            networkIsolation: {
                serializedName: "networkIsolation",
                type: {
                    name: "Composite",
                    className: "NetworkIsolationSettings"
                }
            }
        }
    }
};
const NetworkIsolationSettings = {
    type: {
        name: "Composite",
        className: "NetworkIsolationSettings",
        modelProperties: {
            storageAccountResourceId: {
                serializedName: "storageAccountResourceId",
                type: {
                    name: "String"
                }
            },
            sqlServerResourceId: {
                serializedName: "sqlServerResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionRequestStatus = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionRequestStatus",
        modelProperties: {
            privateLinkServiceId: {
                serializedName: "privateLinkServiceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateEndpointConnectionName: {
                serializedName: "privateEndpointConnectionName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityRequest = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                defaultValue: "Microsoft.Sql/servers",
                isConstant: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityResponse = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityResponse",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            available: {
                serializedName: "available",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Invalid", "AlreadyExists"]
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UsageListResult = {
    type: {
        name: "Composite",
        className: "UsageListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Usage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Usage = {
    type: {
        name: "Composite",
        className: "Usage",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "Name"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            requestedLimit: {
                serializedName: "requestedLimit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Name = {
    type: {
        name: "Composite",
        className: "Name",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseListResult = {
    type: {
        name: "Composite",
        className: "DatabaseListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Database"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseIdentity = {
    type: {
        name: "Composite",
        className: "DatabaseIdentity",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "DatabaseUserIdentity" }
                    }
                }
            },
            delegatedResources: {
                serializedName: "delegatedResources",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "Delegation" } }
                }
            }
        }
    }
};
const DatabaseUserIdentity = {
    type: {
        name: "Composite",
        className: "DatabaseUserIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const Delegation = {
    type: {
        name: "Composite",
        className: "Delegation",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const DatabaseUpdate = {
    type: {
        name: "Composite",
        className: "DatabaseUpdate",
        modelProperties: {
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "DatabaseIdentity"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            createMode: {
                serializedName: "properties.createMode",
                type: {
                    name: "String"
                }
            },
            collation: {
                serializedName: "properties.collation",
                type: {
                    name: "String"
                }
            },
            maxSizeBytes: {
                serializedName: "properties.maxSizeBytes",
                type: {
                    name: "Number"
                }
            },
            sampleName: {
                serializedName: "properties.sampleName",
                type: {
                    name: "String"
                }
            },
            elasticPoolId: {
                serializedName: "properties.elasticPoolId",
                type: {
                    name: "String"
                }
            },
            sourceDatabaseId: {
                serializedName: "properties.sourceDatabaseId",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            databaseId: {
                serializedName: "properties.databaseId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            currentServiceObjectiveName: {
                serializedName: "properties.currentServiceObjectiveName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            requestedServiceObjectiveName: {
                serializedName: "properties.requestedServiceObjectiveName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            defaultSecondaryLocation: {
                serializedName: "properties.defaultSecondaryLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            failoverGroupId: {
                serializedName: "properties.failoverGroupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            restorePointInTime: {
                serializedName: "properties.restorePointInTime",
                type: {
                    name: "DateTime"
                }
            },
            sourceDatabaseDeletionDate: {
                serializedName: "properties.sourceDatabaseDeletionDate",
                type: {
                    name: "DateTime"
                }
            },
            recoveryServicesRecoveryPointId: {
                serializedName: "properties.recoveryServicesRecoveryPointId",
                type: {
                    name: "String"
                }
            },
            longTermRetentionBackupResourceId: {
                serializedName: "properties.longTermRetentionBackupResourceId",
                type: {
                    name: "String"
                }
            },
            recoverableDatabaseId: {
                serializedName: "properties.recoverableDatabaseId",
                type: {
                    name: "String"
                }
            },
            restorableDroppedDatabaseId: {
                serializedName: "properties.restorableDroppedDatabaseId",
                type: {
                    name: "String"
                }
            },
            catalogCollation: {
                serializedName: "properties.catalogCollation",
                type: {
                    name: "String"
                }
            },
            zoneRedundant: {
                serializedName: "properties.zoneRedundant",
                type: {
                    name: "Boolean"
                }
            },
            licenseType: {
                serializedName: "properties.licenseType",
                type: {
                    name: "String"
                }
            },
            maxLogSizeBytes: {
                serializedName: "properties.maxLogSizeBytes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            earliestRestoreDate: {
                serializedName: "properties.earliestRestoreDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            readScale: {
                serializedName: "properties.readScale",
                type: {
                    name: "String"
                }
            },
            highAvailabilityReplicaCount: {
                serializedName: "properties.highAvailabilityReplicaCount",
                type: {
                    name: "Number"
                }
            },
            secondaryType: {
                serializedName: "properties.secondaryType",
                type: {
                    name: "String"
                }
            },
            currentSku: {
                serializedName: "properties.currentSku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            autoPauseDelay: {
                serializedName: "properties.autoPauseDelay",
                type: {
                    name: "Number"
                }
            },
            currentBackupStorageRedundancy: {
                serializedName: "properties.currentBackupStorageRedundancy",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            requestedBackupStorageRedundancy: {
                serializedName: "properties.requestedBackupStorageRedundancy",
                type: {
                    name: "String"
                }
            },
            minCapacity: {
                serializedName: "properties.minCapacity",
                type: {
                    name: "Number"
                }
            },
            pausedDate: {
                serializedName: "properties.pausedDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            resumedDate: {
                serializedName: "properties.resumedDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            maintenanceConfigurationId: {
                serializedName: "properties.maintenanceConfigurationId",
                type: {
                    name: "String"
                }
            },
            isLedgerOn: {
                serializedName: "properties.isLedgerOn",
                type: {
                    name: "Boolean"
                }
            },
            isInfraEncryptionEnabled: {
                serializedName: "properties.isInfraEncryptionEnabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            federatedClientId: {
                serializedName: "properties.federatedClientId",
                type: {
                    name: "Uuid"
                }
            },
            primaryDelegatedIdentityClientId: {
                serializedName: "properties.primaryDelegatedIdentityClientId",
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const ResourceMoveDefinition = {
    type: {
        name: "Composite",
        className: "ResourceMoveDefinition",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImportExistingDatabaseDefinition = {
    type: {
        name: "Composite",
        className: "ImportExistingDatabaseDefinition",
        modelProperties: {
            storageKeyType: {
                serializedName: "storageKeyType",
                required: true,
                type: {
                    name: "String"
                }
            },
            storageKey: {
                serializedName: "storageKey",
                required: true,
                type: {
                    name: "String"
                }
            },
            storageUri: {
                serializedName: "storageUri",
                required: true,
                type: {
                    name: "String"
                }
            },
            administratorLogin: {
                serializedName: "administratorLogin",
                required: true,
                type: {
                    name: "String"
                }
            },
            administratorLoginPassword: {
                serializedName: "administratorLoginPassword",
                required: true,
                type: {
                    name: "String"
                }
            },
            authenticationType: {
                serializedName: "authenticationType",
                type: {
                    name: "String"
                }
            },
            networkIsolation: {
                serializedName: "networkIsolation",
                type: {
                    name: "Composite",
                    className: "NetworkIsolationSettings"
                }
            }
        }
    }
};
const ExportDatabaseDefinition = {
    type: {
        name: "Composite",
        className: "ExportDatabaseDefinition",
        modelProperties: {
            storageKeyType: {
                serializedName: "storageKeyType",
                required: true,
                type: {
                    name: "String"
                }
            },
            storageKey: {
                serializedName: "storageKey",
                required: true,
                type: {
                    name: "String"
                }
            },
            storageUri: {
                serializedName: "storageUri",
                required: true,
                type: {
                    name: "String"
                }
            },
            administratorLogin: {
                serializedName: "administratorLogin",
                required: true,
                type: {
                    name: "String"
                }
            },
            administratorLoginPassword: {
                serializedName: "administratorLoginPassword",
                required: true,
                type: {
                    name: "String"
                }
            },
            authenticationType: {
                serializedName: "authenticationType",
                type: {
                    name: "String"
                }
            },
            networkIsolation: {
                serializedName: "networkIsolation",
                type: {
                    name: "Composite",
                    className: "NetworkIsolationSettings"
                }
            }
        }
    }
};
const CopyLongTermRetentionBackupParameters = {
    type: {
        name: "Composite",
        className: "CopyLongTermRetentionBackupParameters",
        modelProperties: {
            targetSubscriptionId: {
                serializedName: "properties.targetSubscriptionId",
                type: {
                    name: "String"
                }
            },
            targetResourceGroup: {
                serializedName: "properties.targetResourceGroup",
                type: {
                    name: "String"
                }
            },
            targetServerResourceId: {
                serializedName: "properties.targetServerResourceId",
                type: {
                    name: "String"
                }
            },
            targetServerFullyQualifiedDomainName: {
                serializedName: "properties.targetServerFullyQualifiedDomainName",
                type: {
                    name: "String"
                }
            },
            targetDatabaseName: {
                serializedName: "properties.targetDatabaseName",
                type: {
                    name: "String"
                }
            },
            targetBackupStorageRedundancy: {
                serializedName: "properties.targetBackupStorageRedundancy",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpdateLongTermRetentionBackupParameters = {
    type: {
        name: "Composite",
        className: "UpdateLongTermRetentionBackupParameters",
        modelProperties: {
            requestedBackupStorageRedundancy: {
                serializedName: "properties.requestedBackupStorageRedundancy",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LongTermRetentionBackupListResult = {
    type: {
        name: "Composite",
        className: "LongTermRetentionBackupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LongTermRetentionBackup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceLongTermRetentionBackupListResult = {
    type: {
        name: "Composite",
        className: "ManagedInstanceLongTermRetentionBackupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstanceLongTermRetentionBackup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceListResult = {
    type: {
        name: "Composite",
        className: "ManagedInstanceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstance"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstancePecProperty = {
    type: {
        name: "Composite",
        className: "ManagedInstancePecProperty",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ManagedInstancePrivateEndpointConnectionProperties"
                }
            }
        }
    }
};
const ManagedInstanceExternalAdministrator = {
    type: {
        name: "Composite",
        className: "ManagedInstanceExternalAdministrator",
        modelProperties: {
            administratorType: {
                serializedName: "administratorType",
                type: {
                    name: "String"
                }
            },
            principalType: {
                serializedName: "principalType",
                type: {
                    name: "String"
                }
            },
            login: {
                serializedName: "login",
                type: {
                    name: "String"
                }
            },
            sid: {
                serializedName: "sid",
                type: {
                    name: "Uuid"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "Uuid"
                }
            },
            azureADOnlyAuthentication: {
                serializedName: "azureADOnlyAuthentication",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ServicePrincipal = {
    type: {
        name: "Composite",
        className: "ServicePrincipal",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedInstanceUpdate = {
    type: {
        name: "Composite",
        className: "ManagedInstanceUpdate",
        modelProperties: {
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ResourceIdentity"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            managedInstanceCreateMode: {
                serializedName: "properties.managedInstanceCreateMode",
                type: {
                    name: "String"
                }
            },
            fullyQualifiedDomainName: {
                serializedName: "properties.fullyQualifiedDomainName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            administratorLogin: {
                serializedName: "properties.administratorLogin",
                type: {
                    name: "String"
                }
            },
            administratorLoginPassword: {
                serializedName: "properties.administratorLoginPassword",
                type: {
                    name: "String"
                }
            },
            subnetId: {
                serializedName: "properties.subnetId",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            licenseType: {
                serializedName: "properties.licenseType",
                type: {
                    name: "String"
                }
            },
            vCores: {
                serializedName: "properties.vCores",
                type: {
                    name: "Number"
                }
            },
            storageSizeInGB: {
                serializedName: "properties.storageSizeInGB",
                type: {
                    name: "Number"
                }
            },
            collation: {
                serializedName: "properties.collation",
                type: {
                    name: "String"
                }
            },
            dnsZone: {
                serializedName: "properties.dnsZone",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dnsZonePartner: {
                serializedName: "properties.dnsZonePartner",
                type: {
                    name: "String"
                }
            },
            publicDataEndpointEnabled: {
                serializedName: "properties.publicDataEndpointEnabled",
                type: {
                    name: "Boolean"
                }
            },
            sourceManagedInstanceId: {
                serializedName: "properties.sourceManagedInstanceId",
                type: {
                    name: "String"
                }
            },
            restorePointInTime: {
                serializedName: "properties.restorePointInTime",
                type: {
                    name: "DateTime"
                }
            },
            proxyOverride: {
                serializedName: "properties.proxyOverride",
                type: {
                    name: "String"
                }
            },
            timezoneId: {
                serializedName: "properties.timezoneId",
                type: {
                    name: "String"
                }
            },
            instancePoolId: {
                serializedName: "properties.instancePoolId",
                type: {
                    name: "String"
                }
            },
            maintenanceConfigurationId: {
                serializedName: "properties.maintenanceConfigurationId",
                type: {
                    name: "String"
                }
            },
            privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstancePecProperty"
                        }
                    }
                }
            },
            minimalTlsVersion: {
                serializedName: "properties.minimalTlsVersion",
                type: {
                    name: "String"
                }
            },
            currentBackupStorageRedundancy: {
                serializedName: "properties.currentBackupStorageRedundancy",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            requestedBackupStorageRedundancy: {
                serializedName: "properties.requestedBackupStorageRedundancy",
                type: {
                    name: "String"
                }
            },
            zoneRedundant: {
                serializedName: "properties.zoneRedundant",
                type: {
                    name: "Boolean"
                }
            },
            primaryUserAssignedIdentityId: {
                serializedName: "properties.primaryUserAssignedIdentityId",
                type: {
                    name: "String"
                }
            },
            keyId: {
                serializedName: "properties.keyId",
                type: {
                    name: "String"
                }
            },
            administrators: {
                serializedName: "properties.administrators",
                type: {
                    name: "Composite",
                    className: "ManagedInstanceExternalAdministrator"
                }
            },
            servicePrincipal: {
                serializedName: "properties.servicePrincipal",
                type: {
                    name: "Composite",
                    className: "ServicePrincipal"
                }
            }
        }
    }
};
const TopQueriesListResult = {
    type: {
        name: "Composite",
        className: "TopQueriesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TopQueries"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TopQueries = {
    type: {
        name: "Composite",
        className: "TopQueries",
        modelProperties: {
            numberOfQueries: {
                serializedName: "numberOfQueries",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            aggregationFunction: {
                serializedName: "aggregationFunction",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            observationMetric: {
                serializedName: "observationMetric",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            intervalType: {
                serializedName: "intervalType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            endTime: {
                serializedName: "endTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            queries: {
                serializedName: "queries",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryStatisticsProperties"
                        }
                    }
                }
            }
        }
    }
};
const RestorableDroppedDatabaseListResult = {
    type: {
        name: "Composite",
        className: "RestorableDroppedDatabaseListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableDroppedDatabase"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RestorableDroppedManagedDatabaseListResult = {
    type: {
        name: "Composite",
        className: "RestorableDroppedManagedDatabaseListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableDroppedManagedDatabase"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerConnectionPolicyListResult = {
    type: {
        name: "Composite",
        className: "ServerConnectionPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerConnectionPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SloUsageMetric = {
    type: {
        name: "Composite",
        className: "SloUsageMetric",
        modelProperties: {
            serviceLevelObjective: {
                serializedName: "serviceLevelObjective",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            serviceLevelObjectiveId: {
                serializedName: "serviceLevelObjectiveId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            inRangeTimeRatio: {
                serializedName: "inRangeTimeRatio",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const OperationImpact = {
    type: {
        name: "Composite",
        className: "OperationImpact",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            changeValueAbsolute: {
                serializedName: "changeValueAbsolute",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            changeValueRelative: {
                serializedName: "changeValueRelative",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SecurityEventsFilterParameters = {
    type: {
        name: "Composite",
        className: "SecurityEventsFilterParameters",
        modelProperties: {
            eventTime: {
                serializedName: "eventTime",
                type: {
                    name: "DateTime"
                }
            },
            showServerRecords: {
                serializedName: "showServerRecords",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const ProxyResourceWithWritableName = {
    type: {
        name: "Composite",
        className: "ProxyResourceWithWritableName",
        modelProperties: Object.assign({}, ResourceWithWritableName.type.modelProperties)
    }
};
const RecoverableDatabase = {
    type: {
        name: "Composite",
        className: "RecoverableDatabase",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { edition: {
                serializedName: "properties.edition",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serviceLevelObjective: {
                serializedName: "properties.serviceLevelObjective",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, elasticPoolName: {
                serializedName: "properties.elasticPoolName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, lastAvailableBackupDate: {
                serializedName: "properties.lastAvailableBackupDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const DataMaskingPolicy = {
    type: {
        name: "Composite",
        className: "DataMaskingPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, dataMaskingState: {
                serializedName: "properties.dataMaskingState",
                type: {
                    name: "Enum",
                    allowedValues: ["Disabled", "Enabled"]
                }
            }, exemptPrincipals: {
                serializedName: "properties.exemptPrincipals",
                type: {
                    name: "String"
                }
            }, applicationPrincipals: {
                serializedName: "properties.applicationPrincipals",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, maskingLevel: {
                serializedName: "properties.maskingLevel",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DataMaskingRule = {
    type: {
        name: "Composite",
        className: "DataMaskingRule",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, idPropertiesId: {
                serializedName: "properties.id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, aliasName: {
                serializedName: "properties.aliasName",
                type: {
                    name: "String"
                }
            }, ruleState: {
                serializedName: "properties.ruleState",
                type: {
                    name: "Enum",
                    allowedValues: ["Disabled", "Enabled"]
                }
            }, schemaName: {
                serializedName: "properties.schemaName",
                type: {
                    name: "String"
                }
            }, tableName: {
                serializedName: "properties.tableName",
                type: {
                    name: "String"
                }
            }, columnName: {
                serializedName: "properties.columnName",
                type: {
                    name: "String"
                }
            }, maskingFunction: {
                serializedName: "properties.maskingFunction",
                type: {
                    name: "Enum",
                    allowedValues: ["Default", "CCN", "Email", "Number", "SSN", "Text"]
                }
            }, numberFrom: {
                serializedName: "properties.numberFrom",
                type: {
                    name: "String"
                }
            }, numberTo: {
                serializedName: "properties.numberTo",
                type: {
                    name: "String"
                }
            }, prefixSize: {
                serializedName: "properties.prefixSize",
                type: {
                    name: "String"
                }
            }, suffixSize: {
                serializedName: "properties.suffixSize",
                type: {
                    name: "String"
                }
            }, replacementString: {
                serializedName: "properties.replacementString",
                type: {
                    name: "String"
                }
            } })
    }
};
const GeoBackupPolicy = {
    type: {
        name: "Composite",
        className: "GeoBackupPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Disabled", "Enabled"]
                }
            }, storageType: {
                serializedName: "properties.storageType",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ServerCommunicationLink = {
    type: {
        name: "Composite",
        className: "ServerCommunicationLink",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, partnerServer: {
                serializedName: "properties.partnerServer",
                type: {
                    name: "String"
                }
            } })
    }
};
const ServiceObjective = {
    type: {
        name: "Composite",
        className: "ServiceObjective",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { serviceObjectiveName: {
                serializedName: "properties.serviceObjectiveName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, isDefault: {
                serializedName: "properties.isDefault",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, isSystem: {
                serializedName: "properties.isSystem",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, enabled: {
                serializedName: "properties.enabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ElasticPoolActivity = {
    type: {
        name: "Composite",
        className: "ElasticPoolActivity",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, errorCode: {
                serializedName: "properties.errorCode",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, errorMessage: {
                serializedName: "properties.errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorSeverity: {
                serializedName: "properties.errorSeverity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, operation: {
                serializedName: "properties.operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, operationId: {
                serializedName: "properties.operationId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }, percentComplete: {
                serializedName: "properties.percentComplete",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, requestedDatabaseDtuMax: {
                serializedName: "properties.requestedDatabaseDtuMax",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, requestedDatabaseDtuMin: {
                serializedName: "properties.requestedDatabaseDtuMin",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, requestedDtu: {
                serializedName: "properties.requestedDtu",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, requestedElasticPoolName: {
                serializedName: "properties.requestedElasticPoolName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requestedStorageLimitInGB: {
                serializedName: "properties.requestedStorageLimitInGB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, elasticPoolName: {
                serializedName: "properties.elasticPoolName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serverName: {
                serializedName: "properties.serverName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requestedStorageLimitInMB: {
                serializedName: "properties.requestedStorageLimitInMB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, requestedDatabaseDtuGuarantee: {
                serializedName: "properties.requestedDatabaseDtuGuarantee",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, requestedDatabaseDtuCap: {
                serializedName: "properties.requestedDatabaseDtuCap",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, requestedDtuGuarantee: {
                serializedName: "properties.requestedDtuGuarantee",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const ElasticPoolDatabaseActivity = {
    type: {
        name: "Composite",
        className: "ElasticPoolDatabaseActivity",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, databaseName: {
                serializedName: "properties.databaseName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, errorCode: {
                serializedName: "properties.errorCode",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, errorMessage: {
                serializedName: "properties.errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorSeverity: {
                serializedName: "properties.errorSeverity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, operation: {
                serializedName: "properties.operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, operationId: {
                serializedName: "properties.operationId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }, percentComplete: {
                serializedName: "properties.percentComplete",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, requestedElasticPoolName: {
                serializedName: "properties.requestedElasticPoolName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, currentElasticPoolName: {
                serializedName: "properties.currentElasticPoolName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, currentServiceObjective: {
                serializedName: "properties.currentServiceObjective",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requestedServiceObjective: {
                serializedName: "properties.requestedServiceObjective",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serverName: {
                serializedName: "properties.serverName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExtendedDatabaseBlobAuditingPolicy = {
    type: {
        name: "Composite",
        className: "ExtendedDatabaseBlobAuditingPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { predicateExpression: {
                serializedName: "properties.predicateExpression",
                type: {
                    name: "String"
                }
            }, retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            }, auditActionsAndGroups: {
                serializedName: "properties.auditActionsAndGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, isStorageSecondaryKeyInUse: {
                serializedName: "properties.isStorageSecondaryKeyInUse",
                type: {
                    name: "Boolean"
                }
            }, isAzureMonitorTargetEnabled: {
                serializedName: "properties.isAzureMonitorTargetEnabled",
                type: {
                    name: "Boolean"
                }
            }, queueDelayMs: {
                serializedName: "properties.queueDelayMs",
                type: {
                    name: "Number"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, storageEndpoint: {
                serializedName: "properties.storageEndpoint",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, storageAccountSubscriptionId: {
                serializedName: "properties.storageAccountSubscriptionId",
                type: {
                    name: "Uuid"
                }
            } })
    }
};
const ExtendedServerBlobAuditingPolicy = {
    type: {
        name: "Composite",
        className: "ExtendedServerBlobAuditingPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { isDevopsAuditEnabled: {
                serializedName: "properties.isDevopsAuditEnabled",
                type: {
                    name: "Boolean"
                }
            }, predicateExpression: {
                serializedName: "properties.predicateExpression",
                type: {
                    name: "String"
                }
            }, retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            }, auditActionsAndGroups: {
                serializedName: "properties.auditActionsAndGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, isStorageSecondaryKeyInUse: {
                serializedName: "properties.isStorageSecondaryKeyInUse",
                type: {
                    name: "Boolean"
                }
            }, isAzureMonitorTargetEnabled: {
                serializedName: "properties.isAzureMonitorTargetEnabled",
                type: {
                    name: "Boolean"
                }
            }, queueDelayMs: {
                serializedName: "properties.queueDelayMs",
                type: {
                    name: "Number"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, storageEndpoint: {
                serializedName: "properties.storageEndpoint",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, storageAccountSubscriptionId: {
                serializedName: "properties.storageAccountSubscriptionId",
                type: {
                    name: "Uuid"
                }
            } })
    }
};
const ServerBlobAuditingPolicy = {
    type: {
        name: "Composite",
        className: "ServerBlobAuditingPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { isDevopsAuditEnabled: {
                serializedName: "properties.isDevopsAuditEnabled",
                type: {
                    name: "Boolean"
                }
            }, retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            }, auditActionsAndGroups: {
                serializedName: "properties.auditActionsAndGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, isStorageSecondaryKeyInUse: {
                serializedName: "properties.isStorageSecondaryKeyInUse",
                type: {
                    name: "Boolean"
                }
            }, isAzureMonitorTargetEnabled: {
                serializedName: "properties.isAzureMonitorTargetEnabled",
                type: {
                    name: "Boolean"
                }
            }, queueDelayMs: {
                serializedName: "properties.queueDelayMs",
                type: {
                    name: "Number"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, storageEndpoint: {
                serializedName: "properties.storageEndpoint",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, storageAccountSubscriptionId: {
                serializedName: "properties.storageAccountSubscriptionId",
                type: {
                    name: "Uuid"
                }
            } })
    }
};
const DatabaseBlobAuditingPolicy = {
    type: {
        name: "Composite",
        className: "DatabaseBlobAuditingPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            }, auditActionsAndGroups: {
                serializedName: "properties.auditActionsAndGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, isStorageSecondaryKeyInUse: {
                serializedName: "properties.isStorageSecondaryKeyInUse",
                type: {
                    name: "Boolean"
                }
            }, isAzureMonitorTargetEnabled: {
                serializedName: "properties.isAzureMonitorTargetEnabled",
                type: {
                    name: "Boolean"
                }
            }, queueDelayMs: {
                serializedName: "properties.queueDelayMs",
                type: {
                    name: "Number"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, storageEndpoint: {
                serializedName: "properties.storageEndpoint",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, storageAccountSubscriptionId: {
                serializedName: "properties.storageAccountSubscriptionId",
                type: {
                    name: "Uuid"
                }
            } })
    }
};
const RecommendedAction = {
    type: {
        name: "Composite",
        className: "RecommendedAction",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, recommendationReason: {
                serializedName: "properties.recommendationReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, validSince: {
                serializedName: "properties.validSince",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, lastRefresh: {
                serializedName: "properties.lastRefresh",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "Composite",
                    className: "RecommendedActionStateInfo"
                }
            }, isExecutableAction: {
                serializedName: "properties.isExecutableAction",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, isRevertableAction: {
                serializedName: "properties.isRevertableAction",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, isArchivedAction: {
                serializedName: "properties.isArchivedAction",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, executeActionStartTime: {
                serializedName: "properties.executeActionStartTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, executeActionDuration: {
                serializedName: "properties.executeActionDuration",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, revertActionStartTime: {
                serializedName: "properties.revertActionStartTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, revertActionDuration: {
                serializedName: "properties.revertActionDuration",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, executeActionInitiatedBy: {
                serializedName: "properties.executeActionInitiatedBy",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["User", "System"]
                }
            }, executeActionInitiatedTime: {
                serializedName: "properties.executeActionInitiatedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, revertActionInitiatedBy: {
                serializedName: "properties.revertActionInitiatedBy",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["User", "System"]
                }
            }, revertActionInitiatedTime: {
                serializedName: "properties.revertActionInitiatedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, score: {
                serializedName: "properties.score",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, implementationDetails: {
                serializedName: "properties.implementationDetails",
                type: {
                    name: "Composite",
                    className: "RecommendedActionImplementationInfo"
                }
            }, errorDetails: {
                serializedName: "properties.errorDetails",
                type: {
                    name: "Composite",
                    className: "RecommendedActionErrorInfo"
                }
            }, estimatedImpact: {
                serializedName: "properties.estimatedImpact",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecommendedActionImpactRecord"
                        }
                    }
                }
            }, observedImpact: {
                serializedName: "properties.observedImpact",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecommendedActionImpactRecord"
                        }
                    }
                }
            }, timeSeries: {
                serializedName: "properties.timeSeries",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecommendedActionMetricInfo"
                        }
                    }
                }
            }, linkedObjects: {
                serializedName: "properties.linkedObjects",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, details: {
                serializedName: "properties.details",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            } })
    }
};
const Advisor = {
    type: {
        name: "Composite",
        className: "Advisor",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, advisorStatus: {
                serializedName: "properties.advisorStatus",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "GA",
                        "PublicPreview",
                        "LimitedPublicPreview",
                        "PrivatePreview"
                    ]
                }
            }, autoExecuteStatus: {
                serializedName: "properties.autoExecuteStatus",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled", "Default"]
                }
            }, autoExecuteStatusInheritedFrom: {
                serializedName: "properties.autoExecuteStatusInheritedFrom",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Default",
                        "Subscription",
                        "Server",
                        "ElasticPool",
                        "Database"
                    ]
                }
            }, recommendationsStatus: {
                serializedName: "properties.recommendationsStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, lastChecked: {
                serializedName: "properties.lastChecked",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, recommendedActions: {
                serializedName: "properties.recommendedActions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecommendedAction"
                        }
                    }
                }
            } })
    }
};
const DatabaseAutomaticTuning = {
    type: {
        name: "Composite",
        className: "DatabaseAutomaticTuning",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { desiredState: {
                serializedName: "properties.desiredState",
                type: {
                    name: "Enum",
                    allowedValues: ["Inherit", "Custom", "Auto", "Unspecified"]
                }
            }, actualState: {
                serializedName: "properties.actualState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Inherit", "Custom", "Auto", "Unspecified"]
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "AutomaticTuningOptions" }
                    }
                }
            } })
    }
};
const DatabaseColumn = {
    type: {
        name: "Composite",
        className: "DatabaseColumn",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { columnType: {
                serializedName: "properties.columnType",
                type: {
                    name: "String"
                }
            }, temporalType: {
                serializedName: "properties.temporalType",
                type: {
                    name: "String"
                }
            }, memoryOptimized: {
                serializedName: "properties.memoryOptimized",
                type: {
                    name: "Boolean"
                }
            }, isComputed: {
                serializedName: "properties.isComputed",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const DatabaseSchema = {
    type: {
        name: "Composite",
        className: "DatabaseSchema",
        modelProperties: Object.assign({}, ProxyResource.type.modelProperties)
    }
};
const DatabaseSecurityAlertPolicy = {
    type: {
        name: "Composite",
        className: "DatabaseSecurityAlertPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, disabledAlerts: {
                serializedName: "properties.disabledAlerts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, emailAddresses: {
                serializedName: "properties.emailAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, emailAccountAdmins: {
                serializedName: "properties.emailAccountAdmins",
                type: {
                    name: "Boolean"
                }
            }, storageEndpoint: {
                serializedName: "properties.storageEndpoint",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            }, creationTime: {
                serializedName: "properties.creationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const DatabaseTable = {
    type: {
        name: "Composite",
        className: "DatabaseTable",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { temporalType: {
                serializedName: "properties.temporalType",
                type: {
                    name: "String"
                }
            }, memoryOptimized: {
                serializedName: "properties.memoryOptimized",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const DatabaseVulnerabilityAssessmentRuleBaseline = {
    type: {
        name: "Composite",
        className: "DatabaseVulnerabilityAssessmentRuleBaseline",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { baselineResults: {
                serializedName: "properties.baselineResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseVulnerabilityAssessmentRuleBaselineItem"
                        }
                    }
                }
            } })
    }
};
const DatabaseVulnerabilityAssessment = {
    type: {
        name: "Composite",
        className: "DatabaseVulnerabilityAssessment",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { storageContainerPath: {
                serializedName: "properties.storageContainerPath",
                type: {
                    name: "String"
                }
            }, storageContainerSasKey: {
                serializedName: "properties.storageContainerSasKey",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, recurringScans: {
                serializedName: "properties.recurringScans",
                type: {
                    name: "Composite",
                    className: "VulnerabilityAssessmentRecurringScansProperties"
                }
            } })
    }
};
const VulnerabilityAssessmentScanRecord = {
    type: {
        name: "Composite",
        className: "VulnerabilityAssessmentScanRecord",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { scanId: {
                serializedName: "properties.scanId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, triggerType: {
                serializedName: "properties.triggerType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, errors: {
                serializedName: "properties.errors",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VulnerabilityAssessmentScanError"
                        }
                    }
                }
            }, storageContainerPath: {
                serializedName: "properties.storageContainerPath",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, numberOfFailedSecurityChecks: {
                serializedName: "properties.numberOfFailedSecurityChecks",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const DatabaseVulnerabilityAssessmentScansExport = {
    type: {
        name: "Composite",
        className: "DatabaseVulnerabilityAssessmentScansExport",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { exportedReportLocation: {
                serializedName: "properties.exportedReportLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DataWarehouseUserActivities = {
    type: {
        name: "Composite",
        className: "DataWarehouseUserActivities",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { activeQueriesCount: {
                serializedName: "properties.activeQueriesCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const DeletedServer = {
    type: {
        name: "Composite",
        className: "DeletedServer",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { version: {
                serializedName: "properties.version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deletionTime: {
                serializedName: "properties.deletionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, originalId: {
                serializedName: "properties.originalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, fullyQualifiedDomainName: {
                serializedName: "properties.fullyQualifiedDomainName",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ElasticPoolOperation = {
    type: {
        name: "Composite",
        className: "ElasticPoolOperation",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { elasticPoolName: {
                serializedName: "properties.elasticPoolName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, operation: {
                serializedName: "properties.operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, operationFriendlyName: {
                serializedName: "properties.operationFriendlyName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, percentComplete: {
                serializedName: "properties.percentComplete",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, serverName: {
                serializedName: "properties.serverName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorCode: {
                serializedName: "properties.errorCode",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, errorDescription: {
                serializedName: "properties.errorDescription",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorSeverity: {
                serializedName: "properties.errorSeverity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, isUserError: {
                serializedName: "properties.isUserError",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, estimatedCompletionTime: {
                serializedName: "properties.estimatedCompletionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, isCancellable: {
                serializedName: "properties.isCancellable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const EncryptionProtector = {
    type: {
        name: "Composite",
        className: "EncryptionProtector",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subregion: {
                serializedName: "properties.subregion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serverKeyName: {
                serializedName: "properties.serverKeyName",
                type: {
                    name: "String"
                }
            }, serverKeyType: {
                serializedName: "properties.serverKeyType",
                type: {
                    name: "String"
                }
            }, uri: {
                serializedName: "properties.uri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, autoRotationEnabled: {
                serializedName: "properties.autoRotationEnabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const FailoverGroup = {
    type: {
        name: "Composite",
        className: "FailoverGroup",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, readWriteEndpoint: {
                serializedName: "properties.readWriteEndpoint",
                type: {
                    name: "Composite",
                    className: "FailoverGroupReadWriteEndpoint"
                }
            }, readOnlyEndpoint: {
                serializedName: "properties.readOnlyEndpoint",
                type: {
                    name: "Composite",
                    className: "FailoverGroupReadOnlyEndpoint"
                }
            }, replicationRole: {
                serializedName: "properties.replicationRole",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, replicationState: {
                serializedName: "properties.replicationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, partnerServers: {
                serializedName: "properties.partnerServers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PartnerInfo"
                        }
                    }
                }
            }, databases: {
                serializedName: "properties.databases",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const InstanceFailoverGroup = {
    type: {
        name: "Composite",
        className: "InstanceFailoverGroup",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { readWriteEndpoint: {
                serializedName: "properties.readWriteEndpoint",
                type: {
                    name: "Composite",
                    className: "InstanceFailoverGroupReadWriteEndpoint"
                }
            }, readOnlyEndpoint: {
                serializedName: "properties.readOnlyEndpoint",
                type: {
                    name: "Composite",
                    className: "InstanceFailoverGroupReadOnlyEndpoint"
                }
            }, replicationRole: {
                serializedName: "properties.replicationRole",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, replicationState: {
                serializedName: "properties.replicationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, partnerRegions: {
                serializedName: "properties.partnerRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PartnerRegionInfo"
                        }
                    }
                }
            }, managedInstancePairs: {
                serializedName: "properties.managedInstancePairs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstancePairInfo"
                        }
                    }
                }
            } })
    }
};
const JobCredential = {
    type: {
        name: "Composite",
        className: "JobCredential",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { username: {
                serializedName: "properties.username",
                type: {
                    name: "String"
                }
            }, password: {
                serializedName: "properties.password",
                type: {
                    name: "String"
                }
            } })
    }
};
const JobExecution = {
    type: {
        name: "Composite",
        className: "JobExecution",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { jobVersion: {
                serializedName: "properties.jobVersion",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, stepName: {
                serializedName: "properties.stepName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, stepId: {
                serializedName: "properties.stepId",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, jobExecutionId: {
                serializedName: "properties.jobExecutionId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }, lifecycle: {
                serializedName: "properties.lifecycle",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, createTime: {
                serializedName: "properties.createTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, currentAttempts: {
                serializedName: "properties.currentAttempts",
                type: {
                    name: "Number"
                }
            }, currentAttemptStartTime: {
                serializedName: "properties.currentAttemptStartTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, lastMessage: {
                serializedName: "properties.lastMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, target: {
                serializedName: "properties.target",
                type: {
                    name: "Composite",
                    className: "JobExecutionTarget"
                }
            } })
    }
};
const Job = {
    type: {
        name: "Composite",
        className: "Job",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { description: {
                defaultValue: "",
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "properties.version",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, schedule: {
                serializedName: "properties.schedule",
                type: {
                    name: "Composite",
                    className: "JobSchedule"
                }
            } })
    }
};
const JobStep = {
    type: {
        name: "Composite",
        className: "JobStep",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { stepId: {
                serializedName: "properties.stepId",
                type: {
                    name: "Number"
                }
            }, targetGroup: {
                serializedName: "properties.targetGroup",
                type: {
                    name: "String"
                }
            }, credential: {
                serializedName: "properties.credential",
                type: {
                    name: "String"
                }
            }, action: {
                serializedName: "properties.action",
                type: {
                    name: "Composite",
                    className: "JobStepAction"
                }
            }, output: {
                serializedName: "properties.output",
                type: {
                    name: "Composite",
                    className: "JobStepOutput"
                }
            }, executionOptions: {
                serializedName: "properties.executionOptions",
                type: {
                    name: "Composite",
                    className: "JobStepExecutionOptions"
                }
            } })
    }
};
const JobTargetGroup = {
    type: {
        name: "Composite",
        className: "JobTargetGroup",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { members: {
                serializedName: "properties.members",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JobTarget"
                        }
                    }
                }
            } })
    }
};
const JobVersion = {
    type: {
        name: "Composite",
        className: "JobVersion",
        modelProperties: Object.assign({}, ProxyResource.type.modelProperties)
    }
};
const LongTermRetentionPolicy = {
    type: {
        name: "Composite",
        className: "LongTermRetentionPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { weeklyRetention: {
                serializedName: "properties.weeklyRetention",
                type: {
                    name: "String"
                }
            }, monthlyRetention: {
                serializedName: "properties.monthlyRetention",
                type: {
                    name: "String"
                }
            }, yearlyRetention: {
                serializedName: "properties.yearlyRetention",
                type: {
                    name: "String"
                }
            }, weekOfYear: {
                serializedName: "properties.weekOfYear",
                type: {
                    name: "Number"
                }
            } })
    }
};
const MaintenanceWindowOptions = {
    type: {
        name: "Composite",
        className: "MaintenanceWindowOptions",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { isEnabled: {
                serializedName: "properties.isEnabled",
                type: {
                    name: "Boolean"
                }
            }, maintenanceWindowCycles: {
                serializedName: "properties.maintenanceWindowCycles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MaintenanceWindowTimeRange"
                        }
                    }
                }
            }, minDurationInMinutes: {
                serializedName: "properties.minDurationInMinutes",
                type: {
                    name: "Number"
                }
            }, defaultDurationInMinutes: {
                serializedName: "properties.defaultDurationInMinutes",
                type: {
                    name: "Number"
                }
            }, minCycles: {
                serializedName: "properties.minCycles",
                type: {
                    name: "Number"
                }
            }, timeGranularityInMinutes: {
                serializedName: "properties.timeGranularityInMinutes",
                type: {
                    name: "Number"
                }
            }, allowMultipleMaintenanceWindowsPerCycle: {
                serializedName: "properties.allowMultipleMaintenanceWindowsPerCycle",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const MaintenanceWindows = {
    type: {
        name: "Composite",
        className: "MaintenanceWindows",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { timeRanges: {
                serializedName: "properties.timeRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MaintenanceWindowTimeRange"
                        }
                    }
                }
            } })
    }
};
const ManagedBackupShortTermRetentionPolicy = {
    type: {
        name: "Composite",
        className: "ManagedBackupShortTermRetentionPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            } })
    }
};
const ManagedInstanceQuery = {
    type: {
        name: "Composite",
        className: "ManagedInstanceQuery",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { queryText: {
                serializedName: "properties.queryText",
                type: {
                    name: "String"
                }
            } })
    }
};
const QueryStatistics = {
    type: {
        name: "Composite",
        className: "QueryStatistics",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { databaseName: {
                serializedName: "properties.databaseName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, queryId: {
                serializedName: "properties.queryId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, intervals: {
                serializedName: "properties.intervals",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryMetricInterval"
                        }
                    }
                }
            } })
    }
};
const ManagedDatabaseRestoreDetailsResult = {
    type: {
        name: "Composite",
        className: "ManagedDatabaseRestoreDetailsResult",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, currentRestoringFileName: {
                serializedName: "properties.currentRestoringFileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, lastRestoredFileName: {
                serializedName: "properties.lastRestoredFileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, lastRestoredFileTime: {
                serializedName: "properties.lastRestoredFileTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, percentCompleted: {
                serializedName: "properties.percentCompleted",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, unrestorableFiles: {
                serializedName: "properties.unrestorableFiles",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, numberOfFilesDetected: {
                serializedName: "properties.numberOfFilesDetected",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, lastUploadedFileName: {
                serializedName: "properties.lastUploadedFileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, lastUploadedFileTime: {
                serializedName: "properties.lastUploadedFileTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, blockReason: {
                serializedName: "properties.blockReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ManagedDatabaseSecurityAlertPolicy = {
    type: {
        name: "Composite",
        className: "ManagedDatabaseSecurityAlertPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["New", "Enabled", "Disabled"]
                }
            }, disabledAlerts: {
                serializedName: "properties.disabledAlerts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, emailAddresses: {
                serializedName: "properties.emailAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, emailAccountAdmins: {
                serializedName: "properties.emailAccountAdmins",
                type: {
                    name: "Boolean"
                }
            }, storageEndpoint: {
                serializedName: "properties.storageEndpoint",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            }, creationTime: {
                serializedName: "properties.creationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const SecurityEvent = {
    type: {
        name: "Composite",
        className: "SecurityEvent",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { eventTime: {
                serializedName: "properties.eventTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, securityEventType: {
                serializedName: "properties.securityEventType",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Undefined",
                        "SqlInjectionVulnerability",
                        "SqlInjectionExploit"
                    ]
                }
            }, subscription: {
                serializedName: "properties.subscription",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, server: {
                serializedName: "properties.server",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, database: {
                serializedName: "properties.database",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, clientIp: {
                serializedName: "properties.clientIp",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, applicationName: {
                serializedName: "properties.applicationName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, principalName: {
                serializedName: "properties.principalName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, securityEventSqlInjectionAdditionalProperties: {
                serializedName: "properties.securityEventSqlInjectionAdditionalProperties",
                type: {
                    name: "Composite",
                    className: "SecurityEventSqlInjectionAdditionalProperties"
                }
            } })
    }
};
const SensitivityLabel = {
    type: {
        name: "Composite",
        className: "SensitivityLabel",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { managedBy: {
                serializedName: "managedBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, schemaName: {
                serializedName: "properties.schemaName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, tableName: {
                serializedName: "properties.tableName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, columnName: {
                serializedName: "properties.columnName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, labelName: {
                serializedName: "properties.labelName",
                type: {
                    name: "String"
                }
            }, labelId: {
                serializedName: "properties.labelId",
                type: {
                    name: "String"
                }
            }, informationType: {
                serializedName: "properties.informationType",
                type: {
                    name: "String"
                }
            }, informationTypeId: {
                serializedName: "properties.informationTypeId",
                type: {
                    name: "String"
                }
            }, isDisabled: {
                serializedName: "properties.isDisabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, rank: {
                serializedName: "properties.rank",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "Low", "Medium", "High", "Critical"]
                }
            } })
    }
};
const SensitivityLabelUpdate = {
    type: {
        name: "Composite",
        className: "SensitivityLabelUpdate",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { op: {
                serializedName: "properties.op",
                type: {
                    name: "Enum",
                    allowedValues: ["set", "remove"]
                }
            }, schema: {
                serializedName: "properties.schema",
                type: {
                    name: "String"
                }
            }, table: {
                serializedName: "properties.table",
                type: {
                    name: "String"
                }
            }, column: {
                serializedName: "properties.column",
                type: {
                    name: "String"
                }
            }, sensitivityLabel: {
                serializedName: "properties.sensitivityLabel",
                type: {
                    name: "Composite",
                    className: "SensitivityLabel"
                }
            } })
    }
};
const RecommendedSensitivityLabelUpdate = {
    type: {
        name: "Composite",
        className: "RecommendedSensitivityLabelUpdate",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { op: {
                serializedName: "properties.op",
                type: {
                    name: "Enum",
                    allowedValues: ["enable", "disable"]
                }
            }, schema: {
                serializedName: "properties.schema",
                type: {
                    name: "String"
                }
            }, table: {
                serializedName: "properties.table",
                type: {
                    name: "String"
                }
            }, column: {
                serializedName: "properties.column",
                type: {
                    name: "String"
                }
            } })
    }
};
const ManagedTransparentDataEncryption = {
    type: {
        name: "Composite",
        className: "ManagedTransparentDataEncryption",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            } })
    }
};
const ManagedInstanceAdministrator = {
    type: {
        name: "Composite",
        className: "ManagedInstanceAdministrator",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { administratorType: {
                serializedName: "properties.administratorType",
                type: {
                    name: "String"
                }
            }, login: {
                serializedName: "properties.login",
                type: {
                    name: "String"
                }
            }, sid: {
                serializedName: "properties.sid",
                type: {
                    name: "Uuid"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                type: {
                    name: "Uuid"
                }
            } })
    }
};
const ManagedInstanceAzureADOnlyAuthentication = {
    type: {
        name: "Composite",
        className: "ManagedInstanceAzureADOnlyAuthentication",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { azureADOnlyAuthentication: {
                serializedName: "properties.azureADOnlyAuthentication",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ManagedInstanceEncryptionProtector = {
    type: {
        name: "Composite",
        className: "ManagedInstanceEncryptionProtector",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serverKeyName: {
                serializedName: "properties.serverKeyName",
                type: {
                    name: "String"
                }
            }, serverKeyType: {
                serializedName: "properties.serverKeyType",
                type: {
                    name: "String"
                }
            }, uri: {
                serializedName: "properties.uri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, autoRotationEnabled: {
                serializedName: "properties.autoRotationEnabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ManagedInstanceKey = {
    type: {
        name: "Composite",
        className: "ManagedInstanceKey",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serverKeyType: {
                serializedName: "properties.serverKeyType",
                type: {
                    name: "String"
                }
            }, uri: {
                serializedName: "properties.uri",
                type: {
                    name: "String"
                }
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, autoRotationEnabled: {
                serializedName: "properties.autoRotationEnabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ManagedInstanceLongTermRetentionPolicy = {
    type: {
        name: "Composite",
        className: "ManagedInstanceLongTermRetentionPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { weeklyRetention: {
                serializedName: "properties.weeklyRetention",
                type: {
                    name: "String"
                }
            }, monthlyRetention: {
                serializedName: "properties.monthlyRetention",
                type: {
                    name: "String"
                }
            }, yearlyRetention: {
                serializedName: "properties.yearlyRetention",
                type: {
                    name: "String"
                }
            }, weekOfYear: {
                serializedName: "properties.weekOfYear",
                type: {
                    name: "Number"
                }
            } })
    }
};
const ManagedInstanceOperation = {
    type: {
        name: "Composite",
        className: "ManagedInstanceOperation",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { managedInstanceName: {
                serializedName: "properties.managedInstanceName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, operation: {
                serializedName: "properties.operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, operationFriendlyName: {
                serializedName: "properties.operationFriendlyName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, percentComplete: {
                serializedName: "properties.percentComplete",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorCode: {
                serializedName: "properties.errorCode",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, errorDescription: {
                serializedName: "properties.errorDescription",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorSeverity: {
                serializedName: "properties.errorSeverity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, isUserError: {
                serializedName: "properties.isUserError",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, estimatedCompletionTime: {
                serializedName: "properties.estimatedCompletionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, isCancellable: {
                serializedName: "properties.isCancellable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, operationParameters: {
                serializedName: "properties.operationParameters",
                type: {
                    name: "Composite",
                    className: "ManagedInstanceOperationParametersPair"
                }
            }, operationSteps: {
                serializedName: "properties.operationSteps",
                type: {
                    name: "Composite",
                    className: "ManagedInstanceOperationSteps"
                }
            } })
    }
};
const ManagedInstancePrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "ManagedInstancePrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "ManagedInstancePrivateEndpointProperty"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "ManagedInstancePrivateLinkServiceConnectionStateProperty"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ManagedInstancePrivateLink = {
    type: {
        name: "Composite",
        className: "ManagedInstancePrivateLink",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ManagedInstancePrivateLinkProperties"
                }
            } })
    }
};
const TdeCertificate = {
    type: {
        name: "Composite",
        className: "TdeCertificate",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { privateBlob: {
                serializedName: "properties.privateBlob",
                type: {
                    name: "String"
                }
            }, certPassword: {
                serializedName: "properties.certPassword",
                type: {
                    name: "String"
                }
            } })
    }
};
const ManagedInstanceVulnerabilityAssessment = {
    type: {
        name: "Composite",
        className: "ManagedInstanceVulnerabilityAssessment",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { storageContainerPath: {
                serializedName: "properties.storageContainerPath",
                type: {
                    name: "String"
                }
            }, storageContainerSasKey: {
                serializedName: "properties.storageContainerSasKey",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, recurringScans: {
                serializedName: "properties.recurringScans",
                type: {
                    name: "Composite",
                    className: "VulnerabilityAssessmentRecurringScansProperties"
                }
            } })
    }
};
const ManagedServerSecurityAlertPolicy = {
    type: {
        name: "Composite",
        className: "ManagedServerSecurityAlertPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, disabledAlerts: {
                serializedName: "properties.disabledAlerts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, emailAddresses: {
                serializedName: "properties.emailAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, emailAccountAdmins: {
                serializedName: "properties.emailAccountAdmins",
                type: {
                    name: "Boolean"
                }
            }, storageEndpoint: {
                serializedName: "properties.storageEndpoint",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            }, creationTime: {
                serializedName: "properties.creationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const OperationsHealth = {
    type: {
        name: "Composite",
        className: "OperationsHealth",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { namePropertiesName: {
                serializedName: "properties.name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, health: {
                serializedName: "properties.health",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpointProperty"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionStateProperty"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "PrivateLinkResourceProperties"
                }
            } })
    }
};
const RecoverableManagedDatabase = {
    type: {
        name: "Composite",
        className: "RecoverableManagedDatabase",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { lastAvailableBackupDate: {
                serializedName: "properties.lastAvailableBackupDate",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const RestorePoint = {
    type: {
        name: "Composite",
        className: "RestorePoint",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, restorePointType: {
                serializedName: "properties.restorePointType",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["CONTINUOUS", "DISCRETE"]
                }
            }, earliestRestoreDate: {
                serializedName: "properties.earliestRestoreDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, restorePointCreationDate: {
                serializedName: "properties.restorePointCreationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, restorePointLabel: {
                serializedName: "properties.restorePointLabel",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ServerAutomaticTuning = {
    type: {
        name: "Composite",
        className: "ServerAutomaticTuning",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { desiredState: {
                serializedName: "properties.desiredState",
                type: {
                    name: "Enum",
                    allowedValues: ["Custom", "Auto", "Unspecified"]
                }
            }, actualState: {
                serializedName: "properties.actualState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Custom", "Auto", "Unspecified"]
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "AutomaticTuningServerOptions"
                        }
                    }
                }
            } })
    }
};
const ServerAzureADAdministrator = {
    type: {
        name: "Composite",
        className: "ServerAzureADAdministrator",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { administratorType: {
                serializedName: "properties.administratorType",
                type: {
                    name: "String"
                }
            }, login: {
                serializedName: "properties.login",
                type: {
                    name: "String"
                }
            }, sid: {
                serializedName: "properties.sid",
                type: {
                    name: "Uuid"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                type: {
                    name: "Uuid"
                }
            }, azureADOnlyAuthentication: {
                serializedName: "properties.azureADOnlyAuthentication",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ServerAzureADOnlyAuthentication = {
    type: {
        name: "Composite",
        className: "ServerAzureADOnlyAuthentication",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { azureADOnlyAuthentication: {
                serializedName: "properties.azureADOnlyAuthentication",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ServerDevOpsAuditingSettings = {
    type: {
        name: "Composite",
        className: "ServerDevOpsAuditingSettings",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, isAzureMonitorTargetEnabled: {
                serializedName: "properties.isAzureMonitorTargetEnabled",
                type: {
                    name: "Boolean"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, storageEndpoint: {
                serializedName: "properties.storageEndpoint",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, storageAccountSubscriptionId: {
                serializedName: "properties.storageAccountSubscriptionId",
                type: {
                    name: "Uuid"
                }
            } })
    }
};
const ServerDnsAlias = {
    type: {
        name: "Composite",
        className: "ServerDnsAlias",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { azureDnsRecord: {
                serializedName: "properties.azureDnsRecord",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ServerKey = {
    type: {
        name: "Composite",
        className: "ServerKey",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subregion: {
                serializedName: "properties.subregion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serverKeyType: {
                serializedName: "properties.serverKeyType",
                type: {
                    name: "String"
                }
            }, uri: {
                serializedName: "properties.uri",
                type: {
                    name: "String"
                }
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, autoRotationEnabled: {
                serializedName: "properties.autoRotationEnabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ServerOperation = {
    type: {
        name: "Composite",
        className: "ServerOperation",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { operation: {
                serializedName: "properties.operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, operationFriendlyName: {
                serializedName: "properties.operationFriendlyName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, percentComplete: {
                serializedName: "properties.percentComplete",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, serverName: {
                serializedName: "properties.serverName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorCode: {
                serializedName: "properties.errorCode",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, errorDescription: {
                serializedName: "properties.errorDescription",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorSeverity: {
                serializedName: "properties.errorSeverity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, isUserError: {
                serializedName: "properties.isUserError",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, estimatedCompletionTime: {
                serializedName: "properties.estimatedCompletionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, isCancellable: {
                serializedName: "properties.isCancellable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ServerSecurityAlertPolicy = {
    type: {
        name: "Composite",
        className: "ServerSecurityAlertPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, disabledAlerts: {
                serializedName: "properties.disabledAlerts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, emailAddresses: {
                serializedName: "properties.emailAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, emailAccountAdmins: {
                serializedName: "properties.emailAccountAdmins",
                type: {
                    name: "Boolean"
                }
            }, storageEndpoint: {
                serializedName: "properties.storageEndpoint",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            }, creationTime: {
                serializedName: "properties.creationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const ServerTrustGroup = {
    type: {
        name: "Composite",
        className: "ServerTrustGroup",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { groupMembers: {
                serializedName: "properties.groupMembers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerInfo"
                        }
                    }
                }
            }, trustScopes: {
                serializedName: "properties.trustScopes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ServerVulnerabilityAssessment = {
    type: {
        name: "Composite",
        className: "ServerVulnerabilityAssessment",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { storageContainerPath: {
                serializedName: "properties.storageContainerPath",
                type: {
                    name: "String"
                }
            }, storageContainerSasKey: {
                serializedName: "properties.storageContainerSasKey",
                type: {
                    name: "String"
                }
            }, storageAccountAccessKey: {
                serializedName: "properties.storageAccountAccessKey",
                type: {
                    name: "String"
                }
            }, recurringScans: {
                serializedName: "properties.recurringScans",
                type: {
                    name: "Composite",
                    className: "VulnerabilityAssessmentRecurringScansProperties"
                }
            } })
    }
};
const SqlAgentConfiguration = {
    type: {
        name: "Composite",
        className: "SqlAgentConfiguration",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            } })
    }
};
const SubscriptionUsage = {
    type: {
        name: "Composite",
        className: "SubscriptionUsage",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, currentValue: {
                serializedName: "properties.currentValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, limit: {
                serializedName: "properties.limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, unit: {
                serializedName: "properties.unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SyncAgent = {
    type: {
        name: "Composite",
        className: "SyncAgent",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { namePropertiesName: {
                serializedName: "properties.name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, syncDatabaseId: {
                serializedName: "properties.syncDatabaseId",
                type: {
                    name: "String"
                }
            }, lastAliveTime: {
                serializedName: "properties.lastAliveTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, isUpToDate: {
                serializedName: "properties.isUpToDate",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, expiryTime: {
                serializedName: "properties.expiryTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, version: {
                serializedName: "properties.version",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SyncAgentLinkedDatabase = {
    type: {
        name: "Composite",
        className: "SyncAgentLinkedDatabase",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { databaseType: {
                serializedName: "properties.databaseType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, databaseId: {
                serializedName: "properties.databaseId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serverName: {
                serializedName: "properties.serverName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, databaseName: {
                serializedName: "properties.databaseName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, userName: {
                serializedName: "properties.userName",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SyncGroup = {
    type: {
        name: "Composite",
        className: "SyncGroup",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, interval: {
                serializedName: "properties.interval",
                type: {
                    name: "Number"
                }
            }, lastSyncTime: {
                serializedName: "properties.lastSyncTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, conflictResolutionPolicy: {
                serializedName: "properties.conflictResolutionPolicy",
                type: {
                    name: "String"
                }
            }, syncDatabaseId: {
                serializedName: "properties.syncDatabaseId",
                type: {
                    name: "String"
                }
            }, hubDatabaseUserName: {
                serializedName: "properties.hubDatabaseUserName",
                type: {
                    name: "String"
                }
            }, hubDatabasePassword: {
                serializedName: "properties.hubDatabasePassword",
                type: {
                    name: "String"
                }
            }, syncState: {
                serializedName: "properties.syncState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, schema: {
                serializedName: "properties.schema",
                type: {
                    name: "Composite",
                    className: "SyncGroupSchema"
                }
            }, enableConflictLogging: {
                serializedName: "properties.enableConflictLogging",
                type: {
                    name: "Boolean"
                }
            }, conflictLoggingRetentionInDays: {
                serializedName: "properties.conflictLoggingRetentionInDays",
                type: {
                    name: "Number"
                }
            }, usePrivateLinkConnection: {
                serializedName: "properties.usePrivateLinkConnection",
                type: {
                    name: "Boolean"
                }
            }, privateEndpointName: {
                serializedName: "properties.privateEndpointName",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SyncMember = {
    type: {
        name: "Composite",
        className: "SyncMember",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { databaseType: {
                serializedName: "properties.databaseType",
                type: {
                    name: "String"
                }
            }, syncAgentId: {
                serializedName: "properties.syncAgentId",
                type: {
                    name: "String"
                }
            }, sqlServerDatabaseId: {
                serializedName: "properties.sqlServerDatabaseId",
                type: {
                    name: "Uuid"
                }
            }, syncMemberAzureDatabaseResourceId: {
                serializedName: "properties.syncMemberAzureDatabaseResourceId",
                type: {
                    name: "String"
                }
            }, usePrivateLinkConnection: {
                serializedName: "properties.usePrivateLinkConnection",
                type: {
                    name: "Boolean"
                }
            }, privateEndpointName: {
                serializedName: "properties.privateEndpointName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serverName: {
                serializedName: "properties.serverName",
                type: {
                    name: "String"
                }
            }, databaseName: {
                serializedName: "properties.databaseName",
                type: {
                    name: "String"
                }
            }, userName: {
                serializedName: "properties.userName",
                type: {
                    name: "String"
                }
            }, password: {
                serializedName: "properties.password",
                type: {
                    name: "String"
                }
            }, syncDirection: {
                serializedName: "properties.syncDirection",
                type: {
                    name: "String"
                }
            }, syncState: {
                serializedName: "properties.syncState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const TimeZone = {
    type: {
        name: "Composite",
        className: "TimeZone",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { timeZoneId: {
                serializedName: "properties.timeZoneId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const UpdateManagedInstanceDnsServersOperation = {
    type: {
        name: "Composite",
        className: "UpdateManagedInstanceDnsServersOperation",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualNetworkRule = {
    type: {
        name: "Composite",
        className: "VirtualNetworkRule",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { virtualNetworkSubnetId: {
                serializedName: "properties.virtualNetworkSubnetId",
                type: {
                    name: "String"
                }
            }, ignoreMissingVnetServiceEndpoint: {
                serializedName: "properties.ignoreMissingVnetServiceEndpoint",
                type: {
                    name: "Boolean"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const WorkloadClassifier = {
    type: {
        name: "Composite",
        className: "WorkloadClassifier",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { memberName: {
                serializedName: "properties.memberName",
                type: {
                    name: "String"
                }
            }, label: {
                serializedName: "properties.label",
                type: {
                    name: "String"
                }
            }, context: {
                serializedName: "properties.context",
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                type: {
                    name: "String"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                type: {
                    name: "String"
                }
            }, importance: {
                serializedName: "properties.importance",
                type: {
                    name: "String"
                }
            } })
    }
};
const WorkloadGroup = {
    type: {
        name: "Composite",
        className: "WorkloadGroup",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { minResourcePercent: {
                serializedName: "properties.minResourcePercent",
                type: {
                    name: "Number"
                }
            }, maxResourcePercent: {
                serializedName: "properties.maxResourcePercent",
                type: {
                    name: "Number"
                }
            }, minResourcePercentPerRequest: {
                serializedName: "properties.minResourcePercentPerRequest",
                type: {
                    name: "Number"
                }
            }, maxResourcePercentPerRequest: {
                serializedName: "properties.maxResourcePercentPerRequest",
                type: {
                    name: "Number"
                }
            }, importance: {
                serializedName: "properties.importance",
                type: {
                    name: "String"
                }
            }, queryExecutionTimeout: {
                serializedName: "properties.queryExecutionTimeout",
                type: {
                    name: "Number"
                }
            } })
    }
};
const LogicalDatabaseTransparentDataEncryption = {
    type: {
        name: "Composite",
        className: "LogicalDatabaseTransparentDataEncryption",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            } })
    }
};
const BackupShortTermRetentionPolicy = {
    type: {
        name: "Composite",
        className: "BackupShortTermRetentionPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { retentionDays: {
                serializedName: "properties.retentionDays",
                type: {
                    name: "Number"
                }
            }, diffBackupIntervalInHours: {
                serializedName: "properties.diffBackupIntervalInHours",
                type: {
                    name: "Number"
                }
            } })
    }
};
const DatabaseExtensions = {
    type: {
        name: "Composite",
        className: "DatabaseExtensions",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { operationMode: {
                serializedName: "properties.operationMode",
                type: {
                    name: "String"
                }
            }, storageKeyType: {
                serializedName: "properties.storageKeyType",
                type: {
                    name: "String"
                }
            }, storageKey: {
                serializedName: "properties.storageKey",
                type: {
                    name: "String"
                }
            }, storageUri: {
                serializedName: "properties.storageUri",
                type: {
                    name: "String"
                }
            } })
    }
};
const ImportExportExtensionsOperationResult = {
    type: {
        name: "Composite",
        className: "ImportExportExtensionsOperationResult",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { requestId: {
                serializedName: "properties.requestId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }, requestType: {
                serializedName: "properties.requestType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, lastModifiedTime: {
                serializedName: "properties.lastModifiedTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serverName: {
                serializedName: "properties.serverName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, databaseName: {
                serializedName: "properties.databaseName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorMessage: {
                serializedName: "properties.errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DatabaseOperation = {
    type: {
        name: "Composite",
        className: "DatabaseOperation",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { databaseName: {
                serializedName: "properties.databaseName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, operation: {
                serializedName: "properties.operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, operationFriendlyName: {
                serializedName: "properties.operationFriendlyName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, percentComplete: {
                serializedName: "properties.percentComplete",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, serverName: {
                serializedName: "properties.serverName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorCode: {
                serializedName: "properties.errorCode",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, errorDescription: {
                serializedName: "properties.errorDescription",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorSeverity: {
                serializedName: "properties.errorSeverity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, isUserError: {
                serializedName: "properties.isUserError",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, estimatedCompletionTime: {
                serializedName: "properties.estimatedCompletionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, isCancellable: {
                serializedName: "properties.isCancellable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const DatabaseUsage = {
    type: {
        name: "Composite",
        className: "DatabaseUsage",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, currentValue: {
                serializedName: "properties.currentValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, limit: {
                serializedName: "properties.limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, unit: {
                serializedName: "properties.unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const LedgerDigestUploads = {
    type: {
        name: "Composite",
        className: "LedgerDigestUploads",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { digestStorageEndpoint: {
                serializedName: "properties.digestStorageEndpoint",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            } })
    }
};
const OutboundFirewallRule = {
    type: {
        name: "Composite",
        className: "OutboundFirewallRule",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ReplicationLink = {
    type: {
        name: "Composite",
        className: "ReplicationLink",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { partnerServer: {
                serializedName: "properties.partnerServer",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, partnerDatabase: {
                serializedName: "properties.partnerDatabase",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, partnerLocation: {
                serializedName: "properties.partnerLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, role: {
                serializedName: "properties.role",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Primary",
                        "Secondary",
                        "NonReadableSecondary",
                        "Source",
                        "Copy"
                    ]
                }
            }, partnerRole: {
                serializedName: "properties.partnerRole",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Primary",
                        "Secondary",
                        "NonReadableSecondary",
                        "Source",
                        "Copy"
                    ]
                }
            }, replicationMode: {
                serializedName: "properties.replicationMode",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, percentComplete: {
                serializedName: "properties.percentComplete",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, replicationState: {
                serializedName: "properties.replicationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, isTerminationAllowed: {
                serializedName: "properties.isTerminationAllowed",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, linkType: {
                serializedName: "properties.linkType",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ImportExportOperationResult = {
    type: {
        name: "Composite",
        className: "ImportExportOperationResult",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { requestId: {
                serializedName: "properties.requestId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }, requestType: {
                serializedName: "properties.requestType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, queuedTime: {
                serializedName: "properties.queuedTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, lastModifiedTime: {
                serializedName: "properties.lastModifiedTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, blobUri: {
                serializedName: "properties.blobUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serverName: {
                serializedName: "properties.serverName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, databaseName: {
                serializedName: "properties.databaseName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorMessage: {
                serializedName: "properties.errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnectionRequestStatus"
                        }
                    }
                }
            } })
    }
};
const LongTermRetentionBackupOperationResult = {
    type: {
        name: "Composite",
        className: "LongTermRetentionBackupOperationResult",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { requestId: {
                serializedName: "properties.requestId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }, operationType: {
                serializedName: "properties.operationType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, fromBackupResourceId: {
                serializedName: "properties.fromBackupResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, toBackupResourceId: {
                serializedName: "properties.toBackupResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, targetBackupStorageRedundancy: {
                serializedName: "properties.targetBackupStorageRedundancy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, message: {
                serializedName: "properties.message",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const LongTermRetentionBackup = {
    type: {
        name: "Composite",
        className: "LongTermRetentionBackup",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { serverName: {
                serializedName: "properties.serverName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serverCreateTime: {
                serializedName: "properties.serverCreateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, databaseName: {
                serializedName: "properties.databaseName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, databaseDeletionTime: {
                serializedName: "properties.databaseDeletionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, backupTime: {
                serializedName: "properties.backupTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, backupExpirationTime: {
                serializedName: "properties.backupExpirationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, backupStorageRedundancy: {
                serializedName: "properties.backupStorageRedundancy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requestedBackupStorageRedundancy: {
                serializedName: "properties.requestedBackupStorageRedundancy",
                type: {
                    name: "String"
                }
            } })
    }
};
const ManagedInstanceLongTermRetentionBackup = {
    type: {
        name: "Composite",
        className: "ManagedInstanceLongTermRetentionBackup",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { managedInstanceName: {
                serializedName: "properties.managedInstanceName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, managedInstanceCreateTime: {
                serializedName: "properties.managedInstanceCreateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, databaseName: {
                serializedName: "properties.databaseName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, databaseDeletionTime: {
                serializedName: "properties.databaseDeletionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, backupTime: {
                serializedName: "properties.backupTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, backupExpirationTime: {
                serializedName: "properties.backupExpirationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, backupStorageRedundancy: {
                serializedName: "properties.backupStorageRedundancy",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const RestorableDroppedDatabase = {
    type: {
        name: "Composite",
        className: "RestorableDroppedDatabase",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, databaseName: {
                serializedName: "properties.databaseName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, maxSizeBytes: {
                serializedName: "properties.maxSizeBytes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, deletionDate: {
                serializedName: "properties.deletionDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, earliestRestoreDate: {
                serializedName: "properties.earliestRestoreDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, backupStorageRedundancy: {
                serializedName: "properties.backupStorageRedundancy",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ServerConnectionPolicy = {
    type: {
        name: "Composite",
        className: "ServerConnectionPolicy",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, connectionType: {
                serializedName: "properties.connectionType",
                type: {
                    name: "String"
                }
            } })
    }
};
const ElasticPool = {
    type: {
        name: "Composite",
        className: "ElasticPool",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, maxSizeBytes: {
                serializedName: "properties.maxSizeBytes",
                type: {
                    name: "Number"
                }
            }, perDatabaseSettings: {
                serializedName: "properties.perDatabaseSettings",
                type: {
                    name: "Composite",
                    className: "ElasticPoolPerDatabaseSettings"
                }
            }, zoneRedundant: {
                serializedName: "properties.zoneRedundant",
                type: {
                    name: "Boolean"
                }
            }, licenseType: {
                serializedName: "properties.licenseType",
                type: {
                    name: "String"
                }
            }, maintenanceConfigurationId: {
                serializedName: "properties.maintenanceConfigurationId",
                type: {
                    name: "String"
                }
            } })
    }
};
const InstancePool = {
    type: {
        name: "Composite",
        className: "InstancePool",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, subnetId: {
                serializedName: "properties.subnetId",
                type: {
                    name: "String"
                }
            }, vCores: {
                serializedName: "properties.vCores",
                type: {
                    name: "Number"
                }
            }, licenseType: {
                serializedName: "properties.licenseType",
                type: {
                    name: "String"
                }
            } })
    }
};
const JobAgent = {
    type: {
        name: "Composite",
        className: "JobAgent",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, databaseId: {
                serializedName: "properties.databaseId",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ManagedDatabase = {
    type: {
        name: "Composite",
        className: "ManagedDatabase",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { collation: {
                serializedName: "properties.collation",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, earliestRestorePoint: {
                serializedName: "properties.earliestRestorePoint",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, restorePointInTime: {
                serializedName: "properties.restorePointInTime",
                type: {
                    name: "DateTime"
                }
            }, defaultSecondaryLocation: {
                serializedName: "properties.defaultSecondaryLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, catalogCollation: {
                serializedName: "properties.catalogCollation",
                type: {
                    name: "String"
                }
            }, createMode: {
                serializedName: "properties.createMode",
                type: {
                    name: "String"
                }
            }, storageContainerUri: {
                serializedName: "properties.storageContainerUri",
                type: {
                    name: "String"
                }
            }, sourceDatabaseId: {
                serializedName: "properties.sourceDatabaseId",
                type: {
                    name: "String"
                }
            }, restorableDroppedDatabaseId: {
                serializedName: "properties.restorableDroppedDatabaseId",
                type: {
                    name: "String"
                }
            }, storageContainerSasToken: {
                serializedName: "properties.storageContainerSasToken",
                type: {
                    name: "String"
                }
            }, failoverGroupId: {
                serializedName: "properties.failoverGroupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, recoverableDatabaseId: {
                serializedName: "properties.recoverableDatabaseId",
                type: {
                    name: "String"
                }
            }, longTermRetentionBackupResourceId: {
                serializedName: "properties.longTermRetentionBackupResourceId",
                type: {
                    name: "String"
                }
            }, autoCompleteRestore: {
                serializedName: "properties.autoCompleteRestore",
                type: {
                    name: "Boolean"
                }
            }, lastBackupName: {
                serializedName: "properties.lastBackupName",
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualCluster = {
    type: {
        name: "Composite",
        className: "VirtualCluster",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { subnetId: {
                serializedName: "properties.subnetId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, family: {
                serializedName: "properties.family",
                type: {
                    name: "String"
                }
            }, childResources: {
                serializedName: "properties.childResources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, maintenanceConfigurationId: {
                serializedName: "properties.maintenanceConfigurationId",
                type: {
                    name: "String"
                }
            } })
    }
};
const Server = {
    type: {
        name: "Composite",
        className: "Server",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ResourceIdentity"
                }
            }, kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, administratorLogin: {
                serializedName: "properties.administratorLogin",
                type: {
                    name: "String"
                }
            }, administratorLoginPassword: {
                serializedName: "properties.administratorLoginPassword",
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "properties.version",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, fullyQualifiedDomainName: {
                serializedName: "properties.fullyQualifiedDomainName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerPrivateEndpointConnection"
                        }
                    }
                }
            }, minimalTlsVersion: {
                serializedName: "properties.minimalTlsVersion",
                type: {
                    name: "String"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, workspaceFeature: {
                serializedName: "properties.workspaceFeature",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, primaryUserAssignedIdentityId: {
                serializedName: "properties.primaryUserAssignedIdentityId",
                type: {
                    name: "String"
                }
            }, federatedClientId: {
                serializedName: "properties.federatedClientId",
                type: {
                    name: "Uuid"
                }
            }, keyId: {
                serializedName: "properties.keyId",
                type: {
                    name: "String"
                }
            }, administrators: {
                serializedName: "properties.administrators",
                type: {
                    name: "Composite",
                    className: "ServerExternalAdministrator"
                }
            }, restrictOutboundNetworkAccess: {
                serializedName: "properties.restrictOutboundNetworkAccess",
                type: {
                    name: "String"
                }
            } })
    }
};
const Database = {
    type: {
        name: "Composite",
        className: "Database",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, managedBy: {
                serializedName: "managedBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "DatabaseIdentity"
                }
            }, createMode: {
                serializedName: "properties.createMode",
                type: {
                    name: "String"
                }
            }, collation: {
                serializedName: "properties.collation",
                type: {
                    name: "String"
                }
            }, maxSizeBytes: {
                serializedName: "properties.maxSizeBytes",
                type: {
                    name: "Number"
                }
            }, sampleName: {
                serializedName: "properties.sampleName",
                type: {
                    name: "String"
                }
            }, elasticPoolId: {
                serializedName: "properties.elasticPoolId",
                type: {
                    name: "String"
                }
            }, sourceDatabaseId: {
                serializedName: "properties.sourceDatabaseId",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, databaseId: {
                serializedName: "properties.databaseId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }, creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, currentServiceObjectiveName: {
                serializedName: "properties.currentServiceObjectiveName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requestedServiceObjectiveName: {
                serializedName: "properties.requestedServiceObjectiveName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, defaultSecondaryLocation: {
                serializedName: "properties.defaultSecondaryLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, failoverGroupId: {
                serializedName: "properties.failoverGroupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, restorePointInTime: {
                serializedName: "properties.restorePointInTime",
                type: {
                    name: "DateTime"
                }
            }, sourceDatabaseDeletionDate: {
                serializedName: "properties.sourceDatabaseDeletionDate",
                type: {
                    name: "DateTime"
                }
            }, recoveryServicesRecoveryPointId: {
                serializedName: "properties.recoveryServicesRecoveryPointId",
                type: {
                    name: "String"
                }
            }, longTermRetentionBackupResourceId: {
                serializedName: "properties.longTermRetentionBackupResourceId",
                type: {
                    name: "String"
                }
            }, recoverableDatabaseId: {
                serializedName: "properties.recoverableDatabaseId",
                type: {
                    name: "String"
                }
            }, restorableDroppedDatabaseId: {
                serializedName: "properties.restorableDroppedDatabaseId",
                type: {
                    name: "String"
                }
            }, catalogCollation: {
                serializedName: "properties.catalogCollation",
                type: {
                    name: "String"
                }
            }, zoneRedundant: {
                serializedName: "properties.zoneRedundant",
                type: {
                    name: "Boolean"
                }
            }, licenseType: {
                serializedName: "properties.licenseType",
                type: {
                    name: "String"
                }
            }, maxLogSizeBytes: {
                serializedName: "properties.maxLogSizeBytes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, earliestRestoreDate: {
                serializedName: "properties.earliestRestoreDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, readScale: {
                serializedName: "properties.readScale",
                type: {
                    name: "String"
                }
            }, highAvailabilityReplicaCount: {
                serializedName: "properties.highAvailabilityReplicaCount",
                type: {
                    name: "Number"
                }
            }, secondaryType: {
                serializedName: "properties.secondaryType",
                type: {
                    name: "String"
                }
            }, currentSku: {
                serializedName: "properties.currentSku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, autoPauseDelay: {
                serializedName: "properties.autoPauseDelay",
                type: {
                    name: "Number"
                }
            }, currentBackupStorageRedundancy: {
                serializedName: "properties.currentBackupStorageRedundancy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requestedBackupStorageRedundancy: {
                serializedName: "properties.requestedBackupStorageRedundancy",
                type: {
                    name: "String"
                }
            }, minCapacity: {
                serializedName: "properties.minCapacity",
                type: {
                    name: "Number"
                }
            }, pausedDate: {
                serializedName: "properties.pausedDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, resumedDate: {
                serializedName: "properties.resumedDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, maintenanceConfigurationId: {
                serializedName: "properties.maintenanceConfigurationId",
                type: {
                    name: "String"
                }
            }, isLedgerOn: {
                serializedName: "properties.isLedgerOn",
                type: {
                    name: "Boolean"
                }
            }, isInfraEncryptionEnabled: {
                serializedName: "properties.isInfraEncryptionEnabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, federatedClientId: {
                serializedName: "properties.federatedClientId",
                type: {
                    name: "Uuid"
                }
            }, primaryDelegatedIdentityClientId: {
                serializedName: "properties.primaryDelegatedIdentityClientId",
                type: {
                    name: "Uuid"
                }
            } })
    }
};
const ManagedInstance = {
    type: {
        name: "Composite",
        className: "ManagedInstance",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ResourceIdentity"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, managedInstanceCreateMode: {
                serializedName: "properties.managedInstanceCreateMode",
                type: {
                    name: "String"
                }
            }, fullyQualifiedDomainName: {
                serializedName: "properties.fullyQualifiedDomainName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, administratorLogin: {
                serializedName: "properties.administratorLogin",
                type: {
                    name: "String"
                }
            }, administratorLoginPassword: {
                serializedName: "properties.administratorLoginPassword",
                type: {
                    name: "String"
                }
            }, subnetId: {
                serializedName: "properties.subnetId",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, licenseType: {
                serializedName: "properties.licenseType",
                type: {
                    name: "String"
                }
            }, vCores: {
                serializedName: "properties.vCores",
                type: {
                    name: "Number"
                }
            }, storageSizeInGB: {
                serializedName: "properties.storageSizeInGB",
                type: {
                    name: "Number"
                }
            }, collation: {
                serializedName: "properties.collation",
                type: {
                    name: "String"
                }
            }, dnsZone: {
                serializedName: "properties.dnsZone",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, dnsZonePartner: {
                serializedName: "properties.dnsZonePartner",
                type: {
                    name: "String"
                }
            }, publicDataEndpointEnabled: {
                serializedName: "properties.publicDataEndpointEnabled",
                type: {
                    name: "Boolean"
                }
            }, sourceManagedInstanceId: {
                serializedName: "properties.sourceManagedInstanceId",
                type: {
                    name: "String"
                }
            }, restorePointInTime: {
                serializedName: "properties.restorePointInTime",
                type: {
                    name: "DateTime"
                }
            }, proxyOverride: {
                serializedName: "properties.proxyOverride",
                type: {
                    name: "String"
                }
            }, timezoneId: {
                serializedName: "properties.timezoneId",
                type: {
                    name: "String"
                }
            }, instancePoolId: {
                serializedName: "properties.instancePoolId",
                type: {
                    name: "String"
                }
            }, maintenanceConfigurationId: {
                serializedName: "properties.maintenanceConfigurationId",
                type: {
                    name: "String"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedInstancePecProperty"
                        }
                    }
                }
            }, minimalTlsVersion: {
                serializedName: "properties.minimalTlsVersion",
                type: {
                    name: "String"
                }
            }, currentBackupStorageRedundancy: {
                serializedName: "properties.currentBackupStorageRedundancy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requestedBackupStorageRedundancy: {
                serializedName: "properties.requestedBackupStorageRedundancy",
                type: {
                    name: "String"
                }
            }, zoneRedundant: {
                serializedName: "properties.zoneRedundant",
                type: {
                    name: "Boolean"
                }
            }, primaryUserAssignedIdentityId: {
                serializedName: "properties.primaryUserAssignedIdentityId",
                type: {
                    name: "String"
                }
            }, keyId: {
                serializedName: "properties.keyId",
                type: {
                    name: "String"
                }
            }, administrators: {
                serializedName: "properties.administrators",
                type: {
                    name: "Composite",
                    className: "ManagedInstanceExternalAdministrator"
                }
            }, servicePrincipal: {
                serializedName: "properties.servicePrincipal",
                type: {
                    name: "Composite",
                    className: "ServicePrincipal"
                }
            } })
    }
};
const RestorableDroppedManagedDatabase = {
    type: {
        name: "Composite",
        className: "RestorableDroppedManagedDatabase",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { databaseName: {
                serializedName: "properties.databaseName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, deletionDate: {
                serializedName: "properties.deletionDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, earliestRestoreDate: {
                serializedName: "properties.earliestRestoreDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const FirewallRule = {
    type: {
        name: "Composite",
        className: "FirewallRule",
        modelProperties: Object.assign(Object.assign({}, ProxyResourceWithWritableName.type.modelProperties), { startIpAddress: {
                serializedName: "properties.startIpAddress",
                type: {
                    name: "String"
                }
            }, endIpAddress: {
                serializedName: "properties.endIpAddress",
                type: {
                    name: "String"
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Resource: Resource,
    RecoverableDatabaseListResult: RecoverableDatabaseListResult,
    DataMaskingRuleListResult: DataMaskingRuleListResult,
    GeoBackupPolicyListResult: GeoBackupPolicyListResult,
    MetricListResult: MetricListResult,
    Metric: Metric,
    MetricName: MetricName,
    MetricValue: MetricValue,
    MetricDefinitionListResult: MetricDefinitionListResult,
    MetricDefinition: MetricDefinition,
    MetricAvailability: MetricAvailability,
    UnlinkParameters: UnlinkParameters,
    ServerCommunicationLinkListResult: ServerCommunicationLinkListResult,
    ServiceObjectiveListResult: ServiceObjectiveListResult,
    ElasticPoolActivityListResult: ElasticPoolActivityListResult,
    ElasticPoolDatabaseActivityListResult: ElasticPoolDatabaseActivityListResult,
    ServerUsageListResult: ServerUsageListResult,
    ServerUsage: ServerUsage,
    ExtendedDatabaseBlobAuditingPolicyListResult: ExtendedDatabaseBlobAuditingPolicyListResult,
    ExtendedServerBlobAuditingPolicyListResult: ExtendedServerBlobAuditingPolicyListResult,
    ServerBlobAuditingPolicyListResult: ServerBlobAuditingPolicyListResult,
    DatabaseBlobAuditingPolicyListResult: DatabaseBlobAuditingPolicyListResult,
    RecommendedActionStateInfo: RecommendedActionStateInfo,
    RecommendedActionImplementationInfo: RecommendedActionImplementationInfo,
    RecommendedActionErrorInfo: RecommendedActionErrorInfo,
    RecommendedActionImpactRecord: RecommendedActionImpactRecord,
    RecommendedActionMetricInfo: RecommendedActionMetricInfo,
    AutomaticTuningOptions: AutomaticTuningOptions,
    DatabaseColumnListResult: DatabaseColumnListResult,
    DatabaseSchemaListResult: DatabaseSchemaListResult,
    SystemData: SystemData,
    DatabaseSecurityAlertListResult: DatabaseSecurityAlertListResult,
    DatabaseTableListResult: DatabaseTableListResult,
    DatabaseVulnerabilityAssessmentRuleBaselineItem: DatabaseVulnerabilityAssessmentRuleBaselineItem,
    VulnerabilityAssessmentRecurringScansProperties: VulnerabilityAssessmentRecurringScansProperties,
    DatabaseVulnerabilityAssessmentListResult: DatabaseVulnerabilityAssessmentListResult,
    VulnerabilityAssessmentScanRecordListResult: VulnerabilityAssessmentScanRecordListResult,
    VulnerabilityAssessmentScanError: VulnerabilityAssessmentScanError,
    DataWarehouseUserActivitiesListResult: DataWarehouseUserActivitiesListResult,
    DeletedServerListResult: DeletedServerListResult,
    ElasticPoolOperationListResult: ElasticPoolOperationListResult,
    ElasticPoolListResult: ElasticPoolListResult,
    Sku: Sku,
    ElasticPoolPerDatabaseSettings: ElasticPoolPerDatabaseSettings,
    ElasticPoolUpdate: ElasticPoolUpdate,
    EncryptionProtectorListResult: EncryptionProtectorListResult,
    FailoverGroupReadWriteEndpoint: FailoverGroupReadWriteEndpoint,
    FailoverGroupReadOnlyEndpoint: FailoverGroupReadOnlyEndpoint,
    PartnerInfo: PartnerInfo,
    FailoverGroupUpdate: FailoverGroupUpdate,
    FailoverGroupListResult: FailoverGroupListResult,
    ResourceWithWritableName: ResourceWithWritableName,
    FirewallRuleListResult: FirewallRuleListResult,
    FirewallRuleList: FirewallRuleList,
    InstanceFailoverGroupReadWriteEndpoint: InstanceFailoverGroupReadWriteEndpoint,
    InstanceFailoverGroupReadOnlyEndpoint: InstanceFailoverGroupReadOnlyEndpoint,
    PartnerRegionInfo: PartnerRegionInfo,
    ManagedInstancePairInfo: ManagedInstancePairInfo,
    InstanceFailoverGroupListResult: InstanceFailoverGroupListResult,
    InstancePoolUpdate: InstancePoolUpdate,
    InstancePoolListResult: InstancePoolListResult,
    JobAgentListResult: JobAgentListResult,
    JobAgentUpdate: JobAgentUpdate,
    JobCredentialListResult: JobCredentialListResult,
    JobExecutionListResult: JobExecutionListResult,
    JobExecutionTarget: JobExecutionTarget,
    JobListResult: JobListResult,
    JobSchedule: JobSchedule,
    JobStepListResult: JobStepListResult,
    JobStepAction: JobStepAction,
    JobStepOutput: JobStepOutput,
    JobStepExecutionOptions: JobStepExecutionOptions,
    JobTargetGroupListResult: JobTargetGroupListResult,
    JobTarget: JobTarget,
    JobVersionListResult: JobVersionListResult,
    LocationCapabilities: LocationCapabilities,
    ServerVersionCapability: ServerVersionCapability,
    EditionCapability: EditionCapability,
    ServiceObjectiveCapability: ServiceObjectiveCapability,
    MaxSizeRangeCapability: MaxSizeRangeCapability,
    MaxSizeCapability: MaxSizeCapability,
    LogSizeCapability: LogSizeCapability,
    PerformanceLevelCapability: PerformanceLevelCapability,
    LicenseTypeCapability: LicenseTypeCapability,
    AutoPauseDelayTimeRange: AutoPauseDelayTimeRange,
    MinCapacityCapability: MinCapacityCapability,
    MaintenanceConfigurationCapability: MaintenanceConfigurationCapability,
    ReadScaleCapability: ReadScaleCapability,
    StorageCapability: StorageCapability,
    ElasticPoolEditionCapability: ElasticPoolEditionCapability,
    ElasticPoolPerformanceLevelCapability: ElasticPoolPerformanceLevelCapability,
    ElasticPoolPerDatabaseMaxPerformanceLevelCapability: ElasticPoolPerDatabaseMaxPerformanceLevelCapability,
    ElasticPoolPerDatabaseMinPerformanceLevelCapability: ElasticPoolPerDatabaseMinPerformanceLevelCapability,
    ManagedInstanceVersionCapability: ManagedInstanceVersionCapability,
    ManagedInstanceEditionCapability: ManagedInstanceEditionCapability,
    ManagedInstanceFamilyCapability: ManagedInstanceFamilyCapability,
    ManagedInstanceVcoresCapability: ManagedInstanceVcoresCapability,
    ManagedInstanceMaintenanceConfigurationCapability: ManagedInstanceMaintenanceConfigurationCapability,
    InstancePoolEditionCapability: InstancePoolEditionCapability,
    InstancePoolFamilyCapability: InstancePoolFamilyCapability,
    InstancePoolVcoresCapability: InstancePoolVcoresCapability,
    LongTermRetentionPolicyListResult: LongTermRetentionPolicyListResult,
    MaintenanceWindowTimeRange: MaintenanceWindowTimeRange,
    ManagedBackupShortTermRetentionPolicyListResult: ManagedBackupShortTermRetentionPolicyListResult,
    ManagedInstanceQueryStatistics: ManagedInstanceQueryStatistics,
    QueryStatisticsProperties: QueryStatisticsProperties,
    QueryMetricInterval: QueryMetricInterval,
    QueryMetricProperties: QueryMetricProperties,
    ManagedDatabaseListResult: ManagedDatabaseListResult,
    ManagedDatabaseUpdate: ManagedDatabaseUpdate,
    CompleteDatabaseRestoreDefinition: CompleteDatabaseRestoreDefinition,
    ManagedDatabaseSecurityAlertPolicyListResult: ManagedDatabaseSecurityAlertPolicyListResult,
    SecurityEventCollection: SecurityEventCollection,
    SecurityEventSqlInjectionAdditionalProperties: SecurityEventSqlInjectionAdditionalProperties,
    SensitivityLabelListResult: SensitivityLabelListResult,
    SensitivityLabelUpdateList: SensitivityLabelUpdateList,
    RecommendedSensitivityLabelUpdateList: RecommendedSensitivityLabelUpdateList,
    ManagedTransparentDataEncryptionListResult: ManagedTransparentDataEncryptionListResult,
    ManagedInstanceAdministratorListResult: ManagedInstanceAdministratorListResult,
    ManagedInstanceAzureADOnlyAuthListResult: ManagedInstanceAzureADOnlyAuthListResult,
    ManagedInstanceEncryptionProtectorListResult: ManagedInstanceEncryptionProtectorListResult,
    ManagedInstanceKeyListResult: ManagedInstanceKeyListResult,
    ManagedInstanceLongTermRetentionPolicyListResult: ManagedInstanceLongTermRetentionPolicyListResult,
    ManagedInstanceOperationListResult: ManagedInstanceOperationListResult,
    ManagedInstanceOperationParametersPair: ManagedInstanceOperationParametersPair,
    UpsertManagedServerOperationParameters: UpsertManagedServerOperationParameters,
    ManagedInstanceOperationSteps: ManagedInstanceOperationSteps,
    UpsertManagedServerOperationStep: UpsertManagedServerOperationStep,
    ManagedInstancePrivateEndpointConnectionProperties: ManagedInstancePrivateEndpointConnectionProperties,
    ManagedInstancePrivateEndpointProperty: ManagedInstancePrivateEndpointProperty,
    ManagedInstancePrivateLinkServiceConnectionStateProperty: ManagedInstancePrivateLinkServiceConnectionStateProperty,
    ManagedInstancePrivateEndpointConnectionListResult: ManagedInstancePrivateEndpointConnectionListResult,
    ManagedInstancePrivateLinkListResult: ManagedInstancePrivateLinkListResult,
    ManagedInstancePrivateLinkProperties: ManagedInstancePrivateLinkProperties,
    ManagedInstanceVulnerabilityAssessmentListResult: ManagedInstanceVulnerabilityAssessmentListResult,
    ManagedServerSecurityAlertPolicyListResult: ManagedServerSecurityAlertPolicyListResult,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    OperationsHealthListResult: OperationsHealthListResult,
    PrivateEndpointConnectionProperties: PrivateEndpointConnectionProperties,
    PrivateEndpointProperty: PrivateEndpointProperty,
    PrivateLinkServiceConnectionStateProperty: PrivateLinkServiceConnectionStateProperty,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    PrivateLinkResourceListResult: PrivateLinkResourceListResult,
    PrivateLinkResourceProperties: PrivateLinkResourceProperties,
    RecoverableManagedDatabaseListResult: RecoverableManagedDatabaseListResult,
    RestorePointListResult: RestorePointListResult,
    CreateDatabaseRestorePointDefinition: CreateDatabaseRestorePointDefinition,
    AutomaticTuningServerOptions: AutomaticTuningServerOptions,
    AdministratorListResult: AdministratorListResult,
    AzureADOnlyAuthListResult: AzureADOnlyAuthListResult,
    ServerDevOpsAuditSettingsListResult: ServerDevOpsAuditSettingsListResult,
    ServerDnsAliasListResult: ServerDnsAliasListResult,
    ServerDnsAliasAcquisition: ServerDnsAliasAcquisition,
    ServerKeyListResult: ServerKeyListResult,
    ServerOperationListResult: ServerOperationListResult,
    LogicalServerSecurityAlertPolicyListResult: LogicalServerSecurityAlertPolicyListResult,
    ServerInfo: ServerInfo,
    ServerTrustGroupListResult: ServerTrustGroupListResult,
    ServerVulnerabilityAssessmentListResult: ServerVulnerabilityAssessmentListResult,
    SubscriptionUsageListResult: SubscriptionUsageListResult,
    SyncAgentListResult: SyncAgentListResult,
    SyncAgentKeyProperties: SyncAgentKeyProperties,
    SyncAgentLinkedDatabaseListResult: SyncAgentLinkedDatabaseListResult,
    SyncDatabaseIdListResult: SyncDatabaseIdListResult,
    SyncDatabaseIdProperties: SyncDatabaseIdProperties,
    SyncFullSchemaPropertiesListResult: SyncFullSchemaPropertiesListResult,
    SyncFullSchemaProperties: SyncFullSchemaProperties,
    SyncFullSchemaTable: SyncFullSchemaTable,
    SyncFullSchemaTableColumn: SyncFullSchemaTableColumn,
    SyncGroupLogListResult: SyncGroupLogListResult,
    SyncGroupLogProperties: SyncGroupLogProperties,
    SyncGroupSchema: SyncGroupSchema,
    SyncGroupSchemaTable: SyncGroupSchemaTable,
    SyncGroupSchemaTableColumn: SyncGroupSchemaTableColumn,
    SyncGroupListResult: SyncGroupListResult,
    SyncMemberListResult: SyncMemberListResult,
    TimeZoneListResult: TimeZoneListResult,
    VirtualClusterListResult: VirtualClusterListResult,
    VirtualClusterUpdate: VirtualClusterUpdate,
    VirtualNetworkRuleListResult: VirtualNetworkRuleListResult,
    WorkloadClassifierListResult: WorkloadClassifierListResult,
    WorkloadGroupListResult: WorkloadGroupListResult,
    LogicalDatabaseTransparentDataEncryptionListResult: LogicalDatabaseTransparentDataEncryptionListResult,
    BackupShortTermRetentionPolicyListResult: BackupShortTermRetentionPolicyListResult,
    ImportExportExtensionsOperationListResult: ImportExportExtensionsOperationListResult,
    DatabaseOperationListResult: DatabaseOperationListResult,
    DatabaseUsageListResult: DatabaseUsageListResult,
    LedgerDigestUploadsListResult: LedgerDigestUploadsListResult,
    OutboundFirewallRuleListResult: OutboundFirewallRuleListResult,
    ReplicationLinkListResult: ReplicationLinkListResult,
    ServerListResult: ServerListResult,
    ResourceIdentity: ResourceIdentity,
    UserIdentity: UserIdentity,
    ServerPrivateEndpointConnection: ServerPrivateEndpointConnection,
    ServerExternalAdministrator: ServerExternalAdministrator,
    ServerUpdate: ServerUpdate,
    ImportNewDatabaseDefinition: ImportNewDatabaseDefinition,
    NetworkIsolationSettings: NetworkIsolationSettings,
    PrivateEndpointConnectionRequestStatus: PrivateEndpointConnectionRequestStatus,
    CheckNameAvailabilityRequest: CheckNameAvailabilityRequest,
    CheckNameAvailabilityResponse: CheckNameAvailabilityResponse,
    UsageListResult: UsageListResult,
    Usage: Usage,
    Name: Name,
    DatabaseListResult: DatabaseListResult,
    DatabaseIdentity: DatabaseIdentity,
    DatabaseUserIdentity: DatabaseUserIdentity,
    Delegation: Delegation,
    DatabaseUpdate: DatabaseUpdate,
    ResourceMoveDefinition: ResourceMoveDefinition,
    ImportExistingDatabaseDefinition: ImportExistingDatabaseDefinition,
    ExportDatabaseDefinition: ExportDatabaseDefinition,
    CopyLongTermRetentionBackupParameters: CopyLongTermRetentionBackupParameters,
    UpdateLongTermRetentionBackupParameters: UpdateLongTermRetentionBackupParameters,
    LongTermRetentionBackupListResult: LongTermRetentionBackupListResult,
    ManagedInstanceLongTermRetentionBackupListResult: ManagedInstanceLongTermRetentionBackupListResult,
    ManagedInstanceListResult: ManagedInstanceListResult,
    ManagedInstancePecProperty: ManagedInstancePecProperty,
    ManagedInstanceExternalAdministrator: ManagedInstanceExternalAdministrator,
    ServicePrincipal: ServicePrincipal,
    ManagedInstanceUpdate: ManagedInstanceUpdate,
    TopQueriesListResult: TopQueriesListResult,
    TopQueries: TopQueries,
    RestorableDroppedDatabaseListResult: RestorableDroppedDatabaseListResult,
    RestorableDroppedManagedDatabaseListResult: RestorableDroppedManagedDatabaseListResult,
    ServerConnectionPolicyListResult: ServerConnectionPolicyListResult,
    SloUsageMetric: SloUsageMetric,
    OperationImpact: OperationImpact,
    SecurityEventsFilterParameters: SecurityEventsFilterParameters,
    ProxyResource: ProxyResource,
    TrackedResource: TrackedResource,
    ProxyResourceWithWritableName: ProxyResourceWithWritableName,
    RecoverableDatabase: RecoverableDatabase,
    DataMaskingPolicy: DataMaskingPolicy,
    DataMaskingRule: DataMaskingRule,
    GeoBackupPolicy: GeoBackupPolicy,
    ServerCommunicationLink: ServerCommunicationLink,
    ServiceObjective: ServiceObjective,
    ElasticPoolActivity: ElasticPoolActivity,
    ElasticPoolDatabaseActivity: ElasticPoolDatabaseActivity,
    ExtendedDatabaseBlobAuditingPolicy: ExtendedDatabaseBlobAuditingPolicy,
    ExtendedServerBlobAuditingPolicy: ExtendedServerBlobAuditingPolicy,
    ServerBlobAuditingPolicy: ServerBlobAuditingPolicy,
    DatabaseBlobAuditingPolicy: DatabaseBlobAuditingPolicy,
    RecommendedAction: RecommendedAction,
    Advisor: Advisor,
    DatabaseAutomaticTuning: DatabaseAutomaticTuning,
    DatabaseColumn: DatabaseColumn,
    DatabaseSchema: DatabaseSchema,
    DatabaseSecurityAlertPolicy: DatabaseSecurityAlertPolicy,
    DatabaseTable: DatabaseTable,
    DatabaseVulnerabilityAssessmentRuleBaseline: DatabaseVulnerabilityAssessmentRuleBaseline,
    DatabaseVulnerabilityAssessment: DatabaseVulnerabilityAssessment,
    VulnerabilityAssessmentScanRecord: VulnerabilityAssessmentScanRecord,
    DatabaseVulnerabilityAssessmentScansExport: DatabaseVulnerabilityAssessmentScansExport,
    DataWarehouseUserActivities: DataWarehouseUserActivities,
    DeletedServer: DeletedServer,
    ElasticPoolOperation: ElasticPoolOperation,
    EncryptionProtector: EncryptionProtector,
    FailoverGroup: FailoverGroup,
    InstanceFailoverGroup: InstanceFailoverGroup,
    JobCredential: JobCredential,
    JobExecution: JobExecution,
    Job: Job,
    JobStep: JobStep,
    JobTargetGroup: JobTargetGroup,
    JobVersion: JobVersion,
    LongTermRetentionPolicy: LongTermRetentionPolicy,
    MaintenanceWindowOptions: MaintenanceWindowOptions,
    MaintenanceWindows: MaintenanceWindows,
    ManagedBackupShortTermRetentionPolicy: ManagedBackupShortTermRetentionPolicy,
    ManagedInstanceQuery: ManagedInstanceQuery,
    QueryStatistics: QueryStatistics,
    ManagedDatabaseRestoreDetailsResult: ManagedDatabaseRestoreDetailsResult,
    ManagedDatabaseSecurityAlertPolicy: ManagedDatabaseSecurityAlertPolicy,
    SecurityEvent: SecurityEvent,
    SensitivityLabel: SensitivityLabel,
    SensitivityLabelUpdate: SensitivityLabelUpdate,
    RecommendedSensitivityLabelUpdate: RecommendedSensitivityLabelUpdate,
    ManagedTransparentDataEncryption: ManagedTransparentDataEncryption,
    ManagedInstanceAdministrator: ManagedInstanceAdministrator,
    ManagedInstanceAzureADOnlyAuthentication: ManagedInstanceAzureADOnlyAuthentication,
    ManagedInstanceEncryptionProtector: ManagedInstanceEncryptionProtector,
    ManagedInstanceKey: ManagedInstanceKey,
    ManagedInstanceLongTermRetentionPolicy: ManagedInstanceLongTermRetentionPolicy,
    ManagedInstanceOperation: ManagedInstanceOperation,
    ManagedInstancePrivateEndpointConnection: ManagedInstancePrivateEndpointConnection,
    ManagedInstancePrivateLink: ManagedInstancePrivateLink,
    TdeCertificate: TdeCertificate,
    ManagedInstanceVulnerabilityAssessment: ManagedInstanceVulnerabilityAssessment,
    ManagedServerSecurityAlertPolicy: ManagedServerSecurityAlertPolicy,
    OperationsHealth: OperationsHealth,
    PrivateEndpointConnection: PrivateEndpointConnection,
    PrivateLinkResource: PrivateLinkResource,
    RecoverableManagedDatabase: RecoverableManagedDatabase,
    RestorePoint: RestorePoint,
    ServerAutomaticTuning: ServerAutomaticTuning,
    ServerAzureADAdministrator: ServerAzureADAdministrator,
    ServerAzureADOnlyAuthentication: ServerAzureADOnlyAuthentication,
    ServerDevOpsAuditingSettings: ServerDevOpsAuditingSettings,
    ServerDnsAlias: ServerDnsAlias,
    ServerKey: ServerKey,
    ServerOperation: ServerOperation,
    ServerSecurityAlertPolicy: ServerSecurityAlertPolicy,
    ServerTrustGroup: ServerTrustGroup,
    ServerVulnerabilityAssessment: ServerVulnerabilityAssessment,
    SqlAgentConfiguration: SqlAgentConfiguration,
    SubscriptionUsage: SubscriptionUsage,
    SyncAgent: SyncAgent,
    SyncAgentLinkedDatabase: SyncAgentLinkedDatabase,
    SyncGroup: SyncGroup,
    SyncMember: SyncMember,
    TimeZone: TimeZone,
    UpdateManagedInstanceDnsServersOperation: UpdateManagedInstanceDnsServersOperation,
    VirtualNetworkRule: VirtualNetworkRule,
    WorkloadClassifier: WorkloadClassifier,
    WorkloadGroup: WorkloadGroup,
    LogicalDatabaseTransparentDataEncryption: LogicalDatabaseTransparentDataEncryption,
    BackupShortTermRetentionPolicy: BackupShortTermRetentionPolicy,
    DatabaseExtensions: DatabaseExtensions,
    ImportExportExtensionsOperationResult: ImportExportExtensionsOperationResult,
    DatabaseOperation: DatabaseOperation,
    DatabaseUsage: DatabaseUsage,
    LedgerDigestUploads: LedgerDigestUploads,
    OutboundFirewallRule: OutboundFirewallRule,
    ReplicationLink: ReplicationLink,
    ImportExportOperationResult: ImportExportOperationResult,
    LongTermRetentionBackupOperationResult: LongTermRetentionBackupOperationResult,
    LongTermRetentionBackup: LongTermRetentionBackup,
    ManagedInstanceLongTermRetentionBackup: ManagedInstanceLongTermRetentionBackup,
    RestorableDroppedDatabase: RestorableDroppedDatabase,
    ServerConnectionPolicy: ServerConnectionPolicy,
    ElasticPool: ElasticPool,
    InstancePool: InstancePool,
    JobAgent: JobAgent,
    ManagedDatabase: ManagedDatabase,
    VirtualCluster: VirtualCluster,
    Server: Server,
    Database: Database,
    ManagedInstance: ManagedInstance,
    RestorableDroppedManagedDatabase: RestorableDroppedManagedDatabase,
    FirewallRule: FirewallRule
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2014-04-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const serverName = {
    parameterPath: "serverName",
    mapper: {
        serializedName: "serverName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const databaseName = {
    parameterPath: "databaseName",
    mapper: {
        serializedName: "databaseName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: DataMaskingPolicy
};
const dataMaskingPolicyName = {
    parameterPath: "dataMaskingPolicyName",
    mapper: {
        defaultValue: "Default",
        isConstant: true,
        serializedName: "dataMaskingPolicyName",
        type: {
            name: "String"
        }
    }
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: DataMaskingRule
};
const dataMaskingRuleName = {
    parameterPath: "dataMaskingRuleName",
    mapper: {
        serializedName: "dataMaskingRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: GeoBackupPolicy
};
const geoBackupPolicyName = {
    parameterPath: "geoBackupPolicyName",
    mapper: {
        serializedName: "geoBackupPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const filter = {
    parameterPath: "filter",
    mapper: {
        serializedName: "$filter",
        required: true,
        type: {
            name: "String"
        }
    }
};
const skipToken = {
    parameterPath: ["options", "skipToken"],
    mapper: {
        serializedName: "$skipToken",
        type: {
            name: "String"
        }
    }
};
const apiVersion1 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-05-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: Database
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: DatabaseUpdate
};
const elasticPoolName = {
    parameterPath: "elasticPoolName",
    mapper: {
        serializedName: "elasticPoolName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const replicaType = {
    parameterPath: ["options", "replicaType"],
    mapper: {
        serializedName: "replicaType",
        type: {
            name: "String"
        }
    }
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: ResourceMoveDefinition
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: ImportExistingDatabaseDefinition
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: ExportDatabaseDefinition
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const skip = {
    parameterPath: ["options", "skip"],
    mapper: {
        serializedName: "$skip",
        type: {
            name: "Number"
        }
    }
};
const apiVersion2 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2020-11-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const parameters8 = {
    parameterPath: "parameters",
    mapper: ElasticPool
};
const parameters9 = {
    parameterPath: "parameters",
    mapper: ElasticPoolUpdate
};
const linkId = {
    parameterPath: "linkId",
    mapper: {
        serializedName: "linkId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters10 = {
    parameterPath: "parameters",
    mapper: UnlinkParameters
};
const apiVersion3 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-02-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const communicationLinkName = {
    parameterPath: "communicationLinkName",
    mapper: {
        serializedName: "communicationLinkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters11 = {
    parameterPath: "parameters",
    mapper: ServerCommunicationLink
};
const serviceObjectiveName = {
    parameterPath: "serviceObjectiveName",
    mapper: {
        serializedName: "serviceObjectiveName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const blobAuditingPolicyName = {
    parameterPath: "blobAuditingPolicyName",
    mapper: {
        defaultValue: "default",
        isConstant: true,
        serializedName: "blobAuditingPolicyName",
        type: {
            name: "String"
        }
    }
};
const parameters12 = {
    parameterPath: "parameters",
    mapper: ExtendedDatabaseBlobAuditingPolicy
};
const parameters13 = {
    parameterPath: "parameters",
    mapper: ExtendedServerBlobAuditingPolicy
};
const parameters14 = {
    parameterPath: "parameters",
    mapper: ServerBlobAuditingPolicy
};
const parameters15 = {
    parameterPath: "parameters",
    mapper: DatabaseBlobAuditingPolicy
};
const expand = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const advisorName = {
    parameterPath: "advisorName",
    mapper: {
        serializedName: "advisorName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters16 = {
    parameterPath: "parameters",
    mapper: Advisor
};
const parameters17 = {
    parameterPath: "parameters",
    mapper: DatabaseAutomaticTuning
};
const schema = {
    parameterPath: ["options", "schema"],
    mapper: {
        serializedName: "schema",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const table = {
    parameterPath: ["options", "table"],
    mapper: {
        serializedName: "table",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const column = {
    parameterPath: ["options", "column"],
    mapper: {
        serializedName: "column",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const orderBy = {
    parameterPath: ["options", "orderBy"],
    mapper: {
        serializedName: "orderBy",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const skiptoken = {
    parameterPath: ["options", "skiptoken"],
    mapper: {
        serializedName: "$skiptoken",
        type: {
            name: "String"
        }
    }
};
const schemaName = {
    parameterPath: "schemaName",
    mapper: {
        serializedName: "schemaName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const tableName = {
    parameterPath: "tableName",
    mapper: {
        serializedName: "tableName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const filter1 = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const columnName = {
    parameterPath: "columnName",
    mapper: {
        serializedName: "columnName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const recommendedActionName = {
    parameterPath: "recommendedActionName",
    mapper: {
        serializedName: "recommendedActionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters18 = {
    parameterPath: "parameters",
    mapper: RecommendedAction
};
const securityAlertPolicyName = {
    parameterPath: "securityAlertPolicyName",
    mapper: {
        serializedName: "securityAlertPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters19 = {
    parameterPath: "parameters",
    mapper: DatabaseSecurityAlertPolicy
};
const vulnerabilityAssessmentName = {
    parameterPath: "vulnerabilityAssessmentName",
    mapper: {
        serializedName: "vulnerabilityAssessmentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const ruleId = {
    parameterPath: "ruleId",
    mapper: {
        serializedName: "ruleId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const baselineName = {
    parameterPath: "baselineName",
    mapper: {
        serializedName: "baselineName",
        required: true,
        type: {
            name: "Enum",
            allowedValues: ["master", "default"]
        }
    }
};
const parameters20 = {
    parameterPath: "parameters",
    mapper: DatabaseVulnerabilityAssessmentRuleBaseline
};
const parameters21 = {
    parameterPath: "parameters",
    mapper: DatabaseVulnerabilityAssessment
};
const scanId = {
    parameterPath: "scanId",
    mapper: {
        serializedName: "scanId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const dataWarehouseUserActivityName = {
    parameterPath: "dataWarehouseUserActivityName",
    mapper: {
        serializedName: "dataWarehouseUserActivityName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const locationName = {
    parameterPath: "locationName",
    mapper: {
        serializedName: "locationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const deletedServerName = {
    parameterPath: "deletedServerName",
    mapper: {
        serializedName: "deletedServerName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const operationId = {
    parameterPath: "operationId",
    mapper: {
        serializedName: "operationId",
        required: true,
        type: {
            name: "Uuid"
        }
    }
};
const encryptionProtectorName = {
    parameterPath: "encryptionProtectorName",
    mapper: {
        serializedName: "encryptionProtectorName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters22 = {
    parameterPath: "parameters",
    mapper: EncryptionProtector
};
const failoverGroupName = {
    parameterPath: "failoverGroupName",
    mapper: {
        serializedName: "failoverGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters23 = {
    parameterPath: "parameters",
    mapper: FailoverGroup
};
const parameters24 = {
    parameterPath: "parameters",
    mapper: FailoverGroupUpdate
};
const firewallRuleName = {
    parameterPath: "firewallRuleName",
    mapper: {
        serializedName: "firewallRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters25 = {
    parameterPath: "parameters",
    mapper: FirewallRule
};
const parameters26 = {
    parameterPath: "parameters",
    mapper: FirewallRuleList
};
const parameters27 = {
    parameterPath: "parameters",
    mapper: InstanceFailoverGroup
};
const instancePoolName = {
    parameterPath: "instancePoolName",
    mapper: {
        serializedName: "instancePoolName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters28 = {
    parameterPath: "parameters",
    mapper: InstancePool
};
const parameters29 = {
    parameterPath: "parameters",
    mapper: InstancePoolUpdate
};
const jobAgentName = {
    parameterPath: "jobAgentName",
    mapper: {
        serializedName: "jobAgentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters30 = {
    parameterPath: "parameters",
    mapper: JobAgent
};
const parameters31 = {
    parameterPath: "parameters",
    mapper: JobAgentUpdate
};
const credentialName = {
    parameterPath: "credentialName",
    mapper: {
        serializedName: "credentialName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters32 = {
    parameterPath: "parameters",
    mapper: JobCredential
};
const createTimeMin = {
    parameterPath: ["options", "createTimeMin"],
    mapper: {
        serializedName: "createTimeMin",
        type: {
            name: "DateTime"
        }
    }
};
const createTimeMax = {
    parameterPath: ["options", "createTimeMax"],
    mapper: {
        serializedName: "createTimeMax",
        type: {
            name: "DateTime"
        }
    }
};
const endTimeMin = {
    parameterPath: ["options", "endTimeMin"],
    mapper: {
        serializedName: "endTimeMin",
        type: {
            name: "DateTime"
        }
    }
};
const endTimeMax = {
    parameterPath: ["options", "endTimeMax"],
    mapper: {
        serializedName: "endTimeMax",
        type: {
            name: "DateTime"
        }
    }
};
const isActive = {
    parameterPath: ["options", "isActive"],
    mapper: {
        serializedName: "isActive",
        type: {
            name: "Boolean"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const jobName = {
    parameterPath: "jobName",
    mapper: {
        serializedName: "jobName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const jobExecutionId = {
    parameterPath: "jobExecutionId",
    mapper: {
        serializedName: "jobExecutionId",
        required: true,
        type: {
            name: "Uuid"
        }
    }
};
const parameters33 = {
    parameterPath: "parameters",
    mapper: Job
};
const stepName = {
    parameterPath: "stepName",
    mapper: {
        serializedName: "stepName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const jobVersion = {
    parameterPath: "jobVersion",
    mapper: {
        serializedName: "jobVersion",
        required: true,
        type: {
            name: "Number"
        }
    }
};
const parameters34 = {
    parameterPath: "parameters",
    mapper: JobStep
};
const targetId = {
    parameterPath: "targetId",
    mapper: {
        serializedName: "targetId",
        required: true,
        type: {
            name: "Uuid"
        }
    }
};
const targetGroupName = {
    parameterPath: "targetGroupName",
    mapper: {
        serializedName: "targetGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters35 = {
    parameterPath: "parameters",
    mapper: JobTargetGroup
};
const include = {
    parameterPath: ["options", "include"],
    mapper: {
        serializedName: "include",
        type: {
            name: "String"
        }
    }
};
const policyName = {
    parameterPath: "policyName",
    mapper: {
        serializedName: "policyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters36 = {
    parameterPath: "parameters",
    mapper: LongTermRetentionPolicy
};
const maintenanceWindowOptionsName = {
    parameterPath: "maintenanceWindowOptionsName",
    mapper: {
        serializedName: "maintenanceWindowOptionsName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const maintenanceWindowName = {
    parameterPath: "maintenanceWindowName",
    mapper: {
        serializedName: "maintenanceWindowName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters37 = {
    parameterPath: "parameters",
    mapper: MaintenanceWindows
};
const managedInstanceName = {
    parameterPath: "managedInstanceName",
    mapper: {
        serializedName: "managedInstanceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const policyName1 = {
    parameterPath: "policyName",
    mapper: {
        serializedName: "policyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters38 = {
    parameterPath: "parameters",
    mapper: ManagedBackupShortTermRetentionPolicy
};
const queryId = {
    parameterPath: "queryId",
    mapper: {
        serializedName: "queryId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const startTime = {
    parameterPath: ["options", "startTime"],
    mapper: {
        serializedName: "startTime",
        type: {
            name: "String"
        }
    }
};
const endTime = {
    parameterPath: ["options", "endTime"],
    mapper: {
        serializedName: "endTime",
        type: {
            name: "String"
        }
    }
};
const interval = {
    parameterPath: ["options", "interval"],
    mapper: {
        serializedName: "interval",
        type: {
            name: "String"
        }
    }
};
const restoreDetailsName = {
    parameterPath: "restoreDetailsName",
    mapper: {
        serializedName: "restoreDetailsName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters39 = {
    parameterPath: "parameters",
    mapper: ManagedDatabase
};
const parameters40 = {
    parameterPath: "parameters",
    mapper: ManagedDatabaseUpdate
};
const parameters41 = {
    parameterPath: "parameters",
    mapper: CompleteDatabaseRestoreDefinition
};
const parameters42 = {
    parameterPath: "parameters",
    mapper: ManagedDatabaseSecurityAlertPolicy
};
const sensitivityLabelSource = {
    parameterPath: "sensitivityLabelSource",
    mapper: {
        serializedName: "sensitivityLabelSource",
        required: true,
        type: {
            name: "Enum",
            allowedValues: ["current", "recommended"]
        }
    }
};
const parameters43 = {
    parameterPath: "parameters",
    mapper: SensitivityLabel
};
const sensitivityLabelSource1 = {
    parameterPath: "sensitivityLabelSource",
    mapper: {
        defaultValue: "current",
        isConstant: true,
        serializedName: "sensitivityLabelSource",
        type: {
            name: "String"
        }
    }
};
const sensitivityLabelSource2 = {
    parameterPath: "sensitivityLabelSource",
    mapper: {
        defaultValue: "recommended",
        isConstant: true,
        serializedName: "sensitivityLabelSource",
        type: {
            name: "String"
        }
    }
};
const count = {
    parameterPath: ["options", "count"],
    mapper: {
        serializedName: "$count",
        type: {
            name: "Boolean"
        }
    }
};
const parameters44 = {
    parameterPath: "parameters",
    mapper: SensitivityLabelUpdateList
};
const includeDisabledRecommendations = {
    parameterPath: ["options", "includeDisabledRecommendations"],
    mapper: {
        serializedName: "includeDisabledRecommendations",
        type: {
            name: "Boolean"
        }
    }
};
const parameters45 = {
    parameterPath: "parameters",
    mapper: RecommendedSensitivityLabelUpdateList
};
const tdeName = {
    parameterPath: "tdeName",
    mapper: {
        serializedName: "tdeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters46 = {
    parameterPath: "parameters",
    mapper: ManagedTransparentDataEncryption
};
const administratorName = {
    parameterPath: "administratorName",
    mapper: {
        serializedName: "administratorName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters47 = {
    parameterPath: "parameters",
    mapper: ManagedInstanceAdministrator
};
const authenticationName = {
    parameterPath: "authenticationName",
    mapper: {
        serializedName: "authenticationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters48 = {
    parameterPath: "parameters",
    mapper: ManagedInstanceAzureADOnlyAuthentication
};
const parameters49 = {
    parameterPath: "parameters",
    mapper: ManagedInstanceEncryptionProtector
};
const keyName = {
    parameterPath: "keyName",
    mapper: {
        serializedName: "keyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters50 = {
    parameterPath: "parameters",
    mapper: ManagedInstanceKey
};
const policyName2 = {
    parameterPath: "policyName",
    mapper: {
        serializedName: "policyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters51 = {
    parameterPath: "parameters",
    mapper: ManagedInstanceLongTermRetentionPolicy
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters52 = {
    parameterPath: "parameters",
    mapper: ManagedInstancePrivateEndpointConnection
};
const groupName = {
    parameterPath: "groupName",
    mapper: {
        serializedName: "groupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters53 = {
    parameterPath: "parameters",
    mapper: TdeCertificate
};
const parameters54 = {
    parameterPath: "parameters",
    mapper: ManagedInstanceVulnerabilityAssessment
};
const restorableDroppedDatabaseId = {
    parameterPath: "restorableDroppedDatabaseId",
    mapper: {
        serializedName: "restorableDroppedDatabaseId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters55 = {
    parameterPath: "parameters",
    mapper: ManagedServerSecurityAlertPolicy
};
const parameters56 = {
    parameterPath: "parameters",
    mapper: PrivateEndpointConnection
};
const recoverableDatabaseName = {
    parameterPath: "recoverableDatabaseName",
    mapper: {
        serializedName: "recoverableDatabaseName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters57 = {
    parameterPath: "parameters",
    mapper: CreateDatabaseRestorePointDefinition
};
const restorePointName = {
    parameterPath: "restorePointName",
    mapper: {
        serializedName: "restorePointName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters58 = {
    parameterPath: "parameters",
    mapper: ServerAutomaticTuning
};
const parameters59 = {
    parameterPath: "parameters",
    mapper: ServerAzureADAdministrator
};
const parameters60 = {
    parameterPath: "parameters",
    mapper: ServerAzureADOnlyAuthentication
};
const devOpsAuditingSettingsName = {
    parameterPath: "devOpsAuditingSettingsName",
    mapper: {
        serializedName: "devOpsAuditingSettingsName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters61 = {
    parameterPath: "parameters",
    mapper: ServerDevOpsAuditingSettings
};
const dnsAliasName = {
    parameterPath: "dnsAliasName",
    mapper: {
        serializedName: "dnsAliasName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters62 = {
    parameterPath: "parameters",
    mapper: ServerDnsAliasAcquisition
};
const parameters63 = {
    parameterPath: "parameters",
    mapper: ServerKey
};
const parameters64 = {
    parameterPath: "parameters",
    mapper: ServerSecurityAlertPolicy
};
const serverTrustGroupName = {
    parameterPath: "serverTrustGroupName",
    mapper: {
        serializedName: "serverTrustGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters65 = {
    parameterPath: "parameters",
    mapper: ServerTrustGroup
};
const parameters66 = {
    parameterPath: "parameters",
    mapper: ServerVulnerabilityAssessment
};
const parameters67 = {
    parameterPath: "parameters",
    mapper: SqlAgentConfiguration
};
const usageName = {
    parameterPath: "usageName",
    mapper: {
        serializedName: "usageName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const syncAgentName = {
    parameterPath: "syncAgentName",
    mapper: {
        serializedName: "syncAgentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters68 = {
    parameterPath: "parameters",
    mapper: SyncAgent
};
const syncGroupName = {
    parameterPath: "syncGroupName",
    mapper: {
        serializedName: "syncGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const startTime1 = {
    parameterPath: "startTime",
    mapper: {
        serializedName: "startTime",
        required: true,
        type: {
            name: "String"
        }
    }
};
const endTime1 = {
    parameterPath: "endTime",
    mapper: {
        serializedName: "endTime",
        required: true,
        type: {
            name: "String"
        }
    }
};
const typeParam = {
    parameterPath: "typeParam",
    mapper: {
        serializedName: "type",
        required: true,
        type: {
            name: "String"
        }
    }
};
const continuationToken = {
    parameterPath: ["options", "continuationToken"],
    mapper: {
        serializedName: "continuationToken",
        type: {
            name: "String"
        }
    }
};
const parameters69 = {
    parameterPath: "parameters",
    mapper: SyncGroup
};
const syncMemberName = {
    parameterPath: "syncMemberName",
    mapper: {
        serializedName: "syncMemberName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters70 = {
    parameterPath: "parameters",
    mapper: SyncMember
};
const timeZoneId = {
    parameterPath: "timeZoneId",
    mapper: {
        serializedName: "timeZoneId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualClusterName = {
    parameterPath: "virtualClusterName",
    mapper: {
        serializedName: "virtualClusterName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters71 = {
    parameterPath: "parameters",
    mapper: VirtualClusterUpdate
};
const virtualNetworkRuleName = {
    parameterPath: "virtualNetworkRuleName",
    mapper: {
        serializedName: "virtualNetworkRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters72 = {
    parameterPath: "parameters",
    mapper: VirtualNetworkRule
};
const workloadGroupName = {
    parameterPath: "workloadGroupName",
    mapper: {
        serializedName: "workloadGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workloadClassifierName = {
    parameterPath: "workloadClassifierName",
    mapper: {
        serializedName: "workloadClassifierName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters73 = {
    parameterPath: "parameters",
    mapper: WorkloadClassifier
};
const parameters74 = {
    parameterPath: "parameters",
    mapper: WorkloadGroup
};
const parameters75 = {
    parameterPath: "parameters",
    mapper: LogicalDatabaseTransparentDataEncryption
};
const policyName3 = {
    parameterPath: "policyName",
    mapper: {
        serializedName: "policyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters76 = {
    parameterPath: "parameters",
    mapper: BackupShortTermRetentionPolicy
};
const extensionName = {
    parameterPath: "extensionName",
    mapper: {
        serializedName: "extensionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters77 = {
    parameterPath: "parameters",
    mapper: DatabaseExtensions
};
const ledgerDigestUploads = {
    parameterPath: "ledgerDigestUploads",
    mapper: {
        serializedName: "ledgerDigestUploads",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters78 = {
    parameterPath: "parameters",
    mapper: LedgerDigestUploads
};
const outboundRuleFqdn = {
    parameterPath: "outboundRuleFqdn",
    mapper: {
        serializedName: "outboundRuleFqdn",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters79 = {
    parameterPath: "parameters",
    mapper: OutboundFirewallRule
};
const parameters80 = {
    parameterPath: "parameters",
    mapper: Server
};
const parameters81 = {
    parameterPath: "parameters",
    mapper: ServerUpdate
};
const parameters82 = {
    parameterPath: "parameters",
    mapper: ImportNewDatabaseDefinition
};
const parameters83 = {
    parameterPath: "parameters",
    mapper: CheckNameAvailabilityRequest
};
const expandChildren = {
    parameterPath: ["options", "expandChildren"],
    mapper: {
        serializedName: "expandChildren",
        type: {
            name: "Boolean"
        }
    }
};
const parameters84 = {
    parameterPath: "parameters",
    mapper: CopyLongTermRetentionBackupParameters
};
const longTermRetentionServerName = {
    parameterPath: "longTermRetentionServerName",
    mapper: {
        serializedName: "longTermRetentionServerName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const longTermRetentionDatabaseName = {
    parameterPath: "longTermRetentionDatabaseName",
    mapper: {
        serializedName: "longTermRetentionDatabaseName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const backupName = {
    parameterPath: "backupName",
    mapper: {
        serializedName: "backupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters85 = {
    parameterPath: "parameters",
    mapper: UpdateLongTermRetentionBackupParameters
};
const onlyLatestPerDatabase = {
    parameterPath: ["options", "onlyLatestPerDatabase"],
    mapper: {
        serializedName: "onlyLatestPerDatabase",
        type: {
            name: "Boolean"
        }
    }
};
const databaseState = {
    parameterPath: ["options", "databaseState"],
    mapper: {
        serializedName: "databaseState",
        type: {
            name: "String"
        }
    }
};
const parameters86 = {
    parameterPath: "parameters",
    mapper: ManagedInstance
};
const parameters87 = {
    parameterPath: "parameters",
    mapper: ManagedInstanceUpdate
};
const numberOfQueries = {
    parameterPath: ["options", "numberOfQueries"],
    mapper: {
        serializedName: "numberOfQueries",
        type: {
            name: "Number"
        }
    }
};
const databases = {
    parameterPath: ["options", "databases"],
    mapper: {
        serializedName: "databases",
        type: {
            name: "String"
        }
    }
};
const aggregationFunction = {
    parameterPath: ["options", "aggregationFunction"],
    mapper: {
        serializedName: "aggregationFunction",
        type: {
            name: "String"
        }
    }
};
const observationMetric = {
    parameterPath: ["options", "observationMetric"],
    mapper: {
        serializedName: "observationMetric",
        type: {
            name: "String"
        }
    }
};
const connectionPolicyName = {
    parameterPath: "connectionPolicyName",
    mapper: {
        serializedName: "connectionPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters88 = {
    parameterPath: "parameters",
    mapper: ServerConnectionPolicy
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RecoverableDatabases operations. */
class RecoverableDatabasesImpl {
    /**
     * Initialize a new instance of the class RecoverableDatabases class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of recoverable databases
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a recoverable database, which is a resource representing a database's geo backup
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, getOperationSpec);
    }
    /**
     * Gets a list of recoverable databases
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/recoverableDatabases/{databaseName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecoverableDatabase
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer
};
const listByServerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/recoverableDatabases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecoverableDatabaseListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing DataMaskingPolicies operations. */
class DataMaskingPoliciesImpl {
    /**
     * Initialize a new instance of the class DataMaskingPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates or updates a database data masking policy
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters Parameters for creating or updating a data masking policy.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, databaseName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, parameters, options }, createOrUpdateOperationSpec);
    }
    /**
     * Gets a database data masking policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, getOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/dataMaskingPolicies/{dataMaskingPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DataMaskingPolicy
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        dataMaskingPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/dataMaskingPolicies/{dataMaskingPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataMaskingPolicy
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        dataMaskingPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DataMaskingRules operations. */
class DataMaskingRulesImpl {
    /**
     * Initialize a new instance of the class DataMaskingRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of database data masking rules.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates or updates a database data masking rule.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param dataMaskingRuleName The name of the data masking rule.
     * @param parameters The required parameters for creating or updating a data masking rule.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, databaseName, dataMaskingRuleName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            dataMaskingRuleName,
            parameters,
            options
        }, createOrUpdateOperationSpec$1);
    }
    /**
     * Gets a list of database data masking rules.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/dataMaskingPolicies/{dataMaskingPolicyName}/rules/{dataMaskingRuleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DataMaskingRule
        },
        201: {
            bodyMapper: DataMaskingRule
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        dataMaskingPolicyName,
        dataMaskingRuleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const listByDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/dataMaskingPolicies/{dataMaskingPolicyName}/rules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataMaskingRuleListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        dataMaskingPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing GeoBackupPolicies operations. */
class GeoBackupPoliciesImpl {
    /**
     * Initialize a new instance of the class GeoBackupPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns a list of geo backup policies.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Updates a database geo backup policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param geoBackupPolicyName The name of the geo backup policy.
     * @param parameters The required parameters for creating or updating the geo backup policy.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, databaseName, geoBackupPolicyName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            geoBackupPolicyName,
            parameters,
            options
        }, createOrUpdateOperationSpec$2);
    }
    /**
     * Gets a geo backup policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param geoBackupPolicyName The name of the geo backup policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, geoBackupPolicyName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            geoBackupPolicyName,
            options
        }, getOperationSpec$2);
    }
    /**
     * Returns a list of geo backup policies.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$1);
    }
}
// Operation Specifications
const serializer$3 = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/geoBackupPolicies/{geoBackupPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GeoBackupPolicy
        },
        201: {
            bodyMapper: GeoBackupPolicy
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        geoBackupPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/geoBackupPolicies/{geoBackupPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GeoBackupPolicy
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        geoBackupPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByDatabaseOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/geoBackupPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GeoBackupPolicyListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Databases operations. */
class DatabasesImpl {
    /**
     * Initialize a new instance of the class Databases class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns database metrics.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param filter An OData filter expression that describes a subset of metrics to return.
     * @param options The options parameters.
     */
    listMetrics(resourceGroupName, serverName, databaseName, filter, options) {
        const iter = this.listMetricsPagingAll(resourceGroupName, serverName, databaseName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listMetricsPagingPage(resourceGroupName, serverName, databaseName, filter, options);
            }
        };
    }
    listMetricsPagingPage(resourceGroupName, serverName, databaseName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingPage_1() {
            let result = yield tslib.__await(this._listMetrics(resourceGroupName, serverName, databaseName, filter, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricsPagingAll(resourceGroupName, serverName, databaseName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listMetricsPagingPage(resourceGroupName, serverName, databaseName, filter, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns database metric definitions.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listMetricDefinitions(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listMetricDefinitionsPagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listMetricDefinitionsPagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listMetricDefinitionsPagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricDefinitionsPagingPage_1() {
            let result = yield tslib.__await(this._listMetricDefinitions(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricDefinitionsPagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricDefinitionsPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listMetricDefinitionsPagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of databases.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Gets a list of databases in an elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param options The options parameters.
     */
    listByElasticPool(resourceGroupName, serverName, elasticPoolName, options) {
        const iter = this.listByElasticPoolPagingAll(resourceGroupName, serverName, elasticPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByElasticPoolPagingPage(resourceGroupName, serverName, elasticPoolName, options);
            }
        };
    }
    listByElasticPoolPagingPage(resourceGroupName, serverName, elasticPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByElasticPoolPagingPage_1() {
            let result = yield tslib.__await(this._listByElasticPool(resourceGroupName, serverName, elasticPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByElasticPoolNext(resourceGroupName, serverName, elasticPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByElasticPoolPagingAll(resourceGroupName, serverName, elasticPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByElasticPoolPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByElasticPoolPagingPage(resourceGroupName, serverName, elasticPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Gets a list of inaccessible databases in a logical server
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listInaccessibleByServer(resourceGroupName, serverName, options) {
        const iter = this.listInaccessibleByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listInaccessibleByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listInaccessibleByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInaccessibleByServerPagingPage_1() {
            let result = yield tslib.__await(this._listInaccessibleByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listInaccessibleByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listInaccessibleByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInaccessibleByServerPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listInaccessibleByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Returns database metrics.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param filter An OData filter expression that describes a subset of metrics to return.
     * @param options The options parameters.
     */
    _listMetrics(resourceGroupName, serverName, databaseName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, filter, options }, listMetricsOperationSpec);
    }
    /**
     * Returns database metric definitions.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listMetricDefinitions(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listMetricDefinitionsOperationSpec);
    }
    /**
     * Gets a list of databases.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$1);
    }
    /**
     * Gets a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, getOperationSpec$3);
    }
    /**
     * Creates a new database or updates an existing database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters The requested database resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, databaseName, parameters, options }, createOrUpdateOperationSpec$3);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates a new database or updates an existing database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters The requested database resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, databaseName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, databaseName, options }, deleteOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes the database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters The requested database resource state.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, serverName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, databaseName, parameters, options }, updateOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates an existing database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters The requested database resource state.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, serverName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, serverName, databaseName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of databases in an elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param options The options parameters.
     */
    _listByElasticPool(resourceGroupName, serverName, elasticPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, elasticPoolName, options }, listByElasticPoolOperationSpec);
    }
    /**
     * Failovers a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database to failover.
     * @param options The options parameters.
     */
    beginFailover(resourceGroupName, serverName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, databaseName, options }, failoverOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Failovers a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database to failover.
     * @param options The options parameters.
     */
    beginFailoverAndWait(resourceGroupName, serverName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginFailover(resourceGroupName, serverName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of inaccessible databases in a logical server
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listInaccessibleByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listInaccessibleByServerOperationSpec);
    }
    /**
     * Pauses a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database to be paused.
     * @param options The options parameters.
     */
    beginPause(resourceGroupName, serverName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, databaseName, options }, pauseOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Pauses a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database to be paused.
     * @param options The options parameters.
     */
    beginPauseAndWait(resourceGroupName, serverName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPause(resourceGroupName, serverName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Resumes a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database to be resumed.
     * @param options The options parameters.
     */
    beginResume(resourceGroupName, serverName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, databaseName, options }, resumeOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Resumes a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database to be resumed.
     * @param options The options parameters.
     */
    beginResumeAndWait(resourceGroupName, serverName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResume(resourceGroupName, serverName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Upgrades a data warehouse.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database to be upgraded.
     * @param options The options parameters.
     */
    beginUpgradeDataWarehouse(resourceGroupName, serverName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, databaseName, options }, upgradeDataWarehouseOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Upgrades a data warehouse.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database to be upgraded.
     * @param options The options parameters.
     */
    beginUpgradeDataWarehouseAndWait(resourceGroupName, serverName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpgradeDataWarehouse(resourceGroupName, serverName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Renames a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database to rename.
     * @param parameters The resource move definition for renaming this database.
     * @param options The options parameters.
     */
    rename(resourceGroupName, serverName, databaseName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, parameters, options }, renameOperationSpec);
    }
    /**
     * Imports a bacpac into a new database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters The database import request parameters.
     * @param options The options parameters.
     */
    beginImport(resourceGroupName, serverName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, databaseName, parameters, options }, importOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Imports a bacpac into a new database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters The database import request parameters.
     * @param options The options parameters.
     */
    beginImportAndWait(resourceGroupName, serverName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginImport(resourceGroupName, serverName, databaseName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Exports a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters The database export request parameters.
     * @param options The options parameters.
     */
    beginExport(resourceGroupName, serverName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, databaseName, parameters, options }, exportOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Exports a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters The database export request parameters.
     * @param options The options parameters.
     */
    beginExportAndWait(resourceGroupName, serverName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginExport(resourceGroupName, serverName, databaseName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec);
    }
    /**
     * ListByElasticPoolNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param nextLink The nextLink from the previous successful call to the ListByElasticPool method.
     * @param options The options parameters.
     */
    _listByElasticPoolNext(resourceGroupName, serverName, elasticPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, elasticPoolName, nextLink, options }, listByElasticPoolNextOperationSpec);
    }
    /**
     * ListInaccessibleByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListInaccessibleByServer
     *                 method.
     * @param options The options parameters.
     */
    _listInaccessibleByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listInaccessibleByServerNextOperationSpec);
    }
}
// Operation Specifications
const serializer$4 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listMetricsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/metrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetricListResult
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listMetricDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/metricDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetricDefinitionListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listByServerOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseListResult
        },
        default: {}
    },
    queryParameters: [skipToken, apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Database
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Database
        },
        201: {
            bodyMapper: Database
        },
        202: {
            bodyMapper: Database
        },
        204: {
            bodyMapper: Database
        },
        default: {}
    },
    requestBody: parameters3,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    serializer: serializer$4
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Database
        },
        201: {
            bodyMapper: Database
        },
        202: {
            bodyMapper: Database
        },
        204: {
            bodyMapper: Database
        },
        default: {}
    },
    requestBody: parameters4,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const listByElasticPoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/elasticPools/{elasticPoolName}/databases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        elasticPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const failoverOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/failover",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion1, replicaType],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    serializer: serializer$4
};
const listInaccessibleByServerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/inaccessibleDatabases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const pauseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/pause",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Database
        },
        201: {
            bodyMapper: Database
        },
        202: {
            bodyMapper: Database
        },
        204: {
            bodyMapper: Database
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const resumeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/resume",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Database
        },
        201: {
            bodyMapper: Database
        },
        202: {
            bodyMapper: Database
        },
        204: {
            bodyMapper: Database
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const upgradeDataWarehouseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/upgradeDataWarehouse",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    serializer: serializer$4
};
const renameOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/move",
    httpMethod: "POST",
    responses: { 200: {}, default: {} },
    requestBody: parameters5,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$4
};
const importOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/import",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ImportExportOperationResult
        },
        201: {
            bodyMapper: ImportExportOperationResult
        },
        202: {
            bodyMapper: ImportExportOperationResult
        },
        204: {
            bodyMapper: ImportExportOperationResult
        },
        default: {}
    },
    requestBody: parameters6,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const exportOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/export",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ImportExportOperationResult
        },
        201: {
            bodyMapper: ImportExportOperationResult
        },
        202: {
            bodyMapper: ImportExportOperationResult
        },
        204: {
            bodyMapper: ImportExportOperationResult
        },
        default: {}
    },
    requestBody: parameters7,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const listByServerNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseListResult
        },
        default: {}
    },
    queryParameters: [skipToken, apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listByElasticPoolNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        elasticPoolName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listInaccessibleByServerNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ElasticPools operations. */
class ElasticPoolsImpl {
    /**
     * Initialize a new instance of the class ElasticPools class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns elastic pool  metrics.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param filter An OData filter expression that describes a subset of metrics to return.
     * @param options The options parameters.
     */
    listMetrics(resourceGroupName, serverName, elasticPoolName, filter, options) {
        const iter = this.listMetricsPagingAll(resourceGroupName, serverName, elasticPoolName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listMetricsPagingPage(resourceGroupName, serverName, elasticPoolName, filter, options);
            }
        };
    }
    listMetricsPagingPage(resourceGroupName, serverName, elasticPoolName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingPage_1() {
            let result = yield tslib.__await(this._listMetrics(resourceGroupName, serverName, elasticPoolName, filter, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricsPagingAll(resourceGroupName, serverName, elasticPoolName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listMetricsPagingPage(resourceGroupName, serverName, elasticPoolName, filter, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns elastic pool metric definitions.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param options The options parameters.
     */
    listMetricDefinitions(resourceGroupName, serverName, elasticPoolName, options) {
        const iter = this.listMetricDefinitionsPagingAll(resourceGroupName, serverName, elasticPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listMetricDefinitionsPagingPage(resourceGroupName, serverName, elasticPoolName, options);
            }
        };
    }
    listMetricDefinitionsPagingPage(resourceGroupName, serverName, elasticPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricDefinitionsPagingPage_1() {
            let result = yield tslib.__await(this._listMetricDefinitions(resourceGroupName, serverName, elasticPoolName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricDefinitionsPagingAll(resourceGroupName, serverName, elasticPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricDefinitionsPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listMetricDefinitionsPagingPage(resourceGroupName, serverName, elasticPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets all elastic pools in a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Returns elastic pool  metrics.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param filter An OData filter expression that describes a subset of metrics to return.
     * @param options The options parameters.
     */
    _listMetrics(resourceGroupName, serverName, elasticPoolName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, elasticPoolName, filter, options }, listMetricsOperationSpec$1);
    }
    /**
     * Returns elastic pool metric definitions.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param options The options parameters.
     */
    _listMetricDefinitions(resourceGroupName, serverName, elasticPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, elasticPoolName, options }, listMetricDefinitionsOperationSpec$1);
    }
    /**
     * Gets all elastic pools in a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$2);
    }
    /**
     * Gets an elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, elasticPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, elasticPoolName, options }, getOperationSpec$4);
    }
    /**
     * Creates or updates an elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param parameters The elastic pool parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, elasticPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, elasticPoolName, parameters, options }, createOrUpdateOperationSpec$4);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates an elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param parameters The elastic pool parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, elasticPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, elasticPoolName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, elasticPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, elasticPoolName, options }, deleteOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes an elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, elasticPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, elasticPoolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param parameters The elastic pool update parameters.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, serverName, elasticPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, elasticPoolName, parameters, options }, updateOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates an elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param parameters The elastic pool update parameters.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, serverName, elasticPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, serverName, elasticPoolName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Failovers an elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool to failover.
     * @param options The options parameters.
     */
    beginFailover(resourceGroupName, serverName, elasticPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, elasticPoolName, options }, failoverOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Failovers an elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool to failover.
     * @param options The options parameters.
     */
    beginFailoverAndWait(resourceGroupName, serverName, elasticPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginFailover(resourceGroupName, serverName, elasticPoolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$5 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listMetricsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/elasticPools/{elasticPoolName}/metrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetricListResult
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        elasticPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listMetricDefinitionsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/elasticPools/{elasticPoolName}/metricDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetricDefinitionListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        elasticPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listByServerOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/elasticPools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ElasticPoolListResult
        },
        default: {}
    },
    queryParameters: [skip, apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/elasticPools/{elasticPoolName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ElasticPool
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        elasticPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/elasticPools/{elasticPoolName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ElasticPool
        },
        201: {
            bodyMapper: ElasticPool
        },
        202: {
            bodyMapper: ElasticPool
        },
        204: {
            bodyMapper: ElasticPool
        },
        default: {}
    },
    requestBody: parameters8,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        elasticPoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/elasticPools/{elasticPoolName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        elasticPoolName
    ],
    serializer: serializer$5
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/elasticPools/{elasticPoolName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ElasticPool
        },
        201: {
            bodyMapper: ElasticPool
        },
        202: {
            bodyMapper: ElasticPool
        },
        204: {
            bodyMapper: ElasticPool
        },
        default: {}
    },
    requestBody: parameters9,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        elasticPoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const failoverOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/elasticPools/{elasticPoolName}/failover",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        elasticPoolName
    ],
    serializer: serializer$5
};
const listByServerNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ElasticPoolListResult
        },
        default: {}
    },
    queryParameters: [skip, apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ReplicationLinks operations. */
class ReplicationLinksImpl {
    /**
     * Initialize a new instance of the class ReplicationLinks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of replication links on database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of replication links.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes a database replication link. Cannot be done during failover.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database that has the replication link to be dropped.
     * @param linkId The ID of the replication link to be deleted.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serverName, databaseName, linkId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, linkId, options }, deleteOperationSpec$2);
    }
    /**
     * Sets which replica database is primary by failing over from the current primary replica database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database that has the replication link to be failed over.
     * @param linkId The ID of the replication link to be failed over.
     * @param options The options parameters.
     */
    beginFailover(resourceGroupName, serverName, databaseName, linkId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, databaseName, linkId, options }, failoverOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Sets which replica database is primary by failing over from the current primary replica database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database that has the replication link to be failed over.
     * @param linkId The ID of the replication link to be failed over.
     * @param options The options parameters.
     */
    beginFailoverAndWait(resourceGroupName, serverName, databaseName, linkId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginFailover(resourceGroupName, serverName, databaseName, linkId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Sets which replica database is primary by failing over from the current primary replica database.
     * This operation might result in data loss.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database that has the replication link to be failed over.
     * @param linkId The ID of the replication link to be failed over.
     * @param options The options parameters.
     */
    beginFailoverAllowDataLoss(resourceGroupName, serverName, databaseName, linkId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, databaseName, linkId, options }, failoverAllowDataLossOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Sets which replica database is primary by failing over from the current primary replica database.
     * This operation might result in data loss.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database that has the replication link to be failed over.
     * @param linkId The ID of the replication link to be failed over.
     * @param options The options parameters.
     */
    beginFailoverAllowDataLossAndWait(resourceGroupName, serverName, databaseName, linkId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginFailoverAllowDataLoss(resourceGroupName, serverName, databaseName, linkId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a database replication link in forced or friendly way.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database that has the replication link to be failed over.
     * @param linkId The ID of the replication link to be failed over.
     * @param parameters The required parameters for unlinking replication link.
     * @param options The options parameters.
     */
    beginUnlink(resourceGroupName, serverName, databaseName, linkId, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                linkId,
                parameters,
                options
            }, unlinkOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a database replication link in forced or friendly way.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database that has the replication link to be failed over.
     * @param linkId The ID of the replication link to be failed over.
     * @param parameters The required parameters for unlinking replication link.
     * @param options The options parameters.
     */
    beginUnlinkAndWait(resourceGroupName, serverName, databaseName, linkId, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUnlink(resourceGroupName, serverName, databaseName, linkId, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of replication links on database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$2);
    }
    /**
     * Gets a replication link.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param linkId The name of the replication link.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, linkId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, linkId, options }, getOperationSpec$5);
    }
    /**
     * Gets a list of replication links.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$3);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$6 = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/replicationLinks/{linkId}",
    httpMethod: "DELETE",
    responses: { 200: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        linkId
    ],
    serializer: serializer$6
};
const failoverOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/replicationLinks/{linkId}/failover",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        linkId
    ],
    serializer: serializer$6
};
const failoverAllowDataLossOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/replicationLinks/{linkId}/forceFailoverAllowDataLoss",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        linkId
    ],
    serializer: serializer$6
};
const unlinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/replicationLinks/{linkId}/unlink",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    requestBody: parameters10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        linkId
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$6
};
const listByDatabaseOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/replicationLinks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReplicationLinkListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/replicationLinks/{linkId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReplicationLink
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        linkId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByServerOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/replicationLinks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReplicationLinkListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByDatabaseNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReplicationLinkListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByServerNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReplicationLinkListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServerCommunicationLinks operations. */
class ServerCommunicationLinksImpl {
    /**
     * Initialize a new instance of the class ServerCommunicationLinks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of server communication links.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes a server communication link.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param communicationLinkName The name of the server communication link.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serverName, communicationLinkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, communicationLinkName, options }, deleteOperationSpec$3);
    }
    /**
     * Returns a server communication link.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param communicationLinkName The name of the server communication link.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, communicationLinkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, communicationLinkName, options }, getOperationSpec$6);
    }
    /**
     * Creates a server communication link.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param communicationLinkName The name of the server communication link.
     * @param parameters The required parameters for creating a server communication link.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, communicationLinkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                communicationLinkName,
                parameters,
                options
            }, createOrUpdateOperationSpec$5);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates a server communication link.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param communicationLinkName The name of the server communication link.
     * @param parameters The required parameters for creating a server communication link.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, communicationLinkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, communicationLinkName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of server communication links.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$4);
    }
}
// Operation Specifications
const serializer$7 = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/communicationLinks/{communicationLinkName}",
    httpMethod: "DELETE",
    responses: { 200: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        communicationLinkName
    ],
    serializer: serializer$7
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/communicationLinks/{communicationLinkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerCommunicationLink
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        communicationLinkName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/communicationLinks/{communicationLinkName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServerCommunicationLink
        },
        201: {
            bodyMapper: ServerCommunicationLink
        },
        202: {
            bodyMapper: ServerCommunicationLink
        },
        204: {
            bodyMapper: ServerCommunicationLink
        }
    },
    requestBody: parameters11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        communicationLinkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const listByServerOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/communicationLinks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerCommunicationLinkListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServiceObjectives operations. */
class ServiceObjectivesImpl {
    /**
     * Initialize a new instance of the class ServiceObjectives class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns database service objectives.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a database service objective.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param serviceObjectiveName The name of the service objective to retrieve.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, serviceObjectiveName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, serviceObjectiveName, options }, getOperationSpec$7);
    }
    /**
     * Returns database service objectives.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$5);
    }
}
// Operation Specifications
const serializer$8 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/serviceObjectives/{serviceObjectiveName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceObjective
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        serviceObjectiveName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByServerOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/serviceObjectives",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceObjectiveListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ElasticPoolActivities operations. */
class ElasticPoolActivitiesImpl {
    /**
     * Initialize a new instance of the class ElasticPoolActivities class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns elastic pool activities.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool for which to get the current activity.
     * @param options The options parameters.
     */
    listByElasticPool(resourceGroupName, serverName, elasticPoolName, options) {
        const iter = this.listByElasticPoolPagingAll(resourceGroupName, serverName, elasticPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByElasticPoolPagingPage(resourceGroupName, serverName, elasticPoolName, options);
            }
        };
    }
    listByElasticPoolPagingPage(resourceGroupName, serverName, elasticPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByElasticPoolPagingPage_1() {
            let result = yield tslib.__await(this._listByElasticPool(resourceGroupName, serverName, elasticPoolName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByElasticPoolPagingAll(resourceGroupName, serverName, elasticPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByElasticPoolPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByElasticPoolPagingPage(resourceGroupName, serverName, elasticPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns elastic pool activities.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool for which to get the current activity.
     * @param options The options parameters.
     */
    _listByElasticPool(resourceGroupName, serverName, elasticPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, elasticPoolName, options }, listByElasticPoolOperationSpec$1);
    }
}
// Operation Specifications
const serializer$9 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByElasticPoolOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/elasticPools/{elasticPoolName}/elasticPoolActivity",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ElasticPoolActivityListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        elasticPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ElasticPoolDatabaseActivities operations. */
class ElasticPoolDatabaseActivitiesImpl {
    /**
     * Initialize a new instance of the class ElasticPoolDatabaseActivities class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns activity on databases inside of an elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param options The options parameters.
     */
    listByElasticPool(resourceGroupName, serverName, elasticPoolName, options) {
        const iter = this.listByElasticPoolPagingAll(resourceGroupName, serverName, elasticPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByElasticPoolPagingPage(resourceGroupName, serverName, elasticPoolName, options);
            }
        };
    }
    listByElasticPoolPagingPage(resourceGroupName, serverName, elasticPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByElasticPoolPagingPage_1() {
            let result = yield tslib.__await(this._listByElasticPool(resourceGroupName, serverName, elasticPoolName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByElasticPoolPagingAll(resourceGroupName, serverName, elasticPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByElasticPoolPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByElasticPoolPagingPage(resourceGroupName, serverName, elasticPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns activity on databases inside of an elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName The name of the elastic pool.
     * @param options The options parameters.
     */
    _listByElasticPool(resourceGroupName, serverName, elasticPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, elasticPoolName, options }, listByElasticPoolOperationSpec$2);
    }
}
// Operation Specifications
const serializer$a = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByElasticPoolOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/elasticPools/{elasticPoolName}/elasticPoolDatabaseActivity",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ElasticPoolDatabaseActivityListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        elasticPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServerUsages operations. */
class ServerUsagesImpl {
    /**
     * Initialize a new instance of the class ServerUsages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns server usages.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns server usages.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$6);
    }
}
// Operation Specifications
const serializer$b = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByServerOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerUsageListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExtendedDatabaseBlobAuditingPolicies operations. */
class ExtendedDatabaseBlobAuditingPoliciesImpl {
    /**
     * Initialize a new instance of the class ExtendedDatabaseBlobAuditingPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists extended auditing settings of a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets an extended database's blob auditing policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, getOperationSpec$8);
    }
    /**
     * Creates or updates an extended database's blob auditing policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters The extended database blob auditing policy.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, databaseName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, parameters, options }, createOrUpdateOperationSpec$6);
    }
    /**
     * Lists extended auditing settings of a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$3);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$c = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/extendedAuditingSettings/{blobAuditingPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExtendedDatabaseBlobAuditingPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        blobAuditingPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/extendedAuditingSettings/{blobAuditingPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExtendedDatabaseBlobAuditingPolicy
        },
        201: {
            bodyMapper: ExtendedDatabaseBlobAuditingPolicy
        },
        default: {}
    },
    requestBody: parameters12,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        blobAuditingPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const listByDatabaseOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/extendedAuditingSettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExtendedDatabaseBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listByDatabaseNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExtendedDatabaseBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExtendedServerBlobAuditingPolicies operations. */
class ExtendedServerBlobAuditingPoliciesImpl {
    /**
     * Initialize a new instance of the class ExtendedServerBlobAuditingPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists extended auditing settings of a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets an extended server's blob auditing policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, getOperationSpec$9);
    }
    /**
     * Creates or updates an extended server's blob auditing policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param parameters Properties of extended blob auditing policy
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, parameters, options }, createOrUpdateOperationSpec$7);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates an extended server's blob auditing policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param parameters Properties of extended blob auditing policy
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists extended auditing settings of a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$7);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$d = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/extendedAuditingSettings/{blobAuditingPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExtendedServerBlobAuditingPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        blobAuditingPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/extendedAuditingSettings/{blobAuditingPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExtendedServerBlobAuditingPolicy
        },
        201: {
            bodyMapper: ExtendedServerBlobAuditingPolicy
        },
        202: {
            bodyMapper: ExtendedServerBlobAuditingPolicy
        },
        204: {
            bodyMapper: ExtendedServerBlobAuditingPolicy
        },
        default: {}
    },
    requestBody: parameters13,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        blobAuditingPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const listByServerOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/extendedAuditingSettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExtendedServerBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByServerNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExtendedServerBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServerBlobAuditingPolicies operations. */
class ServerBlobAuditingPoliciesImpl {
    /**
     * Initialize a new instance of the class ServerBlobAuditingPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists auditing settings of a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a server's blob auditing policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, getOperationSpec$a);
    }
    /**
     * Creates or updates a server's blob auditing policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param parameters Properties of blob auditing policy
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, parameters, options }, createOrUpdateOperationSpec$8);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a server's blob auditing policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param parameters Properties of blob auditing policy
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists auditing settings of a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$8);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$e = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/auditingSettings/{blobAuditingPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerBlobAuditingPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        blobAuditingPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/auditingSettings/{blobAuditingPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServerBlobAuditingPolicy
        },
        201: {
            bodyMapper: ServerBlobAuditingPolicy
        },
        202: {
            bodyMapper: ServerBlobAuditingPolicy
        },
        204: {
            bodyMapper: ServerBlobAuditingPolicy
        },
        default: {}
    },
    requestBody: parameters14,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        blobAuditingPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const listByServerOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/auditingSettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const listByServerNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DatabaseBlobAuditingPolicies operations. */
class DatabaseBlobAuditingPoliciesImpl {
    /**
     * Initialize a new instance of the class DatabaseBlobAuditingPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists auditing settings of a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a database's blob auditing policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, getOperationSpec$b);
    }
    /**
     * Creates or updates a database's blob auditing policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters The database blob auditing policy.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, databaseName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, parameters, options }, createOrUpdateOperationSpec$9);
    }
    /**
     * Lists auditing settings of a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$4);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$f = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/auditingSettings/{blobAuditingPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseBlobAuditingPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        blobAuditingPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const createOrUpdateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/auditingSettings/{blobAuditingPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DatabaseBlobAuditingPolicy
        },
        201: {
            bodyMapper: DatabaseBlobAuditingPolicy
        },
        default: {}
    },
    requestBody: parameters15,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        blobAuditingPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const listByDatabaseOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/auditingSettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByDatabaseNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseBlobAuditingPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing DatabaseAdvisors operations. */
class DatabaseAdvisorsImpl {
    /**
     * Initialize a new instance of the class DatabaseAdvisors class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of database advisors.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$5);
    }
    /**
     * Gets a database advisor.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param advisorName The name of the Database Advisor.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, advisorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, advisorName, options }, getOperationSpec$c);
    }
    /**
     * Updates a database advisor.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param advisorName The name of the Database Advisor.
     * @param parameters The requested advisor resource state.
     * @param options The options parameters.
     */
    update(resourceGroupName, serverName, databaseName, advisorName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            advisorName,
            parameters,
            options
        }, updateOperationSpec$2);
    }
}
// Operation Specifications
const serializer$g = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByDatabaseOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/advisors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "Advisor" } }
                }
            }
        },
        default: {}
    },
    queryParameters: [apiVersion2, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/advisors/{advisorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Advisor
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        advisorName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/advisors/{advisorName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Advisor
        },
        default: {}
    },
    requestBody: parameters16,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        advisorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing DatabaseAutomaticTuningOperations operations. */
class DatabaseAutomaticTuningOperationsImpl {
    /**
     * Initialize a new instance of the class DatabaseAutomaticTuningOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a database's automatic tuning.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, getOperationSpec$d);
    }
    /**
     * Update automatic tuning properties for target database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters The requested automatic tuning resource state.
     * @param options The options parameters.
     */
    update(resourceGroupName, serverName, databaseName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, parameters, options }, updateOperationSpec$3);
    }
}
// Operation Specifications
const serializer$h = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/automaticTuning/current",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseAutomaticTuning
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/automaticTuning/current",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DatabaseAutomaticTuning
        },
        default: {}
    },
    requestBody: parameters17,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DatabaseColumns operations. */
class DatabaseColumnsImpl {
    /**
     * Initialize a new instance of the class DatabaseColumns class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List database columns
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List database columns
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param options The options parameters.
     */
    listByTable(resourceGroupName, serverName, databaseName, schemaName, tableName, options) {
        const iter = this.listByTablePagingAll(resourceGroupName, serverName, databaseName, schemaName, tableName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByTablePagingPage(resourceGroupName, serverName, databaseName, schemaName, tableName, options);
            }
        };
    }
    listByTablePagingPage(resourceGroupName, serverName, databaseName, schemaName, tableName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByTablePagingPage_1() {
            let result = yield tslib.__await(this._listByTable(resourceGroupName, serverName, databaseName, schemaName, tableName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByTableNext(resourceGroupName, serverName, databaseName, schemaName, tableName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByTablePagingAll(resourceGroupName, serverName, databaseName, schemaName, tableName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByTablePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByTablePagingPage(resourceGroupName, serverName, databaseName, schemaName, tableName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List database columns
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$6);
    }
    /**
     * List database columns
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param options The options parameters.
     */
    _listByTable(resourceGroupName, serverName, databaseName, schemaName, tableName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            schemaName,
            tableName,
            options
        }, listByTableOperationSpec);
    }
    /**
     * Get database column
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, schemaName, tableName, columnName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            schemaName,
            tableName,
            columnName,
            options
        }, getOperationSpec$e);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$3);
    }
    /**
     * ListByTableNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param nextLink The nextLink from the previous successful call to the ListByTable method.
     * @param options The options parameters.
     */
    _listByTableNext(resourceGroupName, serverName, databaseName, schemaName, tableName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            schemaName,
            tableName,
            nextLink,
            options
        }, listByTableNextOperationSpec);
    }
}
// Operation Specifications
const serializer$i = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByDatabaseOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/columns",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseColumnListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion2,
        schema,
        table,
        column,
        orderBy,
        skiptoken
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listByTableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/columns",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseColumnListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        schemaName,
        tableName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseColumn
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        schemaName,
        tableName,
        columnName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listByDatabaseNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseColumnListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion2,
        schema,
        table,
        column,
        orderBy,
        skiptoken
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listByTableNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseColumnListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink,
        schemaName,
        tableName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing DatabaseRecommendedActions operations. */
class DatabaseRecommendedActionsImpl {
    /**
     * Initialize a new instance of the class DatabaseRecommendedActions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets list of Database Recommended Actions.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param advisorName The name of the Database Advisor.
     * @param options The options parameters.
     */
    listByDatabaseAdvisor(resourceGroupName, serverName, databaseName, advisorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, advisorName, options }, listByDatabaseAdvisorOperationSpec);
    }
    /**
     * Gets a database recommended action.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param advisorName The name of the Database Advisor.
     * @param recommendedActionName The name of Database Recommended Action.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, advisorName, recommendedActionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            advisorName,
            recommendedActionName,
            options
        }, getOperationSpec$f);
    }
    /**
     * Updates a database recommended action.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param advisorName The name of the Database Advisor.
     * @param recommendedActionName The name of Database Recommended Action.
     * @param parameters The requested recommended action resource state.
     * @param options The options parameters.
     */
    update(resourceGroupName, serverName, databaseName, advisorName, recommendedActionName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            advisorName,
            recommendedActionName,
            parameters,
            options
        }, updateOperationSpec$4);
    }
}
// Operation Specifications
const serializer$j = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByDatabaseAdvisorOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/advisors/{advisorName}/recommendedActions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "RecommendedAction" }
                    }
                }
            }
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        advisorName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const getOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/advisors/{advisorName}/recommendedActions/{recommendedActionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecommendedAction
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        advisorName,
        recommendedActionName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/advisors/{advisorName}/recommendedActions/{recommendedActionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: RecommendedAction
        },
        default: {}
    },
    requestBody: parameters18,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        advisorName,
        recommendedActionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DatabaseSchemas operations. */
class DatabaseSchemasImpl {
    /**
     * Initialize a new instance of the class DatabaseSchemas class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List database schemas
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List database schemas
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$7);
    }
    /**
     * Get database schema
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, schemaName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, schemaName, options }, getOperationSpec$g);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$k = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByDatabaseOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/schemas",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseSchemaListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const getOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/schemas/{schemaName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseSchema
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        schemaName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listByDatabaseNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseSchemaListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DatabaseSecurityAlertPolicies operations. */
class DatabaseSecurityAlertPoliciesImpl {
    /**
     * Initialize a new instance of the class DatabaseSecurityAlertPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of database's security alert policies.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the  server.
     * @param databaseName The name of the  database for which the security alert policy is defined.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a database's security alert policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the  server.
     * @param databaseName The name of the  database for which the security alert policy is defined.
     * @param securityAlertPolicyName The name of the security alert policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, securityAlertPolicyName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            securityAlertPolicyName,
            options
        }, getOperationSpec$h);
    }
    /**
     * Creates or updates a database's security alert policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the  server.
     * @param databaseName The name of the  database for which the security alert policy is defined.
     * @param securityAlertPolicyName The name of the security alert policy.
     * @param parameters The database security alert policy.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, databaseName, securityAlertPolicyName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            securityAlertPolicyName,
            parameters,
            options
        }, createOrUpdateOperationSpec$a);
    }
    /**
     * Gets a list of database's security alert policies.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the  server.
     * @param databaseName The name of the  database for which the security alert policy is defined.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$8);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the  server.
     * @param databaseName The name of the  database for which the security alert policy is defined.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$l = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/securityAlertPolicies/{securityAlertPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseSecurityAlertPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        securityAlertPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const createOrUpdateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/securityAlertPolicies/{securityAlertPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DatabaseSecurityAlertPolicy
        },
        201: {
            bodyMapper: DatabaseSecurityAlertPolicy
        },
        default: {}
    },
    requestBody: parameters19,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        securityAlertPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const listByDatabaseOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/securityAlertPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseSecurityAlertListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listByDatabaseNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseSecurityAlertListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DatabaseTables operations. */
class DatabaseTablesImpl {
    /**
     * Initialize a new instance of the class DatabaseTables class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List database tables
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param options The options parameters.
     */
    listBySchema(resourceGroupName, serverName, databaseName, schemaName, options) {
        const iter = this.listBySchemaPagingAll(resourceGroupName, serverName, databaseName, schemaName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySchemaPagingPage(resourceGroupName, serverName, databaseName, schemaName, options);
            }
        };
    }
    listBySchemaPagingPage(resourceGroupName, serverName, databaseName, schemaName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySchemaPagingPage_1() {
            let result = yield tslib.__await(this._listBySchema(resourceGroupName, serverName, databaseName, schemaName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySchemaNext(resourceGroupName, serverName, databaseName, schemaName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySchemaPagingAll(resourceGroupName, serverName, databaseName, schemaName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySchemaPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySchemaPagingPage(resourceGroupName, serverName, databaseName, schemaName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List database tables
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param options The options parameters.
     */
    _listBySchema(resourceGroupName, serverName, databaseName, schemaName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, schemaName, options }, listBySchemaOperationSpec);
    }
    /**
     * Get database table
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, schemaName, tableName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            schemaName,
            tableName,
            options
        }, getOperationSpec$i);
    }
    /**
     * ListBySchemaNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param nextLink The nextLink from the previous successful call to the ListBySchema method.
     * @param options The options parameters.
     */
    _listBySchemaNext(resourceGroupName, serverName, databaseName, schemaName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            schemaName,
            nextLink,
            options
        }, listBySchemaNextOperationSpec);
    }
}
// Operation Specifications
const serializer$m = coreClient.createSerializer(Mappers, /* isXml */ false);
const listBySchemaOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/schemas/{schemaName}/tables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseTableListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        schemaName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseTable
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        schemaName,
        tableName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listBySchemaNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseTableListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink,
        schemaName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing DatabaseVulnerabilityAssessmentRuleBaselines operations. */
class DatabaseVulnerabilityAssessmentRuleBaselinesImpl {
    /**
     * Initialize a new instance of the class DatabaseVulnerabilityAssessmentRuleBaselines class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a database's vulnerability assessment rule baseline.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database for which the vulnerability assessment rule baseline is
     *                     defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param ruleId The vulnerability assessment rule ID.
     * @param baselineName The name of the vulnerability assessment rule baseline (default implies a
     *                     baseline on a database level rule and master for server level rule).
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, ruleId, baselineName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            vulnerabilityAssessmentName,
            ruleId,
            baselineName,
            options
        }, getOperationSpec$j);
    }
    /**
     * Creates or updates a database's vulnerability assessment rule baseline.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database for which the vulnerability assessment rule baseline is
     *                     defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param ruleId The vulnerability assessment rule ID.
     * @param baselineName The name of the vulnerability assessment rule baseline (default implies a
     *                     baseline on a database level rule and master for server level rule).
     * @param parameters The requested rule baseline resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, ruleId, baselineName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            vulnerabilityAssessmentName,
            ruleId,
            baselineName,
            parameters,
            options
        }, createOrUpdateOperationSpec$b);
    }
    /**
     * Removes the database's vulnerability assessment rule baseline.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database for which the vulnerability assessment rule baseline is
     *                     defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param ruleId The vulnerability assessment rule ID.
     * @param baselineName The name of the vulnerability assessment rule baseline (default implies a
     *                     baseline on a database level rule and master for server level rule).
     * @param options The options parameters.
     */
    delete(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, ruleId, baselineName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            vulnerabilityAssessmentName,
            ruleId,
            baselineName,
            options
        }, deleteOperationSpec$4);
    }
}
// Operation Specifications
const serializer$n = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/rules/{ruleId}/baselines/{baselineName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseVulnerabilityAssessmentRuleBaseline
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        vulnerabilityAssessmentName,
        ruleId,
        baselineName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createOrUpdateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/rules/{ruleId}/baselines/{baselineName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DatabaseVulnerabilityAssessmentRuleBaseline
        },
        default: {}
    },
    requestBody: parameters20,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        vulnerabilityAssessmentName,
        ruleId,
        baselineName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/rules/{ruleId}/baselines/{baselineName}",
    httpMethod: "DELETE",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        vulnerabilityAssessmentName,
        ruleId,
        baselineName
    ],
    serializer: serializer$n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DatabaseVulnerabilityAssessments operations. */
class DatabaseVulnerabilityAssessmentsImpl {
    /**
     * Initialize a new instance of the class DatabaseVulnerabilityAssessments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the vulnerability assessment policies associated with a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database for which the vulnerability assessment policies are
     *                     defined.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the database's vulnerability assessment.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database for which the vulnerability assessment is defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            vulnerabilityAssessmentName,
            options
        }, getOperationSpec$k);
    }
    /**
     * Creates or updates the database's vulnerability assessment.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database for which the vulnerability assessment is defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param parameters The requested resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            vulnerabilityAssessmentName,
            parameters,
            options
        }, createOrUpdateOperationSpec$c);
    }
    /**
     * Removes the database's vulnerability assessment.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database for which the vulnerability assessment is defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            vulnerabilityAssessmentName,
            options
        }, deleteOperationSpec$5);
    }
    /**
     * Lists the vulnerability assessment policies associated with a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database for which the vulnerability assessment policies are
     *                     defined.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$9);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database for which the vulnerability assessment policies are
     *                     defined.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$o = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseVulnerabilityAssessment
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        vulnerabilityAssessmentName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const createOrUpdateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DatabaseVulnerabilityAssessment
        },
        201: {
            bodyMapper: DatabaseVulnerabilityAssessment
        },
        default: {}
    },
    requestBody: parameters21,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        vulnerabilityAssessmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "DELETE",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        vulnerabilityAssessmentName
    ],
    serializer: serializer$o
};
const listByDatabaseOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/vulnerabilityAssessments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseVulnerabilityAssessmentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const listByDatabaseNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseVulnerabilityAssessmentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$o
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DatabaseVulnerabilityAssessmentScans operations. */
class DatabaseVulnerabilityAssessmentScansImpl {
    /**
     * Initialize a new instance of the class DatabaseVulnerabilityAssessmentScans class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the vulnerability assessment scans of a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Executes a Vulnerability Assessment database scan.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param scanId The vulnerability assessment scan Id of the scan to retrieve.
     * @param options The options parameters.
     */
    beginInitiateScan(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, scanId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                vulnerabilityAssessmentName,
                scanId,
                options
            }, initiateScanOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Executes a Vulnerability Assessment database scan.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param scanId The vulnerability assessment scan Id of the scan to retrieve.
     * @param options The options parameters.
     */
    beginInitiateScanAndWait(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, scanId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginInitiateScan(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, scanId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the vulnerability assessment scans of a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            vulnerabilityAssessmentName,
            options
        }, listByDatabaseOperationSpec$a);
    }
    /**
     * Gets a vulnerability assessment scan record of a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param scanId The vulnerability assessment scan Id of the scan to retrieve.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, scanId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            vulnerabilityAssessmentName,
            scanId,
            options
        }, getOperationSpec$l);
    }
    /**
     * Convert an existing scan result to a human readable format. If already exists nothing happens
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the scanned database.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param scanId The vulnerability assessment scan Id.
     * @param options The options parameters.
     */
    export(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, scanId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            vulnerabilityAssessmentName,
            scanId,
            options
        }, exportOperationSpec$1);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, vulnerabilityAssessmentName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            vulnerabilityAssessmentName,
            nextLink,
            options
        }, listByDatabaseNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$p = coreClient.createSerializer(Mappers, /* isXml */ false);
const initiateScanOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/scans/{scanId}/initiateScan",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        vulnerabilityAssessmentName,
        scanId
    ],
    serializer: serializer$p
};
const listByDatabaseOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/scans",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VulnerabilityAssessmentScanRecordListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        vulnerabilityAssessmentName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const getOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/scans/{scanId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VulnerabilityAssessmentScanRecord
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        vulnerabilityAssessmentName,
        scanId
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const exportOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/scans/{scanId}/export",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DatabaseVulnerabilityAssessmentScansExport
        },
        201: {
            bodyMapper: DatabaseVulnerabilityAssessmentScansExport
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        vulnerabilityAssessmentName,
        scanId
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const listByDatabaseNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VulnerabilityAssessmentScanRecordListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink,
        vulnerabilityAssessmentName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DataWarehouseUserActivitiesOperations operations. */
class DataWarehouseUserActivitiesOperationsImpl {
    /**
     * Initialize a new instance of the class DataWarehouseUserActivitiesOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List the user activities of a data warehouse which includes running and suspended queries
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the user activities of a data warehouse which includes running and suspended queries
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param dataWarehouseUserActivityName The activity name of the data warehouse.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, dataWarehouseUserActivityName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            dataWarehouseUserActivityName,
            options
        }, getOperationSpec$m);
    }
    /**
     * List the user activities of a data warehouse which includes running and suspended queries
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$b);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$q = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/dataWarehouseUserActivities/{dataWarehouseUserActivityName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataWarehouseUserActivities
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        dataWarehouseUserActivityName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const listByDatabaseOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/dataWarehouseUserActivities",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataWarehouseUserActivitiesListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const listByDatabaseNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataWarehouseUserActivitiesListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DeletedServers operations. */
class DeletedServersImpl {
    /**
     * Initialize a new instance of the class DeletedServers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all deleted servers in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of deleted servers for a location.
     * @param locationName The name of the region where the resource is located.
     * @param options The options parameters.
     */
    listByLocation(locationName, options) {
        const iter = this.listByLocationPagingAll(locationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByLocationPagingPage(locationName, options);
            }
        };
    }
    listByLocationPagingPage(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingPage_1() {
            let result = yield tslib.__await(this._listByLocation(locationName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByLocationNext(locationName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByLocationPagingAll(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLocationPagingPage(locationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of all deleted servers in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * Gets a deleted server.
     * @param locationName The name of the region where the resource is located.
     * @param deletedServerName The name of the deleted server.
     * @param options The options parameters.
     */
    get(locationName, deletedServerName, options) {
        return this.client.sendOperationRequest({ locationName, deletedServerName, options }, getOperationSpec$n);
    }
    /**
     * Gets a list of deleted servers for a location.
     * @param locationName The name of the region where the resource is located.
     * @param options The options parameters.
     */
    _listByLocation(locationName, options) {
        return this.client.sendOperationRequest({ locationName, options }, listByLocationOperationSpec);
    }
    /**
     * Recovers a deleted server.
     * @param locationName The name of the region where the resource is located.
     * @param deletedServerName The name of the deleted server.
     * @param options The options parameters.
     */
    beginRecover(locationName, deletedServerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { locationName, deletedServerName, options }, recoverOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Recovers a deleted server.
     * @param locationName The name of the region where the resource is located.
     * @param deletedServerName The name of the deleted server.
     * @param options The options parameters.
     */
    beginRecoverAndWait(locationName, deletedServerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRecover(locationName, deletedServerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
    /**
     * ListByLocationNext
     * @param locationName The name of the region where the resource is located.
     * @param nextLink The nextLink from the previous successful call to the ListByLocation method.
     * @param options The options parameters.
     */
    _listByLocationNext(locationName, nextLink, options) {
        return this.client.sendOperationRequest({ locationName, nextLink, options }, listByLocationNextOperationSpec);
    }
}
// Operation Specifications
const serializer$r = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/deletedServers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedServerListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$r
};
const getOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/deletedServers/{deletedServerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedServer
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        locationName,
        deletedServerName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const listByLocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/deletedServers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedServerListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const recoverOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/deletedServers/{deletedServerName}/recover",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeletedServer
        },
        201: {
            bodyMapper: DeletedServer
        },
        202: {
            bodyMapper: DeletedServer
        },
        204: {
            bodyMapper: DeletedServer
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        locationName,
        deletedServerName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedServerListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const listByLocationNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedServerListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ElasticPoolOperations operations. */
class ElasticPoolOperationsImpl {
    /**
     * Initialize a new instance of the class ElasticPoolOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of operations performed on the elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName
     * @param options The options parameters.
     */
    listByElasticPool(resourceGroupName, serverName, elasticPoolName, options) {
        const iter = this.listByElasticPoolPagingAll(resourceGroupName, serverName, elasticPoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByElasticPoolPagingPage(resourceGroupName, serverName, elasticPoolName, options);
            }
        };
    }
    listByElasticPoolPagingPage(resourceGroupName, serverName, elasticPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByElasticPoolPagingPage_1() {
            let result = yield tslib.__await(this._listByElasticPool(resourceGroupName, serverName, elasticPoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByElasticPoolNext(resourceGroupName, serverName, elasticPoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByElasticPoolPagingAll(resourceGroupName, serverName, elasticPoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByElasticPoolPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByElasticPoolPagingPage(resourceGroupName, serverName, elasticPoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Cancels the asynchronous operation on the elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName
     * @param operationId The operation identifier.
     * @param options The options parameters.
     */
    cancel(resourceGroupName, serverName, elasticPoolName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, elasticPoolName, operationId, options }, cancelOperationSpec);
    }
    /**
     * Gets a list of operations performed on the elastic pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName
     * @param options The options parameters.
     */
    _listByElasticPool(resourceGroupName, serverName, elasticPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, elasticPoolName, options }, listByElasticPoolOperationSpec$3);
    }
    /**
     * ListByElasticPoolNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param elasticPoolName
     * @param nextLink The nextLink from the previous successful call to the ListByElasticPool method.
     * @param options The options parameters.
     */
    _listByElasticPoolNext(resourceGroupName, serverName, elasticPoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, elasticPoolName, nextLink, options }, listByElasticPoolNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$s = coreClient.createSerializer(Mappers, /* isXml */ false);
const cancelOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/elasticPools/{elasticPoolName}/operations/{operationId}/cancel",
    httpMethod: "POST",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        elasticPoolName,
        operationId
    ],
    serializer: serializer$s
};
const listByElasticPoolOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/elasticPools/{elasticPoolName}/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ElasticPoolOperationListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        elasticPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};
const listByElasticPoolNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ElasticPoolOperationListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        elasticPoolName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$s
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing EncryptionProtectors operations. */
class EncryptionProtectorsImpl {
    /**
     * Initialize a new instance of the class EncryptionProtectors class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of server encryption protectors
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of server encryption protectors
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$9);
    }
    /**
     * Gets a server encryption protector.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param encryptionProtectorName The name of the encryption protector to be retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, encryptionProtectorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, encryptionProtectorName, options }, getOperationSpec$o);
    }
    /**
     * Updates an existing encryption protector.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param encryptionProtectorName The name of the encryption protector to be updated.
     * @param parameters The requested encryption protector resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, encryptionProtectorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                encryptionProtectorName,
                parameters,
                options
            }, createOrUpdateOperationSpec$d);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates an existing encryption protector.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param encryptionProtectorName The name of the encryption protector to be updated.
     * @param parameters The requested encryption protector resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, encryptionProtectorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, encryptionProtectorName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Revalidates an existing encryption protector.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param encryptionProtectorName The name of the encryption protector to be updated.
     * @param options The options parameters.
     */
    beginRevalidate(resourceGroupName, serverName, encryptionProtectorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, encryptionProtectorName, options }, revalidateOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Revalidates an existing encryption protector.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param encryptionProtectorName The name of the encryption protector to be updated.
     * @param options The options parameters.
     */
    beginRevalidateAndWait(resourceGroupName, serverName, encryptionProtectorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRevalidate(resourceGroupName, serverName, encryptionProtectorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$t = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByServerOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/encryptionProtector",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EncryptionProtectorListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const getOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/encryptionProtector/{encryptionProtectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EncryptionProtector
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        encryptionProtectorName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const createOrUpdateOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/encryptionProtector/{encryptionProtectorName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: EncryptionProtector
        },
        201: {
            bodyMapper: EncryptionProtector
        },
        202: {
            bodyMapper: EncryptionProtector
        },
        204: {
            bodyMapper: EncryptionProtector
        },
        default: {}
    },
    requestBody: parameters22,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        encryptionProtectorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$t
};
const revalidateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/encryptionProtector/{encryptionProtectorName}/revalidate",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        encryptionProtectorName
    ],
    serializer: serializer$t
};
const listByServerNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EncryptionProtectorListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$t
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing FailoverGroups operations. */
class FailoverGroupsImpl {
    /**
     * Initialize a new instance of the class FailoverGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the failover groups in a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server containing the failover group.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a failover group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server containing the failover group.
     * @param failoverGroupName The name of the failover group.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, failoverGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, failoverGroupName, options }, getOperationSpec$p);
    }
    /**
     * Creates or updates a failover group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server containing the failover group.
     * @param failoverGroupName The name of the failover group.
     * @param parameters The failover group parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, failoverGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, failoverGroupName, parameters, options }, createOrUpdateOperationSpec$e);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a failover group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server containing the failover group.
     * @param failoverGroupName The name of the failover group.
     * @param parameters The failover group parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, failoverGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, failoverGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a failover group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server containing the failover group.
     * @param failoverGroupName The name of the failover group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, failoverGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, failoverGroupName, options }, deleteOperationSpec$6);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a failover group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server containing the failover group.
     * @param failoverGroupName The name of the failover group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, failoverGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, failoverGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a failover group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server containing the failover group.
     * @param failoverGroupName The name of the failover group.
     * @param parameters The failover group parameters.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, serverName, failoverGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, failoverGroupName, parameters, options }, updateOperationSpec$5);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a failover group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server containing the failover group.
     * @param failoverGroupName The name of the failover group.
     * @param parameters The failover group parameters.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, serverName, failoverGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, serverName, failoverGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the failover groups in a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server containing the failover group.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$a);
    }
    /**
     * Fails over from the current primary server to this server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server containing the failover group.
     * @param failoverGroupName The name of the failover group.
     * @param options The options parameters.
     */
    beginFailover(resourceGroupName, serverName, failoverGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, failoverGroupName, options }, failoverOperationSpec$3);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Fails over from the current primary server to this server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server containing the failover group.
     * @param failoverGroupName The name of the failover group.
     * @param options The options parameters.
     */
    beginFailoverAndWait(resourceGroupName, serverName, failoverGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginFailover(resourceGroupName, serverName, failoverGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Fails over from the current primary server to this server. This operation might result in data loss.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server containing the failover group.
     * @param failoverGroupName The name of the failover group.
     * @param options The options parameters.
     */
    beginForceFailoverAllowDataLoss(resourceGroupName, serverName, failoverGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, failoverGroupName, options }, forceFailoverAllowDataLossOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Fails over from the current primary server to this server. This operation might result in data loss.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server containing the failover group.
     * @param failoverGroupName The name of the failover group.
     * @param options The options parameters.
     */
    beginForceFailoverAllowDataLossAndWait(resourceGroupName, serverName, failoverGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginForceFailoverAllowDataLoss(resourceGroupName, serverName, failoverGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server containing the failover group.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$u = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/failoverGroups/{failoverGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FailoverGroup
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        failoverGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const createOrUpdateOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/failoverGroups/{failoverGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FailoverGroup
        },
        201: {
            bodyMapper: FailoverGroup
        },
        202: {
            bodyMapper: FailoverGroup
        },
        204: {
            bodyMapper: FailoverGroup
        },
        default: {}
    },
    requestBody: parameters23,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        failoverGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/failoverGroups/{failoverGroupName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        failoverGroupName
    ],
    serializer: serializer$u
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/failoverGroups/{failoverGroupName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: FailoverGroup
        },
        201: {
            bodyMapper: FailoverGroup
        },
        202: {
            bodyMapper: FailoverGroup
        },
        204: {
            bodyMapper: FailoverGroup
        },
        default: {}
    },
    requestBody: parameters24,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        failoverGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u
};
const listByServerOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/failoverGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FailoverGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const failoverOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/failoverGroups/{failoverGroupName}/failover",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FailoverGroup
        },
        201: {
            bodyMapper: FailoverGroup
        },
        202: {
            bodyMapper: FailoverGroup
        },
        204: {
            bodyMapper: FailoverGroup
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        failoverGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const forceFailoverAllowDataLossOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/failoverGroups/{failoverGroupName}/forceFailoverAllowDataLoss",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FailoverGroup
        },
        201: {
            bodyMapper: FailoverGroup
        },
        202: {
            bodyMapper: FailoverGroup
        },
        204: {
            bodyMapper: FailoverGroup
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        failoverGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const listByServerNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FailoverGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$u
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing FirewallRules operations. */
class FirewallRulesImpl {
    /**
     * Initialize a new instance of the class FirewallRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of firewall rules.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a firewall rule.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param firewallRuleName The name of the firewall rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, firewallRuleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, firewallRuleName, options }, getOperationSpec$q);
    }
    /**
     * Creates or updates a firewall rule.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param firewallRuleName The name of the firewall rule.
     * @param parameters The required parameters for creating or updating a firewall rule.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, firewallRuleName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, firewallRuleName, parameters, options }, createOrUpdateOperationSpec$f);
    }
    /**
     * Deletes a firewall rule.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param firewallRuleName The name of the firewall rule.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serverName, firewallRuleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, firewallRuleName, options }, deleteOperationSpec$7);
    }
    /**
     * Gets a list of firewall rules.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$b);
    }
    /**
     * Replaces all firewall rules on the server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param parameters A list of server firewall rules.
     * @param options The options parameters.
     */
    replace(resourceGroupName, serverName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, parameters, options }, replaceOperationSpec);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$v = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/firewallRules/{firewallRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallRule
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        firewallRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const createOrUpdateOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/firewallRules/{firewallRuleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FirewallRule
        },
        201: {
            bodyMapper: FirewallRule
        },
        default: {}
    },
    requestBody: parameters25,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        firewallRuleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$v
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/firewallRules/{firewallRuleName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        firewallRuleName
    ],
    serializer: serializer$v
};
const listByServerOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/firewallRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallRuleListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const replaceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/firewallRules",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FirewallRule
        },
        202: {},
        default: {}
    },
    requestBody: parameters26,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$v
};
const listByServerNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallRuleListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$v
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing InstanceFailoverGroups operations. */
class InstanceFailoverGroupsImpl {
    /**
     * Initialize a new instance of the class InstanceFailoverGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the failover groups in a location.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param options The options parameters.
     */
    listByLocation(resourceGroupName, locationName, options) {
        const iter = this.listByLocationPagingAll(resourceGroupName, locationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByLocationPagingPage(resourceGroupName, locationName, options);
            }
        };
    }
    listByLocationPagingPage(resourceGroupName, locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingPage_1() {
            let result = yield tslib.__await(this._listByLocation(resourceGroupName, locationName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByLocationNext(resourceGroupName, locationName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByLocationPagingAll(resourceGroupName, locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLocationPagingPage(resourceGroupName, locationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a failover group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param failoverGroupName The name of the failover group.
     * @param options The options parameters.
     */
    get(resourceGroupName, locationName, failoverGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, locationName, failoverGroupName, options }, getOperationSpec$r);
    }
    /**
     * Creates or updates a failover group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param failoverGroupName The name of the failover group.
     * @param parameters The failover group parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, locationName, failoverGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                locationName,
                failoverGroupName,
                parameters,
                options
            }, createOrUpdateOperationSpec$g);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a failover group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param failoverGroupName The name of the failover group.
     * @param parameters The failover group parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, locationName, failoverGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, locationName, failoverGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a failover group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param failoverGroupName The name of the failover group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, locationName, failoverGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, locationName, failoverGroupName, options }, deleteOperationSpec$8);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a failover group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param failoverGroupName The name of the failover group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, locationName, failoverGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, locationName, failoverGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the failover groups in a location.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param options The options parameters.
     */
    _listByLocation(resourceGroupName, locationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, locationName, options }, listByLocationOperationSpec$1);
    }
    /**
     * Fails over from the current primary managed instance to this managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param failoverGroupName The name of the failover group.
     * @param options The options parameters.
     */
    beginFailover(resourceGroupName, locationName, failoverGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, locationName, failoverGroupName, options }, failoverOperationSpec$4);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Fails over from the current primary managed instance to this managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param failoverGroupName The name of the failover group.
     * @param options The options parameters.
     */
    beginFailoverAndWait(resourceGroupName, locationName, failoverGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginFailover(resourceGroupName, locationName, failoverGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Fails over from the current primary managed instance to this managed instance. This operation might
     * result in data loss.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param failoverGroupName The name of the failover group.
     * @param options The options parameters.
     */
    beginForceFailoverAllowDataLoss(resourceGroupName, locationName, failoverGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, locationName, failoverGroupName, options }, forceFailoverAllowDataLossOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Fails over from the current primary managed instance to this managed instance. This operation might
     * result in data loss.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param failoverGroupName The name of the failover group.
     * @param options The options parameters.
     */
    beginForceFailoverAllowDataLossAndWait(resourceGroupName, locationName, failoverGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginForceFailoverAllowDataLoss(resourceGroupName, locationName, failoverGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByLocationNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param nextLink The nextLink from the previous successful call to the ListByLocation method.
     * @param options The options parameters.
     */
    _listByLocationNext(resourceGroupName, locationName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, locationName, nextLink, options }, listByLocationNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$w = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/instanceFailoverGroups/{failoverGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InstanceFailoverGroup
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName,
        failoverGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const createOrUpdateOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/instanceFailoverGroups/{failoverGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: InstanceFailoverGroup
        },
        201: {
            bodyMapper: InstanceFailoverGroup
        },
        202: {
            bodyMapper: InstanceFailoverGroup
        },
        204: {
            bodyMapper: InstanceFailoverGroup
        },
        default: {}
    },
    requestBody: parameters27,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName,
        failoverGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/instanceFailoverGroups/{failoverGroupName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName,
        failoverGroupName
    ],
    serializer: serializer$w
};
const listByLocationOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/instanceFailoverGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InstanceFailoverGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const failoverOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/instanceFailoverGroups/{failoverGroupName}/failover",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: InstanceFailoverGroup
        },
        201: {
            bodyMapper: InstanceFailoverGroup
        },
        202: {
            bodyMapper: InstanceFailoverGroup
        },
        204: {
            bodyMapper: InstanceFailoverGroup
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName,
        failoverGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const forceFailoverAllowDataLossOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/instanceFailoverGroups/{failoverGroupName}/forceFailoverAllowDataLoss",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: InstanceFailoverGroup
        },
        201: {
            bodyMapper: InstanceFailoverGroup
        },
        202: {
            bodyMapper: InstanceFailoverGroup
        },
        204: {
            bodyMapper: InstanceFailoverGroup
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName,
        failoverGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const listByLocationNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InstanceFailoverGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing InstancePools operations. */
class InstancePoolsImpl {
    /**
     * Initialize a new instance of the class InstancePools class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of instance pools in the resource group
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of all instance pools in the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets an instance pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param instancePoolName The name of the instance pool to be retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, instancePoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, instancePoolName, options }, getOperationSpec$s);
    }
    /**
     * Creates or updates an instance pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param instancePoolName The name of the instance pool to be created or updated.
     * @param parameters The requested instance pool resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, instancePoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, instancePoolName, parameters, options }, createOrUpdateOperationSpec$h);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates an instance pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param instancePoolName The name of the instance pool to be created or updated.
     * @param parameters The requested instance pool resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, instancePoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, instancePoolName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an instance pool
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param instancePoolName The name of the instance pool to be deleted
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, instancePoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, instancePoolName, options }, deleteOperationSpec$9);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes an instance pool
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param instancePoolName The name of the instance pool to be deleted
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, instancePoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, instancePoolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an instance pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param instancePoolName The name of the instance pool to be updated.
     * @param parameters The requested instance pool resource state.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, instancePoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, instancePoolName, parameters, options }, updateOperationSpec$6);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates an instance pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param instancePoolName The name of the instance pool to be updated.
     * @param parameters The requested instance pool resource state.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, instancePoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, instancePoolName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of instance pools in the resource group
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Gets a list of all instance pools in the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$x = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/instancePools/{instancePoolName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InstancePool
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        instancePoolName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const createOrUpdateOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/instancePools/{instancePoolName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: InstancePool
        },
        201: {
            bodyMapper: InstancePool
        },
        202: {
            bodyMapper: InstancePool
        },
        204: {
            bodyMapper: InstancePool
        },
        default: {}
    },
    requestBody: parameters28,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        instancePoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$x
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/instancePools/{instancePoolName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        instancePoolName
    ],
    serializer: serializer$x
};
const updateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/instancePools/{instancePoolName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: InstancePool
        },
        201: {
            bodyMapper: InstancePool
        },
        202: {
            bodyMapper: InstancePool
        },
        204: {
            bodyMapper: InstancePool
        },
        default: {}
    },
    requestBody: parameters29,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        instancePoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$x
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/instancePools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InstancePoolListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/instancePools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InstancePoolListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$x
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InstancePoolListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InstancePoolListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$x
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing JobAgents operations. */
class JobAgentsImpl {
    /**
     * Initialize a new instance of the class JobAgents class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of job agents in a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of job agents in a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$c);
    }
    /**
     * Gets a job agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent to be retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, jobAgentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, options }, getOperationSpec$t);
    }
    /**
     * Creates or updates a job agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent to be created or updated.
     * @param parameters The requested job agent resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, jobAgentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, jobAgentName, parameters, options }, createOrUpdateOperationSpec$i);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a job agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent to be created or updated.
     * @param parameters The requested job agent resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, jobAgentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, jobAgentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a job agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent to be deleted.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, jobAgentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, jobAgentName, options }, deleteOperationSpec$a);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a job agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent to be deleted.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, jobAgentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, jobAgentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a job agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent to be updated.
     * @param parameters The update to the job agent.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, serverName, jobAgentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, jobAgentName, parameters, options }, updateOperationSpec$7);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a job agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent to be updated.
     * @param parameters The update to the job agent.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, serverName, jobAgentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, serverName, jobAgentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$y = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByServerOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobAgentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const getOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobAgent
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const createOrUpdateOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: JobAgent
        },
        201: {
            bodyMapper: JobAgent
        },
        202: {
            bodyMapper: JobAgent
        },
        204: {
            bodyMapper: JobAgent
        },
        default: {}
    },
    requestBody: parameters30,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$y
};
const deleteOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName
    ],
    serializer: serializer$y
};
const updateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: JobAgent
        },
        201: {
            bodyMapper: JobAgent
        },
        202: {
            bodyMapper: JobAgent
        },
        204: {
            bodyMapper: JobAgent
        },
        default: {}
    },
    requestBody: parameters31,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$y
};
const listByServerNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobAgentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing JobCredentials operations. */
class JobCredentialsImpl {
    /**
     * Initialize a new instance of the class JobCredentials class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of jobs credentials.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param options The options parameters.
     */
    listByAgent(resourceGroupName, serverName, jobAgentName, options) {
        const iter = this.listByAgentPagingAll(resourceGroupName, serverName, jobAgentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByAgentPagingPage(resourceGroupName, serverName, jobAgentName, options);
            }
        };
    }
    listByAgentPagingPage(resourceGroupName, serverName, jobAgentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByAgentPagingPage_1() {
            let result = yield tslib.__await(this._listByAgent(resourceGroupName, serverName, jobAgentName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByAgentNext(resourceGroupName, serverName, jobAgentName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByAgentPagingAll(resourceGroupName, serverName, jobAgentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByAgentPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByAgentPagingPage(resourceGroupName, serverName, jobAgentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of jobs credentials.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param options The options parameters.
     */
    _listByAgent(resourceGroupName, serverName, jobAgentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, options }, listByAgentOperationSpec);
    }
    /**
     * Gets a jobs credential.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param credentialName The name of the credential.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, jobAgentName, credentialName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, credentialName, options }, getOperationSpec$u);
    }
    /**
     * Creates or updates a job credential.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param credentialName The name of the credential.
     * @param parameters The requested job credential state.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, jobAgentName, credentialName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            credentialName,
            parameters,
            options
        }, createOrUpdateOperationSpec$j);
    }
    /**
     * Deletes a job credential.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param credentialName The name of the credential.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serverName, jobAgentName, credentialName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, credentialName, options }, deleteOperationSpec$b);
    }
    /**
     * ListByAgentNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param nextLink The nextLink from the previous successful call to the ListByAgent method.
     * @param options The options parameters.
     */
    _listByAgentNext(resourceGroupName, serverName, jobAgentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, nextLink, options }, listByAgentNextOperationSpec);
    }
}
// Operation Specifications
const serializer$z = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByAgentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/credentials",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobCredentialListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const getOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/credentials/{credentialName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobCredential
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        credentialName
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const createOrUpdateOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/credentials/{credentialName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: JobCredential
        },
        201: {
            bodyMapper: JobCredential
        },
        default: {}
    },
    requestBody: parameters32,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        credentialName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$z
};
const deleteOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/credentials/{credentialName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        credentialName
    ],
    serializer: serializer$z
};
const listByAgentNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobCredentialListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink,
        jobAgentName
    ],
    headerParameters: [accept],
    serializer: serializer$z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing JobExecutions operations. */
class JobExecutionsImpl {
    /**
     * Initialize a new instance of the class JobExecutions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all executions in a job agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param options The options parameters.
     */
    listByAgent(resourceGroupName, serverName, jobAgentName, options) {
        const iter = this.listByAgentPagingAll(resourceGroupName, serverName, jobAgentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByAgentPagingPage(resourceGroupName, serverName, jobAgentName, options);
            }
        };
    }
    listByAgentPagingPage(resourceGroupName, serverName, jobAgentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByAgentPagingPage_1() {
            let result = yield tslib.__await(this._listByAgent(resourceGroupName, serverName, jobAgentName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByAgentNext(resourceGroupName, serverName, jobAgentName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByAgentPagingAll(resourceGroupName, serverName, jobAgentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByAgentPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByAgentPagingPage(resourceGroupName, serverName, jobAgentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a job's executions.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param options The options parameters.
     */
    listByJob(resourceGroupName, serverName, jobAgentName, jobName, options) {
        const iter = this.listByJobPagingAll(resourceGroupName, serverName, jobAgentName, jobName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByJobPagingPage(resourceGroupName, serverName, jobAgentName, jobName, options);
            }
        };
    }
    listByJobPagingPage(resourceGroupName, serverName, jobAgentName, jobName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByJobPagingPage_1() {
            let result = yield tslib.__await(this._listByJob(resourceGroupName, serverName, jobAgentName, jobName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByJobNext(resourceGroupName, serverName, jobAgentName, jobName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByJobPagingAll(resourceGroupName, serverName, jobAgentName, jobName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByJobPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByJobPagingPage(resourceGroupName, serverName, jobAgentName, jobName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all executions in a job agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param options The options parameters.
     */
    _listByAgent(resourceGroupName, serverName, jobAgentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, options }, listByAgentOperationSpec$1);
    }
    /**
     * Requests cancellation of a job execution.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job.
     * @param jobExecutionId The id of the job execution to cancel.
     * @param options The options parameters.
     */
    cancel(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            jobExecutionId,
            options
        }, cancelOperationSpec$1);
    }
    /**
     * Starts an elastic job execution.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, serverName, jobAgentName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, jobAgentName, jobName, options }, createOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Starts an elastic job execution.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, serverName, jobAgentName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, serverName, jobAgentName, jobName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists a job's executions.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param options The options parameters.
     */
    _listByJob(resourceGroupName, serverName, jobAgentName, jobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, jobName, options }, listByJobOperationSpec);
    }
    /**
     * Gets a job execution.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job.
     * @param jobExecutionId The id of the job execution
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            jobExecutionId,
            options
        }, getOperationSpec$v);
    }
    /**
     * Creates or updates a job execution.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobExecutionId The job execution id to create the job execution under.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                jobAgentName,
                jobName,
                jobExecutionId,
                options
            }, createOrUpdateOperationSpec$k);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a job execution.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobExecutionId The job execution id to create the job execution under.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByAgentNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param nextLink The nextLink from the previous successful call to the ListByAgent method.
     * @param options The options parameters.
     */
    _listByAgentNext(resourceGroupName, serverName, jobAgentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, nextLink, options }, listByAgentNextOperationSpec$1);
    }
    /**
     * ListByJobNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param nextLink The nextLink from the previous successful call to the ListByJob method.
     * @param options The options parameters.
     */
    _listByJobNext(resourceGroupName, serverName, jobAgentName, jobName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            nextLink,
            options
        }, listByJobNextOperationSpec);
    }
}
// Operation Specifications
const serializer$A = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByAgentOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/executions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobExecutionListResult
        },
        default: {}
    },
    queryParameters: [
        skip,
        apiVersion2,
        createTimeMin,
        createTimeMax,
        endTimeMin,
        endTimeMax,
        isActive,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const cancelOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/executions/{jobExecutionId}/cancel",
    httpMethod: "POST",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName,
        jobExecutionId
    ],
    serializer: serializer$A
};
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/start",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: JobExecution
        },
        201: {
            bodyMapper: JobExecution
        },
        202: {
            bodyMapper: JobExecution
        },
        204: {
            bodyMapper: JobExecution
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const listByJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/executions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobExecutionListResult
        },
        default: {}
    },
    queryParameters: [
        skip,
        apiVersion2,
        createTimeMin,
        createTimeMax,
        endTimeMin,
        endTimeMax,
        isActive,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const getOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/executions/{jobExecutionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobExecution
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName,
        jobExecutionId
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const createOrUpdateOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/executions/{jobExecutionId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: JobExecution
        },
        201: {
            bodyMapper: JobExecution
        },
        202: {
            bodyMapper: JobExecution
        },
        204: {
            bodyMapper: JobExecution
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName,
        jobExecutionId
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const listByAgentNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobExecutionListResult
        },
        default: {}
    },
    queryParameters: [
        skip,
        apiVersion2,
        createTimeMin,
        createTimeMax,
        endTimeMin,
        endTimeMax,
        isActive,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink,
        jobAgentName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const listByJobNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobExecutionListResult
        },
        default: {}
    },
    queryParameters: [
        skip,
        apiVersion2,
        createTimeMin,
        createTimeMax,
        endTimeMin,
        endTimeMax,
        isActive,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink,
        jobAgentName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Jobs operations. */
class JobsImpl {
    /**
     * Initialize a new instance of the class Jobs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of jobs.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param options The options parameters.
     */
    listByAgent(resourceGroupName, serverName, jobAgentName, options) {
        const iter = this.listByAgentPagingAll(resourceGroupName, serverName, jobAgentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByAgentPagingPage(resourceGroupName, serverName, jobAgentName, options);
            }
        };
    }
    listByAgentPagingPage(resourceGroupName, serverName, jobAgentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByAgentPagingPage_1() {
            let result = yield tslib.__await(this._listByAgent(resourceGroupName, serverName, jobAgentName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByAgentNext(resourceGroupName, serverName, jobAgentName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByAgentPagingAll(resourceGroupName, serverName, jobAgentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByAgentPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByAgentPagingPage(resourceGroupName, serverName, jobAgentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of jobs.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param options The options parameters.
     */
    _listByAgent(resourceGroupName, serverName, jobAgentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, options }, listByAgentOperationSpec$2);
    }
    /**
     * Gets a job.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, jobAgentName, jobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, jobName, options }, getOperationSpec$w);
    }
    /**
     * Creates or updates a job.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param parameters The requested job state.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, jobAgentName, jobName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            parameters,
            options
        }, createOrUpdateOperationSpec$l);
    }
    /**
     * Deletes a job.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to delete.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serverName, jobAgentName, jobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, jobName, options }, deleteOperationSpec$c);
    }
    /**
     * ListByAgentNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param nextLink The nextLink from the previous successful call to the ListByAgent method.
     * @param options The options parameters.
     */
    _listByAgentNext(resourceGroupName, serverName, jobAgentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, nextLink, options }, listByAgentNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$B = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByAgentOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const getOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Job
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const createOrUpdateOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Job
        },
        201: {
            bodyMapper: Job
        },
        default: {}
    },
    requestBody: parameters33,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$B
};
const deleteOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName
    ],
    serializer: serializer$B
};
const listByAgentNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink,
        jobAgentName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing JobStepExecutions operations. */
class JobStepExecutionsImpl {
    /**
     * Initialize a new instance of the class JobStepExecutions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the step executions of a job execution.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobExecutionId The id of the job execution
     * @param options The options parameters.
     */
    listByJobExecution(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options) {
        const iter = this.listByJobExecutionPagingAll(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByJobExecutionPagingPage(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options);
            }
        };
    }
    listByJobExecutionPagingPage(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByJobExecutionPagingPage_1() {
            let result = yield tslib.__await(this._listByJobExecution(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByJobExecutionNext(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByJobExecutionPagingAll(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByJobExecutionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByJobExecutionPagingPage(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the step executions of a job execution.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobExecutionId The id of the job execution
     * @param options The options parameters.
     */
    _listByJobExecution(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            jobExecutionId,
            options
        }, listByJobExecutionOperationSpec);
    }
    /**
     * Gets a step execution of a job execution.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobExecutionId The unique id of the job execution
     * @param stepName The name of the step.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, stepName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            jobExecutionId,
            stepName,
            options
        }, getOperationSpec$x);
    }
    /**
     * ListByJobExecutionNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobExecutionId The id of the job execution
     * @param nextLink The nextLink from the previous successful call to the ListByJobExecution method.
     * @param options The options parameters.
     */
    _listByJobExecutionNext(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            jobExecutionId,
            nextLink,
            options
        }, listByJobExecutionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$C = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByJobExecutionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/executions/{jobExecutionId}/steps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobExecutionListResult
        },
        default: {}
    },
    queryParameters: [
        skip,
        apiVersion2,
        createTimeMin,
        createTimeMax,
        endTimeMin,
        endTimeMax,
        isActive,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName,
        jobExecutionId
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const getOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/executions/{jobExecutionId}/steps/{stepName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobExecution
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName,
        jobExecutionId,
        stepName
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const listByJobExecutionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobExecutionListResult
        },
        default: {}
    },
    queryParameters: [
        skip,
        apiVersion2,
        createTimeMin,
        createTimeMax,
        endTimeMin,
        endTimeMax,
        isActive,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink,
        jobAgentName,
        jobName,
        jobExecutionId
    ],
    headerParameters: [accept],
    serializer: serializer$C
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing JobSteps operations. */
class JobStepsImpl {
    /**
     * Initialize a new instance of the class JobSteps class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all job steps in the specified job version.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobVersion The version of the job to get.
     * @param options The options parameters.
     */
    listByVersion(resourceGroupName, serverName, jobAgentName, jobName, jobVersion, options) {
        const iter = this.listByVersionPagingAll(resourceGroupName, serverName, jobAgentName, jobName, jobVersion, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByVersionPagingPage(resourceGroupName, serverName, jobAgentName, jobName, jobVersion, options);
            }
        };
    }
    listByVersionPagingPage(resourceGroupName, serverName, jobAgentName, jobName, jobVersion, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVersionPagingPage_1() {
            let result = yield tslib.__await(this._listByVersion(resourceGroupName, serverName, jobAgentName, jobName, jobVersion, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByVersionNext(resourceGroupName, serverName, jobAgentName, jobName, jobVersion, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByVersionPagingAll(resourceGroupName, serverName, jobAgentName, jobName, jobVersion, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVersionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByVersionPagingPage(resourceGroupName, serverName, jobAgentName, jobName, jobVersion, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all job steps for a job's current version.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param options The options parameters.
     */
    listByJob(resourceGroupName, serverName, jobAgentName, jobName, options) {
        const iter = this.listByJobPagingAll(resourceGroupName, serverName, jobAgentName, jobName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByJobPagingPage(resourceGroupName, serverName, jobAgentName, jobName, options);
            }
        };
    }
    listByJobPagingPage(resourceGroupName, serverName, jobAgentName, jobName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByJobPagingPage_1() {
            let result = yield tslib.__await(this._listByJob(resourceGroupName, serverName, jobAgentName, jobName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByJobNext(resourceGroupName, serverName, jobAgentName, jobName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByJobPagingAll(resourceGroupName, serverName, jobAgentName, jobName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByJobPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByJobPagingPage(resourceGroupName, serverName, jobAgentName, jobName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets all job steps in the specified job version.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobVersion The version of the job to get.
     * @param options The options parameters.
     */
    _listByVersion(resourceGroupName, serverName, jobAgentName, jobName, jobVersion, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            jobVersion,
            options
        }, listByVersionOperationSpec);
    }
    /**
     * Gets the specified version of a job step.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job.
     * @param jobVersion The version of the job to get.
     * @param stepName The name of the job step.
     * @param options The options parameters.
     */
    getByVersion(resourceGroupName, serverName, jobAgentName, jobName, jobVersion, stepName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            jobVersion,
            stepName,
            options
        }, getByVersionOperationSpec);
    }
    /**
     * Gets all job steps for a job's current version.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param options The options parameters.
     */
    _listByJob(resourceGroupName, serverName, jobAgentName, jobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, jobName, options }, listByJobOperationSpec$1);
    }
    /**
     * Gets a job step in a job's current version.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job.
     * @param stepName The name of the job step.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, jobAgentName, jobName, stepName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            stepName,
            options
        }, getOperationSpec$y);
    }
    /**
     * Creates or updates a job step. This will implicitly create a new job version.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job.
     * @param stepName The name of the job step.
     * @param parameters The requested state of the job step.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, jobAgentName, jobName, stepName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            stepName,
            parameters,
            options
        }, createOrUpdateOperationSpec$m);
    }
    /**
     * Deletes a job step. This will implicitly create a new job version.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job.
     * @param stepName The name of the job step to delete.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serverName, jobAgentName, jobName, stepName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            stepName,
            options
        }, deleteOperationSpec$d);
    }
    /**
     * ListByVersionNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobVersion The version of the job to get.
     * @param nextLink The nextLink from the previous successful call to the ListByVersion method.
     * @param options The options parameters.
     */
    _listByVersionNext(resourceGroupName, serverName, jobAgentName, jobName, jobVersion, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            jobVersion,
            nextLink,
            options
        }, listByVersionNextOperationSpec);
    }
    /**
     * ListByJobNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param nextLink The nextLink from the previous successful call to the ListByJob method.
     * @param options The options parameters.
     */
    _listByJobNext(resourceGroupName, serverName, jobAgentName, jobName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            nextLink,
            options
        }, listByJobNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$D = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByVersionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/versions/{jobVersion}/steps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobStepListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName,
        jobVersion
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const getByVersionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/versions/{jobVersion}/steps/{stepName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobStep
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName,
        stepName,
        jobVersion
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const listByJobOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/steps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobStepListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const getOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/steps/{stepName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobStep
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName,
        stepName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const createOrUpdateOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/steps/{stepName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: JobStep
        },
        201: {
            bodyMapper: JobStep
        },
        default: {}
    },
    requestBody: parameters34,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName,
        stepName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$D
};
const deleteOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/steps/{stepName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName,
        stepName
    ],
    serializer: serializer$D
};
const listByVersionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobStepListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink,
        jobAgentName,
        jobName,
        jobVersion
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const listByJobNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobStepListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink,
        jobAgentName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing JobTargetExecutions operations. */
class JobTargetExecutionsImpl {
    /**
     * Initialize a new instance of the class JobTargetExecutions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists target executions for all steps of a job execution.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobExecutionId The id of the job execution
     * @param options The options parameters.
     */
    listByJobExecution(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options) {
        const iter = this.listByJobExecutionPagingAll(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByJobExecutionPagingPage(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options);
            }
        };
    }
    listByJobExecutionPagingPage(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByJobExecutionPagingPage_1() {
            let result = yield tslib.__await(this._listByJobExecution(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByJobExecutionNext(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByJobExecutionPagingAll(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByJobExecutionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByJobExecutionPagingPage(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the target executions of a job step execution.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobExecutionId The id of the job execution
     * @param stepName The name of the step.
     * @param options The options parameters.
     */
    listByStep(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, stepName, options) {
        const iter = this.listByStepPagingAll(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, stepName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByStepPagingPage(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, stepName, options);
            }
        };
    }
    listByStepPagingPage(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, stepName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByStepPagingPage_1() {
            let result = yield tslib.__await(this._listByStep(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, stepName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByStepNext(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, stepName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByStepPagingAll(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, stepName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByStepPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByStepPagingPage(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, stepName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists target executions for all steps of a job execution.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobExecutionId The id of the job execution
     * @param options The options parameters.
     */
    _listByJobExecution(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            jobExecutionId,
            options
        }, listByJobExecutionOperationSpec$1);
    }
    /**
     * Lists the target executions of a job step execution.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobExecutionId The id of the job execution
     * @param stepName The name of the step.
     * @param options The options parameters.
     */
    _listByStep(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, stepName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            jobExecutionId,
            stepName,
            options
        }, listByStepOperationSpec);
    }
    /**
     * Gets a target execution.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobExecutionId The unique id of the job execution
     * @param stepName The name of the step.
     * @param targetId The target id.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, stepName, targetId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            jobExecutionId,
            stepName,
            targetId,
            options
        }, getOperationSpec$z);
    }
    /**
     * ListByJobExecutionNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobExecutionId The id of the job execution
     * @param nextLink The nextLink from the previous successful call to the ListByJobExecution method.
     * @param options The options parameters.
     */
    _listByJobExecutionNext(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            jobExecutionId,
            nextLink,
            options
        }, listByJobExecutionNextOperationSpec$1);
    }
    /**
     * ListByStepNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param jobExecutionId The id of the job execution
     * @param stepName The name of the step.
     * @param nextLink The nextLink from the previous successful call to the ListByStep method.
     * @param options The options parameters.
     */
    _listByStepNext(resourceGroupName, serverName, jobAgentName, jobName, jobExecutionId, stepName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            jobExecutionId,
            stepName,
            nextLink,
            options
        }, listByStepNextOperationSpec);
    }
}
// Operation Specifications
const serializer$E = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByJobExecutionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/executions/{jobExecutionId}/targets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobExecutionListResult
        },
        default: {}
    },
    queryParameters: [
        skip,
        apiVersion2,
        createTimeMin,
        createTimeMax,
        endTimeMin,
        endTimeMax,
        isActive,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName,
        jobExecutionId
    ],
    headerParameters: [accept],
    serializer: serializer$E
};
const listByStepOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/executions/{jobExecutionId}/steps/{stepName}/targets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobExecutionListResult
        },
        default: {}
    },
    queryParameters: [
        skip,
        apiVersion2,
        createTimeMin,
        createTimeMax,
        endTimeMin,
        endTimeMax,
        isActive,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName,
        jobExecutionId,
        stepName
    ],
    headerParameters: [accept],
    serializer: serializer$E
};
const getOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/executions/{jobExecutionId}/steps/{stepName}/targets/{targetId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobExecution
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName,
        jobExecutionId,
        stepName,
        targetId
    ],
    headerParameters: [accept],
    serializer: serializer$E
};
const listByJobExecutionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobExecutionListResult
        },
        default: {}
    },
    queryParameters: [
        skip,
        apiVersion2,
        createTimeMin,
        createTimeMax,
        endTimeMin,
        endTimeMax,
        isActive,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink,
        jobAgentName,
        jobName,
        jobExecutionId
    ],
    headerParameters: [accept],
    serializer: serializer$E
};
const listByStepNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobExecutionListResult
        },
        default: {}
    },
    queryParameters: [
        skip,
        apiVersion2,
        createTimeMin,
        createTimeMax,
        endTimeMin,
        endTimeMax,
        isActive,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink,
        jobAgentName,
        jobName,
        jobExecutionId,
        stepName
    ],
    headerParameters: [accept],
    serializer: serializer$E
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing JobTargetGroups operations. */
class JobTargetGroupsImpl {
    /**
     * Initialize a new instance of the class JobTargetGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all target groups in an agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param options The options parameters.
     */
    listByAgent(resourceGroupName, serverName, jobAgentName, options) {
        const iter = this.listByAgentPagingAll(resourceGroupName, serverName, jobAgentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByAgentPagingPage(resourceGroupName, serverName, jobAgentName, options);
            }
        };
    }
    listByAgentPagingPage(resourceGroupName, serverName, jobAgentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByAgentPagingPage_1() {
            let result = yield tslib.__await(this._listByAgent(resourceGroupName, serverName, jobAgentName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByAgentNext(resourceGroupName, serverName, jobAgentName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByAgentPagingAll(resourceGroupName, serverName, jobAgentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByAgentPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByAgentPagingPage(resourceGroupName, serverName, jobAgentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all target groups in an agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param options The options parameters.
     */
    _listByAgent(resourceGroupName, serverName, jobAgentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, options }, listByAgentOperationSpec$3);
    }
    /**
     * Gets a target group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param targetGroupName The name of the target group.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, jobAgentName, targetGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, targetGroupName, options }, getOperationSpec$A);
    }
    /**
     * Creates or updates a target group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param targetGroupName The name of the target group.
     * @param parameters The requested state of the target group.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, jobAgentName, targetGroupName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            targetGroupName,
            parameters,
            options
        }, createOrUpdateOperationSpec$n);
    }
    /**
     * Deletes a target group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param targetGroupName The name of the target group.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serverName, jobAgentName, targetGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, targetGroupName, options }, deleteOperationSpec$e);
    }
    /**
     * ListByAgentNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param nextLink The nextLink from the previous successful call to the ListByAgent method.
     * @param options The options parameters.
     */
    _listByAgentNext(resourceGroupName, serverName, jobAgentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, nextLink, options }, listByAgentNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$F = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByAgentOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/targetGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobTargetGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const getOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/targetGroups/{targetGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobTargetGroup
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        targetGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const createOrUpdateOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/targetGroups/{targetGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: JobTargetGroup
        },
        201: {
            bodyMapper: JobTargetGroup
        },
        default: {}
    },
    requestBody: parameters35,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        targetGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$F
};
const deleteOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/targetGroups/{targetGroupName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        targetGroupName
    ],
    serializer: serializer$F
};
const listByAgentNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobTargetGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink,
        jobAgentName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing JobVersions operations. */
class JobVersionsImpl {
    /**
     * Initialize a new instance of the class JobVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all versions of a job.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param options The options parameters.
     */
    listByJob(resourceGroupName, serverName, jobAgentName, jobName, options) {
        const iter = this.listByJobPagingAll(resourceGroupName, serverName, jobAgentName, jobName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByJobPagingPage(resourceGroupName, serverName, jobAgentName, jobName, options);
            }
        };
    }
    listByJobPagingPage(resourceGroupName, serverName, jobAgentName, jobName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByJobPagingPage_1() {
            let result = yield tslib.__await(this._listByJob(resourceGroupName, serverName, jobAgentName, jobName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByJobNext(resourceGroupName, serverName, jobAgentName, jobName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByJobPagingAll(resourceGroupName, serverName, jobAgentName, jobName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByJobPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByJobPagingPage(resourceGroupName, serverName, jobAgentName, jobName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all versions of a job.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param options The options parameters.
     */
    _listByJob(resourceGroupName, serverName, jobAgentName, jobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, jobAgentName, jobName, options }, listByJobOperationSpec$2);
    }
    /**
     * Gets a job version.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job.
     * @param jobVersion The version of the job to get.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, jobAgentName, jobName, jobVersion, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            jobVersion,
            options
        }, getOperationSpec$B);
    }
    /**
     * ListByJobNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param jobAgentName The name of the job agent.
     * @param jobName The name of the job to get.
     * @param nextLink The nextLink from the previous successful call to the ListByJob method.
     * @param options The options parameters.
     */
    _listByJobNext(resourceGroupName, serverName, jobAgentName, jobName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            jobAgentName,
            jobName,
            nextLink,
            options
        }, listByJobNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$G = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByJobOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobVersionListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const getOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/jobAgents/{jobAgentName}/jobs/{jobName}/versions/{jobVersion}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobVersion
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        jobAgentName,
        jobName,
        jobVersion
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const listByJobNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobVersionListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink,
        jobAgentName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$G
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Capabilities operations. */
class CapabilitiesImpl {
    /**
     * Initialize a new instance of the class Capabilities class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the subscription capabilities available for the specified location.
     * @param locationName The location name whose capabilities are retrieved.
     * @param options The options parameters.
     */
    listByLocation(locationName, options) {
        return this.client.sendOperationRequest({ locationName, options }, listByLocationOperationSpec$2);
    }
}
// Operation Specifications
const serializer$H = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByLocationOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/capabilities",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LocationCapabilities
        },
        default: {}
    },
    queryParameters: [apiVersion2, include],
    urlParameters: [
        $host,
        subscriptionId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$H
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LongTermRetentionPolicies operations. */
class LongTermRetentionPoliciesImpl {
    /**
     * Initialize a new instance of the class LongTermRetentionPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a database's long term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a database's long term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param policyName The policy name. Should always be Default.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, policyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, policyName, options }, getOperationSpec$C);
    }
    /**
     * Sets a database's long term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param policyName The policy name. Should always be Default.
     * @param parameters The long term retention policy info.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, databaseName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                policyName,
                parameters,
                options
            }, createOrUpdateOperationSpec$o);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Sets a database's long term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param policyName The policy name. Should always be Default.
     * @param parameters The long term retention policy info.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, databaseName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, databaseName, policyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a database's long term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$c);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$I = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/backupLongTermRetentionPolicies/{policyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        policyName
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const createOrUpdateOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/backupLongTermRetentionPolicies/{policyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: LongTermRetentionPolicy
        },
        201: {
            bodyMapper: LongTermRetentionPolicy
        },
        202: {
            bodyMapper: LongTermRetentionPolicy
        },
        204: {
            bodyMapper: LongTermRetentionPolicy
        },
        default: {}
    },
    requestBody: parameters36,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        policyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$I
};
const listByDatabaseOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/backupLongTermRetentionPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const listByDatabaseNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$I
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing MaintenanceWindowOptionsOperations operations. */
class MaintenanceWindowOptionsOperationsImpl {
    /**
     * Initialize a new instance of the class MaintenanceWindowOptionsOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of available maintenance windows.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database to get maintenance windows options for.
     * @param maintenanceWindowOptionsName Maintenance window options name.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, maintenanceWindowOptionsName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            maintenanceWindowOptionsName,
            options
        }, getOperationSpec$D);
    }
}
// Operation Specifications
const serializer$J = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/maintenanceWindowOptions/current",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MaintenanceWindowOptions
        },
        default: {}
    },
    queryParameters: [
        apiVersion2,
        maintenanceWindowOptionsName
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing MaintenanceWindowsOperations operations. */
class MaintenanceWindowsOperationsImpl {
    /**
     * Initialize a new instance of the class MaintenanceWindowsOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets maintenance windows settings for a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database to get maintenance windows for.
     * @param maintenanceWindowName Maintenance window name.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, maintenanceWindowName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            maintenanceWindowName,
            options
        }, getOperationSpec$E);
    }
    /**
     * Sets maintenance windows settings for a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database to set maintenance windows for.
     * @param maintenanceWindowName Maintenance window name.
     * @param parameters Maintenance windows.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, databaseName, maintenanceWindowName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            maintenanceWindowName,
            parameters,
            options
        }, createOrUpdateOperationSpec$p);
    }
}
// Operation Specifications
const serializer$K = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/maintenanceWindows/current",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MaintenanceWindows
        },
        default: {}
    },
    queryParameters: [apiVersion2, maintenanceWindowName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$K
};
const createOrUpdateOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/maintenanceWindows/current",
    httpMethod: "PUT",
    responses: { 200: {}, default: {} },
    requestBody: parameters37,
    queryParameters: [apiVersion2, maintenanceWindowName],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$K
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedBackupShortTermRetentionPolicies operations. */
class ManagedBackupShortTermRetentionPoliciesImpl {
    /**
     * Initialize a new instance of the class ManagedBackupShortTermRetentionPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a managed database's short term retention policy list.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, managedInstanceName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a managed database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param policyName The policy name.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, databaseName, policyName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            policyName,
            options
        }, getOperationSpec$F);
    }
    /**
     * Updates a managed database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param policyName The policy name. Should always be "default".
     * @param parameters The short term retention policy info.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, managedInstanceName, databaseName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                databaseName,
                policyName,
                parameters,
                options
            }, createOrUpdateOperationSpec$q);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a managed database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param policyName The policy name. Should always be "default".
     * @param parameters The short term retention policy info.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, managedInstanceName, databaseName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, managedInstanceName, databaseName, policyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a managed database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param policyName The policy name. Should always be "default".
     * @param parameters The short term retention policy info.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, managedInstanceName, databaseName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                databaseName,
                policyName,
                parameters,
                options
            }, updateOperationSpec$8);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a managed database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param policyName The policy name. Should always be "default".
     * @param parameters The short term retention policy info.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, managedInstanceName, databaseName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, managedInstanceName, databaseName, policyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a managed database's short term retention policy list.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, databaseName, options }, listByDatabaseOperationSpec$d);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            nextLink,
            options
        }, listByDatabaseNextOperationSpec$a);
    }
}
// Operation Specifications
const serializer$L = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/backupShortTermRetentionPolicies/{policyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName,
        policyName1
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const createOrUpdateOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/backupShortTermRetentionPolicies/{policyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        201: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        202: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        204: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        default: {}
    },
    requestBody: parameters38,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName,
        policyName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$L
};
const updateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/backupShortTermRetentionPolicies/{policyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        201: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        202: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        204: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        default: {}
    },
    requestBody: parameters38,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName,
        policyName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$L
};
const listByDatabaseOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/backupShortTermRetentionPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedBackupShortTermRetentionPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const listByDatabaseNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedBackupShortTermRetentionPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$L
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedDatabaseColumns operations. */
class ManagedDatabaseColumnsImpl {
    /**
     * Initialize a new instance of the class ManagedDatabaseColumns class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List managed database columns
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, managedInstanceName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List managed database columns
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param options The options parameters.
     */
    listByTable(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, options) {
        const iter = this.listByTablePagingAll(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByTablePagingPage(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, options);
            }
        };
    }
    listByTablePagingPage(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByTablePagingPage_1() {
            let result = yield tslib.__await(this._listByTable(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByTableNext(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByTablePagingAll(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByTablePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByTablePagingPage(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List managed database columns
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, databaseName, options }, listByDatabaseOperationSpec$e);
    }
    /**
     * List managed database columns
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param options The options parameters.
     */
    _listByTable(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            schemaName,
            tableName,
            options
        }, listByTableOperationSpec$1);
    }
    /**
     * Get managed database column
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, columnName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            schemaName,
            tableName,
            columnName,
            options
        }, getOperationSpec$G);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            nextLink,
            options
        }, listByDatabaseNextOperationSpec$b);
    }
    /**
     * ListByTableNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param nextLink The nextLink from the previous successful call to the ListByTable method.
     * @param options The options parameters.
     */
    _listByTableNext(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            schemaName,
            tableName,
            nextLink,
            options
        }, listByTableNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$M = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByDatabaseOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/columns",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseColumnListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion2,
        schema,
        table,
        column,
        orderBy,
        skiptoken
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const listByTableOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/columns",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseColumnListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        schemaName,
        tableName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const getOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseColumn
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        schemaName,
        tableName,
        columnName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const listByDatabaseNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseColumnListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion2,
        schema,
        table,
        column,
        orderBy,
        skiptoken
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const listByTableNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseColumnListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        nextLink,
        schemaName,
        tableName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$M
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedDatabaseQueries operations. */
class ManagedDatabaseQueriesImpl {
    /**
     * Initialize a new instance of the class ManagedDatabaseQueries class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get query execution statistics by query id.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param queryId
     * @param options The options parameters.
     */
    listByQuery(resourceGroupName, managedInstanceName, databaseName, queryId, options) {
        const iter = this.listByQueryPagingAll(resourceGroupName, managedInstanceName, databaseName, queryId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByQueryPagingPage(resourceGroupName, managedInstanceName, databaseName, queryId, options);
            }
        };
    }
    listByQueryPagingPage(resourceGroupName, managedInstanceName, databaseName, queryId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByQueryPagingPage_1() {
            let result = yield tslib.__await(this._listByQuery(resourceGroupName, managedInstanceName, databaseName, queryId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByQueryNext(resourceGroupName, managedInstanceName, databaseName, queryId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByQueryPagingAll(resourceGroupName, managedInstanceName, databaseName, queryId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByQueryPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByQueryPagingPage(resourceGroupName, managedInstanceName, databaseName, queryId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get query by query id.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param queryId
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, databaseName, queryId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            queryId,
            options
        }, getOperationSpec$H);
    }
    /**
     * Get query execution statistics by query id.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param queryId
     * @param options The options parameters.
     */
    _listByQuery(resourceGroupName, managedInstanceName, databaseName, queryId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            queryId,
            options
        }, listByQueryOperationSpec);
    }
    /**
     * ListByQueryNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param queryId
     * @param nextLink The nextLink from the previous successful call to the ListByQuery method.
     * @param options The options parameters.
     */
    _listByQueryNext(resourceGroupName, managedInstanceName, databaseName, queryId, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            queryId,
            nextLink,
            options
        }, listByQueryNextOperationSpec);
    }
}
// Operation Specifications
const serializer$N = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$H = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/queries/{queryId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceQuery
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName,
        queryId
    ],
    headerParameters: [accept],
    serializer: serializer$N
};
const listByQueryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/queries/{queryId}/statistics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceQueryStatistics
        },
        default: {}
    },
    queryParameters: [
        apiVersion2,
        startTime,
        endTime,
        interval
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName,
        queryId
    ],
    headerParameters: [accept],
    serializer: serializer$N
};
const listByQueryNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceQueryStatistics
        },
        default: {}
    },
    queryParameters: [
        apiVersion2,
        startTime,
        endTime,
        interval
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        nextLink,
        managedInstanceName,
        queryId
    ],
    headerParameters: [accept],
    serializer: serializer$N
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ManagedDatabaseRestoreDetails operations. */
class ManagedDatabaseRestoreDetailsImpl {
    /**
     * Initialize a new instance of the class ManagedDatabaseRestoreDetails class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets managed database restore details.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param restoreDetailsName The name of the restore details to retrieve.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, databaseName, restoreDetailsName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            restoreDetailsName,
            options
        }, getOperationSpec$I);
    }
}
// Operation Specifications
const serializer$O = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$I = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/restoreDetails/{restoreDetailsName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedDatabaseRestoreDetailsResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName,
        restoreDetailsName
    ],
    headerParameters: [accept],
    serializer: serializer$O
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedDatabases operations. */
class ManagedDatabasesImpl {
    /**
     * Initialize a new instance of the class ManagedDatabases class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of managed databases.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listByInstance(resourceGroupName, managedInstanceName, options) {
        const iter = this.listByInstancePagingAll(resourceGroupName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options);
            }
        };
    }
    listByInstancePagingPage(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByInstance(resourceGroupName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByInstanceNext(resourceGroupName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByInstancePagingAll(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of inaccessible managed databases in a managed instance
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listInaccessibleByInstance(resourceGroupName, managedInstanceName, options) {
        const iter = this.listInaccessibleByInstancePagingAll(resourceGroupName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listInaccessibleByInstancePagingPage(resourceGroupName, managedInstanceName, options);
            }
        };
    }
    listInaccessibleByInstancePagingPage(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInaccessibleByInstancePagingPage_1() {
            let result = yield tslib.__await(this._listInaccessibleByInstance(resourceGroupName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listInaccessibleByInstanceNext(resourceGroupName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listInaccessibleByInstancePagingAll(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listInaccessibleByInstancePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listInaccessibleByInstancePagingPage(resourceGroupName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of managed databases.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listByInstance(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, listByInstanceOperationSpec);
    }
    /**
     * Gets a managed database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, databaseName, options }, getOperationSpec$J);
    }
    /**
     * Creates a new database or updates an existing database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param parameters The requested database resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, managedInstanceName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                databaseName,
                parameters,
                options
            }, createOrUpdateOperationSpec$r);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates a new database or updates an existing database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param parameters The requested database resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, managedInstanceName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, managedInstanceName, databaseName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a managed database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, managedInstanceName, databaseName, options }, deleteOperationSpec$f);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a managed database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, managedInstanceName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param parameters The requested database resource state.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, managedInstanceName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                databaseName,
                parameters,
                options
            }, updateOperationSpec$9);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates an existing database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param parameters The requested database resource state.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, managedInstanceName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, managedInstanceName, databaseName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Completes the restore operation on a managed database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param parameters The definition for completing the restore of this managed database.
     * @param options The options parameters.
     */
    beginCompleteRestore(resourceGroupName, managedInstanceName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                databaseName,
                parameters,
                options
            }, completeRestoreOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Completes the restore operation on a managed database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param parameters The definition for completing the restore of this managed database.
     * @param options The options parameters.
     */
    beginCompleteRestoreAndWait(resourceGroupName, managedInstanceName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCompleteRestore(resourceGroupName, managedInstanceName, databaseName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of inaccessible managed databases in a managed instance
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listInaccessibleByInstance(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, listInaccessibleByInstanceOperationSpec);
    }
    /**
     * ListByInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListByInstance method.
     * @param options The options parameters.
     */
    _listByInstanceNext(resourceGroupName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, nextLink, options }, listByInstanceNextOperationSpec);
    }
    /**
     * ListInaccessibleByInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListInaccessibleByInstance
     *                 method.
     * @param options The options parameters.
     */
    _listInaccessibleByInstanceNext(resourceGroupName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, nextLink, options }, listInaccessibleByInstanceNextOperationSpec);
    }
}
// Operation Specifications
const serializer$P = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByInstanceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedDatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$P
};
const getOperationSpec$J = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedDatabase
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$P
};
const createOrUpdateOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedDatabase
        },
        201: {
            bodyMapper: ManagedDatabase
        },
        202: {
            bodyMapper: ManagedDatabase
        },
        204: {
            bodyMapper: ManagedDatabase
        },
        default: {}
    },
    requestBody: parameters39,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$P
};
const deleteOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    serializer: serializer$P
};
const updateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ManagedDatabase
        },
        201: {
            bodyMapper: ManagedDatabase
        },
        202: {
            bodyMapper: ManagedDatabase
        },
        204: {
            bodyMapper: ManagedDatabase
        },
        default: {}
    },
    requestBody: parameters40,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$P
};
const completeRestoreOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/completeRestore",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    requestBody: parameters41,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$P
};
const listInaccessibleByInstanceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/inaccessibleManagedDatabases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedDatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$P
};
const listByInstanceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedDatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$P
};
const listInaccessibleByInstanceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedDatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$P
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedDatabaseSchemas operations. */
class ManagedDatabaseSchemasImpl {
    /**
     * Initialize a new instance of the class ManagedDatabaseSchemas class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List managed database schemas
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, managedInstanceName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List managed database schemas
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, databaseName, options }, listByDatabaseOperationSpec$f);
    }
    /**
     * Get managed database schema
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, databaseName, schemaName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            schemaName,
            options
        }, getOperationSpec$K);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            nextLink,
            options
        }, listByDatabaseNextOperationSpec$c);
    }
}
// Operation Specifications
const serializer$Q = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByDatabaseOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/schemas",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseSchemaListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};
const getOperationSpec$K = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/schemas/{schemaName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseSchema
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        schemaName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};
const listByDatabaseNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseSchemaListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedDatabaseSecurityAlertPolicies operations. */
class ManagedDatabaseSecurityAlertPoliciesImpl {
    /**
     * Initialize a new instance of the class ManagedDatabaseSecurityAlertPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of managed database's security alert policies.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database for which the security alert policies are
     *                     defined.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, managedInstanceName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a managed database's security alert policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database for which the security alert policy is defined.
     * @param securityAlertPolicyName The name of the security alert policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, databaseName, securityAlertPolicyName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            securityAlertPolicyName,
            options
        }, getOperationSpec$L);
    }
    /**
     * Creates or updates a database's security alert policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database for which the security alert policy is defined.
     * @param securityAlertPolicyName The name of the security alert policy.
     * @param parameters The database security alert policy.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, managedInstanceName, databaseName, securityAlertPolicyName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            securityAlertPolicyName,
            parameters,
            options
        }, createOrUpdateOperationSpec$s);
    }
    /**
     * Gets a list of managed database's security alert policies.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database for which the security alert policies are
     *                     defined.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, databaseName, options }, listByDatabaseOperationSpec$g);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database for which the security alert policies are
     *                     defined.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            nextLink,
            options
        }, listByDatabaseNextOperationSpec$d);
    }
}
// Operation Specifications
const serializer$R = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$L = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/securityAlertPolicies/{securityAlertPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedDatabaseSecurityAlertPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        securityAlertPolicyName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const createOrUpdateOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/securityAlertPolicies/{securityAlertPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedDatabaseSecurityAlertPolicy
        },
        201: {
            bodyMapper: ManagedDatabaseSecurityAlertPolicy
        },
        default: {}
    },
    requestBody: parameters42,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        securityAlertPolicyName,
        managedInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$R
};
const listByDatabaseOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/securityAlertPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedDatabaseSecurityAlertPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const listByDatabaseNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedDatabaseSecurityAlertPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedDatabaseSecurityEvents operations. */
class ManagedDatabaseSecurityEventsImpl {
    /**
     * Initialize a new instance of the class ManagedDatabaseSecurityEvents class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of security events.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database for which the security events are retrieved.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, managedInstanceName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of security events.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database for which the security events are retrieved.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, databaseName, options }, listByDatabaseOperationSpec$h);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database for which the security events are retrieved.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            nextLink,
            options
        }, listByDatabaseNextOperationSpec$e);
    }
}
// Operation Specifications
const serializer$S = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByDatabaseOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/securityEvents",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityEventCollection
        },
        default: {}
    },
    queryParameters: [
        skip,
        apiVersion2,
        skiptoken,
        filter1,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$S
};
const listByDatabaseNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityEventCollection
        },
        default: {}
    },
    queryParameters: [
        skip,
        apiVersion2,
        skiptoken,
        filter1,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$S
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedDatabaseSensitivityLabels operations. */
class ManagedDatabaseSensitivityLabelsImpl {
    /**
     * Initialize a new instance of the class ManagedDatabaseSensitivityLabels class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the sensitivity labels of a given database
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listCurrentByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        const iter = this.listCurrentByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listCurrentByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options);
            }
        };
    }
    listCurrentByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCurrentByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listCurrentByDatabase(resourceGroupName, managedInstanceName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listCurrentByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listCurrentByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCurrentByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCurrentByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the sensitivity labels of a given database
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listRecommendedByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        const iter = this.listRecommendedByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listRecommendedByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options);
            }
        };
    }
    listRecommendedByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendedByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listRecommendedByDatabase(resourceGroupName, managedInstanceName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listRecommendedByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listRecommendedByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendedByDatabasePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listRecommendedByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the sensitivity label of a given column
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param sensitivityLabelSource The source of the sensitivity label.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, columnName, sensitivityLabelSource, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            schemaName,
            tableName,
            columnName,
            sensitivityLabelSource,
            options
        }, getOperationSpec$M);
    }
    /**
     * Creates or updates the sensitivity label of a given column
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param parameters The column sensitivity label resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, columnName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            schemaName,
            tableName,
            columnName,
            parameters,
            options
        }, createOrUpdateOperationSpec$t);
    }
    /**
     * Deletes the sensitivity label of a given column
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param options The options parameters.
     */
    delete(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, columnName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            schemaName,
            tableName,
            columnName,
            options
        }, deleteOperationSpec$g);
    }
    /**
     * Disables sensitivity recommendations on a given column
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param options The options parameters.
     */
    disableRecommendation(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, columnName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            schemaName,
            tableName,
            columnName,
            options
        }, disableRecommendationOperationSpec);
    }
    /**
     * Enables sensitivity recommendations on a given column (recommendations are enabled by default on all
     * columns)
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param options The options parameters.
     */
    enableRecommendation(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, columnName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            schemaName,
            tableName,
            columnName,
            options
        }, enableRecommendationOperationSpec);
    }
    /**
     * Gets the sensitivity labels of a given database
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listCurrentByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, databaseName, options }, listCurrentByDatabaseOperationSpec);
    }
    /**
     * Update sensitivity labels of a given database using an operations batch.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param parameters A list of sensitivity label update operations.
     * @param options The options parameters.
     */
    update(resourceGroupName, managedInstanceName, databaseName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            parameters,
            options
        }, updateOperationSpec$a);
    }
    /**
     * Gets the sensitivity labels of a given database
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listRecommendedByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, databaseName, options }, listRecommendedByDatabaseOperationSpec);
    }
    /**
     * ListCurrentByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListCurrentByDatabase method.
     * @param options The options parameters.
     */
    _listCurrentByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            nextLink,
            options
        }, listCurrentByDatabaseNextOperationSpec);
    }
    /**
     * ListRecommendedByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListRecommendedByDatabase
     *                 method.
     * @param options The options parameters.
     */
    _listRecommendedByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            nextLink,
            options
        }, listRecommendedByDatabaseNextOperationSpec);
    }
}
// Operation Specifications
const serializer$T = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$M = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}/sensitivityLabels/{sensitivityLabelSource}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SensitivityLabel
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        schemaName,
        tableName,
        columnName,
        managedInstanceName,
        sensitivityLabelSource
    ],
    headerParameters: [accept],
    serializer: serializer$T
};
const createOrUpdateOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}/sensitivityLabels/{sensitivityLabelSource}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SensitivityLabel
        },
        201: {
            bodyMapper: SensitivityLabel
        },
        default: {}
    },
    requestBody: parameters43,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        schemaName,
        tableName,
        columnName,
        managedInstanceName,
        sensitivityLabelSource1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$T
};
const deleteOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}/sensitivityLabels/{sensitivityLabelSource}",
    httpMethod: "DELETE",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        schemaName,
        tableName,
        columnName,
        managedInstanceName,
        sensitivityLabelSource1
    ],
    serializer: serializer$T
};
const disableRecommendationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}/sensitivityLabels/{sensitivityLabelSource}/disable",
    httpMethod: "POST",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        schemaName,
        tableName,
        columnName,
        managedInstanceName,
        sensitivityLabelSource2
    ],
    serializer: serializer$T
};
const enableRecommendationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}/sensitivityLabels/{sensitivityLabelSource}/enable",
    httpMethod: "POST",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        schemaName,
        tableName,
        columnName,
        managedInstanceName,
        sensitivityLabelSource2
    ],
    serializer: serializer$T
};
const listCurrentByDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/currentSensitivityLabels",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SensitivityLabelListResult
        },
        default: {}
    },
    queryParameters: [
        skipToken,
        apiVersion2,
        filter1,
        count
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$T
};
const updateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/currentSensitivityLabels",
    httpMethod: "PATCH",
    responses: { 200: {}, default: {} },
    requestBody: parameters44,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$T
};
const listRecommendedByDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/recommendedSensitivityLabels",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SensitivityLabelListResult
        },
        default: {}
    },
    queryParameters: [
        skipToken,
        apiVersion2,
        filter1,
        includeDisabledRecommendations
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$T
};
const listCurrentByDatabaseNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SensitivityLabelListResult
        },
        default: {}
    },
    queryParameters: [
        skipToken,
        apiVersion2,
        filter1,
        count
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$T
};
const listRecommendedByDatabaseNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SensitivityLabelListResult
        },
        default: {}
    },
    queryParameters: [
        skipToken,
        apiVersion2,
        filter1,
        includeDisabledRecommendations
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$T
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ManagedDatabaseRecommendedSensitivityLabels operations. */
class ManagedDatabaseRecommendedSensitivityLabelsImpl {
    /**
     * Initialize a new instance of the class ManagedDatabaseRecommendedSensitivityLabels class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Update recommended sensitivity labels states of a given database using an operations batch.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param parameters A list of recommended sensitivity label update operations.
     * @param options The options parameters.
     */
    update(resourceGroupName, managedInstanceName, databaseName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            parameters,
            options
        }, updateOperationSpec$b);
    }
}
// Operation Specifications
const serializer$U = coreClient.createSerializer(Mappers, /* isXml */ false);
const updateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/recommendedSensitivityLabels",
    httpMethod: "PATCH",
    responses: { 200: {}, default: {} },
    requestBody: parameters45,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$U
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedDatabaseTables operations. */
class ManagedDatabaseTablesImpl {
    /**
     * Initialize a new instance of the class ManagedDatabaseTables class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List managed database tables
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param options The options parameters.
     */
    listBySchema(resourceGroupName, managedInstanceName, databaseName, schemaName, options) {
        const iter = this.listBySchemaPagingAll(resourceGroupName, managedInstanceName, databaseName, schemaName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySchemaPagingPage(resourceGroupName, managedInstanceName, databaseName, schemaName, options);
            }
        };
    }
    listBySchemaPagingPage(resourceGroupName, managedInstanceName, databaseName, schemaName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySchemaPagingPage_1() {
            let result = yield tslib.__await(this._listBySchema(resourceGroupName, managedInstanceName, databaseName, schemaName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySchemaNext(resourceGroupName, managedInstanceName, databaseName, schemaName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySchemaPagingAll(resourceGroupName, managedInstanceName, databaseName, schemaName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySchemaPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySchemaPagingPage(resourceGroupName, managedInstanceName, databaseName, schemaName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List managed database tables
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param options The options parameters.
     */
    _listBySchema(resourceGroupName, managedInstanceName, databaseName, schemaName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            schemaName,
            options
        }, listBySchemaOperationSpec$1);
    }
    /**
     * Get managed database table
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, databaseName, schemaName, tableName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            schemaName,
            tableName,
            options
        }, getOperationSpec$N);
    }
    /**
     * ListBySchemaNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param nextLink The nextLink from the previous successful call to the ListBySchema method.
     * @param options The options parameters.
     */
    _listBySchemaNext(resourceGroupName, managedInstanceName, databaseName, schemaName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            schemaName,
            nextLink,
            options
        }, listBySchemaNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$V = coreClient.createSerializer(Mappers, /* isXml */ false);
const listBySchemaOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/schemas/{schemaName}/tables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseTableListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        schemaName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$V
};
const getOperationSpec$N = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseTable
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        schemaName,
        tableName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$V
};
const listBySchemaNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseTableListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        nextLink,
        schemaName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$V
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedDatabaseTransparentDataEncryption operations. */
class ManagedDatabaseTransparentDataEncryptionImpl {
    /**
     * Initialize a new instance of the class ManagedDatabaseTransparentDataEncryption class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of managed database's transparent data encryptions.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database for which the transparent data encryption is
     *                     defined.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, managedInstanceName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a managed database's transparent data encryption.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database for which the transparent data encryption is
     *                     defined.
     * @param tdeName The name of the transparent data encryption configuration.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, databaseName, tdeName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            tdeName,
            options
        }, getOperationSpec$O);
    }
    /**
     * Updates a database's transparent data encryption configuration.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database for which the security alert policy is defined.
     * @param tdeName The name of the transparent data encryption configuration.
     * @param parameters The database transparent data encryption.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, managedInstanceName, databaseName, tdeName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            tdeName,
            parameters,
            options
        }, createOrUpdateOperationSpec$u);
    }
    /**
     * Gets a list of managed database's transparent data encryptions.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database for which the transparent data encryption is
     *                     defined.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, databaseName, options }, listByDatabaseOperationSpec$i);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database for which the transparent data encryption is
     *                     defined.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            nextLink,
            options
        }, listByDatabaseNextOperationSpec$f);
    }
}
// Operation Specifications
const serializer$W = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$O = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/transparentDataEncryption/{tdeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedTransparentDataEncryption
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName,
        tdeName
    ],
    headerParameters: [accept],
    serializer: serializer$W
};
const createOrUpdateOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/transparentDataEncryption/{tdeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedTransparentDataEncryption
        },
        201: {
            bodyMapper: ManagedTransparentDataEncryption
        },
        default: {}
    },
    requestBody: parameters46,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName,
        tdeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const listByDatabaseOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/transparentDataEncryption",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedTransparentDataEncryptionListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$W
};
const listByDatabaseNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedTransparentDataEncryptionListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$W
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ManagedDatabaseVulnerabilityAssessmentRuleBaselines operations. */
class ManagedDatabaseVulnerabilityAssessmentRuleBaselinesImpl {
    /**
     * Initialize a new instance of the class ManagedDatabaseVulnerabilityAssessmentRuleBaselines class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a database's vulnerability assessment rule baseline.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database for which the vulnerability assessment rule baseline is
     *                     defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param ruleId The vulnerability assessment rule ID.
     * @param baselineName The name of the vulnerability assessment rule baseline (default implies a
     *                     baseline on a database level rule and master for server level rule).
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, ruleId, baselineName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            vulnerabilityAssessmentName,
            ruleId,
            baselineName,
            options
        }, getOperationSpec$P);
    }
    /**
     * Creates or updates a database's vulnerability assessment rule baseline.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database for which the vulnerability assessment rule baseline is
     *                     defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param ruleId The vulnerability assessment rule ID.
     * @param baselineName The name of the vulnerability assessment rule baseline (default implies a
     *                     baseline on a database level rule and master for server level rule).
     * @param parameters The requested rule baseline resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, ruleId, baselineName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            vulnerabilityAssessmentName,
            ruleId,
            baselineName,
            parameters,
            options
        }, createOrUpdateOperationSpec$v);
    }
    /**
     * Removes the database's vulnerability assessment rule baseline.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database for which the vulnerability assessment rule baseline is
     *                     defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param ruleId The vulnerability assessment rule ID.
     * @param baselineName The name of the vulnerability assessment rule baseline (default implies a
     *                     baseline on a database level rule and master for server level rule).
     * @param options The options parameters.
     */
    delete(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, ruleId, baselineName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            vulnerabilityAssessmentName,
            ruleId,
            baselineName,
            options
        }, deleteOperationSpec$h);
    }
}
// Operation Specifications
const serializer$X = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$P = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/rules/{ruleId}/baselines/{baselineName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseVulnerabilityAssessmentRuleBaseline
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        vulnerabilityAssessmentName,
        ruleId,
        baselineName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$X
};
const createOrUpdateOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/rules/{ruleId}/baselines/{baselineName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DatabaseVulnerabilityAssessmentRuleBaseline
        },
        default: {}
    },
    requestBody: parameters20,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        vulnerabilityAssessmentName,
        ruleId,
        baselineName,
        managedInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$X
};
const deleteOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/rules/{ruleId}/baselines/{baselineName}",
    httpMethod: "DELETE",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        vulnerabilityAssessmentName,
        ruleId,
        baselineName,
        managedInstanceName
    ],
    serializer: serializer$X
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedDatabaseVulnerabilityAssessments operations. */
class ManagedDatabaseVulnerabilityAssessmentsImpl {
    /**
     * Initialize a new instance of the class ManagedDatabaseVulnerabilityAssessments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the vulnerability assessments of a managed database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database for which the vulnerability assessment is defined.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, managedInstanceName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the database's vulnerability assessment.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database for which the vulnerability assessment is defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            vulnerabilityAssessmentName,
            options
        }, getOperationSpec$Q);
    }
    /**
     * Creates or updates the database's vulnerability assessment.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database for which the vulnerability assessment is defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param parameters The requested resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            vulnerabilityAssessmentName,
            parameters,
            options
        }, createOrUpdateOperationSpec$w);
    }
    /**
     * Removes the database's vulnerability assessment.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database for which the vulnerability assessment is defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    delete(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            vulnerabilityAssessmentName,
            options
        }, deleteOperationSpec$i);
    }
    /**
     * Lists the vulnerability assessments of a managed database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database for which the vulnerability assessment is defined.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, databaseName, options }, listByDatabaseOperationSpec$j);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database for which the vulnerability assessment is defined.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            nextLink,
            options
        }, listByDatabaseNextOperationSpec$g);
    }
}
// Operation Specifications
const serializer$Y = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$Q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseVulnerabilityAssessment
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        vulnerabilityAssessmentName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$Y
};
const createOrUpdateOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DatabaseVulnerabilityAssessment
        },
        201: {
            bodyMapper: DatabaseVulnerabilityAssessment
        },
        default: {}
    },
    requestBody: parameters21,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        vulnerabilityAssessmentName,
        managedInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$Y
};
const deleteOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "DELETE",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        vulnerabilityAssessmentName,
        managedInstanceName
    ],
    serializer: serializer$Y
};
const listByDatabaseOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/vulnerabilityAssessments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseVulnerabilityAssessmentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$Y
};
const listByDatabaseNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseVulnerabilityAssessmentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$Y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedDatabaseVulnerabilityAssessmentScans operations. */
class ManagedDatabaseVulnerabilityAssessmentScansImpl {
    /**
     * Initialize a new instance of the class ManagedDatabaseVulnerabilityAssessmentScans class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the vulnerability assessment scans of a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Executes a Vulnerability Assessment database scan.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param scanId The vulnerability assessment scan Id of the scan to retrieve.
     * @param options The options parameters.
     */
    beginInitiateScan(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, scanId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                databaseName,
                vulnerabilityAssessmentName,
                scanId,
                options
            }, initiateScanOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Executes a Vulnerability Assessment database scan.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param scanId The vulnerability assessment scan Id of the scan to retrieve.
     * @param options The options parameters.
     */
    beginInitiateScanAndWait(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, scanId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginInitiateScan(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, scanId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Convert an existing scan result to a human readable format. If already exists nothing happens
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the scanned database.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param scanId The vulnerability assessment scan Id.
     * @param options The options parameters.
     */
    export(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, scanId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            vulnerabilityAssessmentName,
            scanId,
            options
        }, exportOperationSpec$2);
    }
    /**
     * Lists the vulnerability assessment scans of a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            vulnerabilityAssessmentName,
            options
        }, listByDatabaseOperationSpec$k);
    }
    /**
     * Gets a vulnerability assessment scan record of a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param scanId The vulnerability assessment scan Id of the scan to retrieve.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, scanId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            vulnerabilityAssessmentName,
            scanId,
            options
        }, getOperationSpec$R);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, vulnerabilityAssessmentName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            vulnerabilityAssessmentName,
            nextLink,
            options
        }, listByDatabaseNextOperationSpec$h);
    }
}
// Operation Specifications
const serializer$Z = coreClient.createSerializer(Mappers, /* isXml */ false);
const initiateScanOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/scans/{scanId}/initiateScan",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        vulnerabilityAssessmentName,
        scanId,
        managedInstanceName
    ],
    serializer: serializer$Z
};
const exportOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/scans/{scanId}/export",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DatabaseVulnerabilityAssessmentScansExport
        },
        201: {
            bodyMapper: DatabaseVulnerabilityAssessmentScansExport
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        vulnerabilityAssessmentName,
        scanId,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};
const listByDatabaseOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/scans",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VulnerabilityAssessmentScanRecordListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        vulnerabilityAssessmentName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};
const getOperationSpec$R = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}/scans/{scanId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VulnerabilityAssessmentScanRecord
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        vulnerabilityAssessmentName,
        scanId,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};
const listByDatabaseNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VulnerabilityAssessmentScanRecordListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        nextLink,
        vulnerabilityAssessmentName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedInstanceAdministrators operations. */
class ManagedInstanceAdministratorsImpl {
    /**
     * Initialize a new instance of the class ManagedInstanceAdministrators class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of managed instance administrators.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listByInstance(resourceGroupName, managedInstanceName, options) {
        const iter = this.listByInstancePagingAll(resourceGroupName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options);
            }
        };
    }
    listByInstancePagingPage(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByInstance(resourceGroupName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByInstanceNext(resourceGroupName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByInstancePagingAll(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of managed instance administrators.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listByInstance(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, listByInstanceOperationSpec$1);
    }
    /**
     * Gets a managed instance administrator.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param administratorName
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, administratorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, administratorName, options }, getOperationSpec$S);
    }
    /**
     * Creates or updates a managed instance administrator.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param administratorName
     * @param parameters The requested administrator parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, managedInstanceName, administratorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                administratorName,
                parameters,
                options
            }, createOrUpdateOperationSpec$x);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a managed instance administrator.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param administratorName
     * @param parameters The requested administrator parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, managedInstanceName, administratorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, managedInstanceName, administratorName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a managed instance administrator.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param administratorName
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, managedInstanceName, administratorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, managedInstanceName, administratorName, options }, deleteOperationSpec$j);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a managed instance administrator.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param administratorName
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, managedInstanceName, administratorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, managedInstanceName, administratorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListByInstance method.
     * @param options The options parameters.
     */
    _listByInstanceNext(resourceGroupName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, nextLink, options }, listByInstanceNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$_ = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByInstanceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/administrators",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceAdministratorListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$_
};
const getOperationSpec$S = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/administrators/{administratorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceAdministrator
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        administratorName
    ],
    headerParameters: [accept],
    serializer: serializer$_
};
const createOrUpdateOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/administrators/{administratorName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedInstanceAdministrator
        },
        201: {
            bodyMapper: ManagedInstanceAdministrator
        },
        202: {
            bodyMapper: ManagedInstanceAdministrator
        },
        204: {
            bodyMapper: ManagedInstanceAdministrator
        },
        default: {}
    },
    requestBody: parameters47,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        administratorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$_
};
const deleteOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/administrators/{administratorName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        administratorName
    ],
    serializer: serializer$_
};
const listByInstanceNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceAdministratorListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$_
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedInstanceAzureADOnlyAuthentications operations. */
class ManagedInstanceAzureADOnlyAuthenticationsImpl {
    /**
     * Initialize a new instance of the class ManagedInstanceAzureADOnlyAuthentications class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of server Azure Active Directory only authentications.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listByInstance(resourceGroupName, managedInstanceName, options) {
        const iter = this.listByInstancePagingAll(resourceGroupName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options);
            }
        };
    }
    listByInstancePagingPage(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByInstance(resourceGroupName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByInstanceNext(resourceGroupName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByInstancePagingAll(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a specific Azure Active Directory only authentication property.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param authenticationName The name of server azure active directory only authentication.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, authenticationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, authenticationName, options }, getOperationSpec$T);
    }
    /**
     * Sets Server Active Directory only authentication property or updates an existing server Active
     * Directory only authentication property.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param authenticationName The name of server azure active directory only authentication.
     * @param parameters The required parameters for creating or updating an Active Directory only
     *                   authentication property.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, managedInstanceName, authenticationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                authenticationName,
                parameters,
                options
            }, createOrUpdateOperationSpec$y);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Sets Server Active Directory only authentication property or updates an existing server Active
     * Directory only authentication property.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param authenticationName The name of server azure active directory only authentication.
     * @param parameters The required parameters for creating or updating an Active Directory only
     *                   authentication property.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, managedInstanceName, authenticationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, managedInstanceName, authenticationName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing server Active Directory only authentication property.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param authenticationName The name of server azure active directory only authentication.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, managedInstanceName, authenticationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, managedInstanceName, authenticationName, options }, deleteOperationSpec$k);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes an existing server Active Directory only authentication property.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param authenticationName The name of server azure active directory only authentication.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, managedInstanceName, authenticationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, managedInstanceName, authenticationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of server Azure Active Directory only authentications.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listByInstance(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, listByInstanceOperationSpec$2);
    }
    /**
     * ListByInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListByInstance method.
     * @param options The options parameters.
     */
    _listByInstanceNext(resourceGroupName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, nextLink, options }, listByInstanceNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$$ = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$T = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/azureADOnlyAuthentications/{authenticationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceAzureADOnlyAuthentication
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        authenticationName
    ],
    headerParameters: [accept],
    serializer: serializer$$
};
const createOrUpdateOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/azureADOnlyAuthentications/{authenticationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedInstanceAzureADOnlyAuthentication
        },
        201: {
            bodyMapper: ManagedInstanceAzureADOnlyAuthentication
        },
        202: {
            bodyMapper: ManagedInstanceAzureADOnlyAuthentication
        },
        204: {
            bodyMapper: ManagedInstanceAzureADOnlyAuthentication
        },
        default: {}
    },
    requestBody: parameters48,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        authenticationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$$
};
const deleteOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/azureADOnlyAuthentications/{authenticationName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        authenticationName
    ],
    serializer: serializer$$
};
const listByInstanceOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/azureADOnlyAuthentications",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceAzureADOnlyAuthListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$$
};
const listByInstanceNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceAzureADOnlyAuthListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$$
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedInstanceEncryptionProtectors operations. */
class ManagedInstanceEncryptionProtectorsImpl {
    /**
     * Initialize a new instance of the class ManagedInstanceEncryptionProtectors class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of managed instance encryption protectors
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listByInstance(resourceGroupName, managedInstanceName, options) {
        const iter = this.listByInstancePagingAll(resourceGroupName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options);
            }
        };
    }
    listByInstancePagingPage(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByInstance(resourceGroupName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByInstanceNext(resourceGroupName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByInstancePagingAll(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Revalidates an existing encryption protector.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param encryptionProtectorName The name of the encryption protector to be updated.
     * @param options The options parameters.
     */
    beginRevalidate(resourceGroupName, managedInstanceName, encryptionProtectorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                encryptionProtectorName,
                options
            }, revalidateOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Revalidates an existing encryption protector.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param encryptionProtectorName The name of the encryption protector to be updated.
     * @param options The options parameters.
     */
    beginRevalidateAndWait(resourceGroupName, managedInstanceName, encryptionProtectorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRevalidate(resourceGroupName, managedInstanceName, encryptionProtectorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of managed instance encryption protectors
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listByInstance(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, listByInstanceOperationSpec$3);
    }
    /**
     * Gets a managed instance encryption protector.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param encryptionProtectorName The name of the encryption protector to be retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, encryptionProtectorName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            encryptionProtectorName,
            options
        }, getOperationSpec$U);
    }
    /**
     * Updates an existing encryption protector.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param encryptionProtectorName The name of the encryption protector to be updated.
     * @param parameters The requested encryption protector resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, managedInstanceName, encryptionProtectorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                encryptionProtectorName,
                parameters,
                options
            }, createOrUpdateOperationSpec$z);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates an existing encryption protector.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param encryptionProtectorName The name of the encryption protector to be updated.
     * @param parameters The requested encryption protector resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, managedInstanceName, encryptionProtectorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, managedInstanceName, encryptionProtectorName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListByInstance method.
     * @param options The options parameters.
     */
    _listByInstanceNext(resourceGroupName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, nextLink, options }, listByInstanceNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$10 = coreClient.createSerializer(Mappers, /* isXml */ false);
const revalidateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/encryptionProtector/{encryptionProtectorName}/revalidate",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        encryptionProtectorName,
        managedInstanceName
    ],
    serializer: serializer$10
};
const listByInstanceOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/encryptionProtector",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceEncryptionProtectorListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const getOperationSpec$U = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/encryptionProtector/{encryptionProtectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceEncryptionProtector
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        encryptionProtectorName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const createOrUpdateOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/encryptionProtector/{encryptionProtectorName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedInstanceEncryptionProtector
        },
        201: {
            bodyMapper: ManagedInstanceEncryptionProtector
        },
        202: {
            bodyMapper: ManagedInstanceEncryptionProtector
        },
        204: {
            bodyMapper: ManagedInstanceEncryptionProtector
        },
        default: {}
    },
    requestBody: parameters49,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        encryptionProtectorName,
        managedInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$10
};
const listByInstanceNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceEncryptionProtectorListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$10
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedInstanceKeys operations. */
class ManagedInstanceKeysImpl {
    /**
     * Initialize a new instance of the class ManagedInstanceKeys class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of managed instance keys.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listByInstance(resourceGroupName, managedInstanceName, options) {
        const iter = this.listByInstancePagingAll(resourceGroupName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options);
            }
        };
    }
    listByInstancePagingPage(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByInstance(resourceGroupName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByInstanceNext(resourceGroupName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByInstancePagingAll(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of managed instance keys.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listByInstance(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, listByInstanceOperationSpec$4);
    }
    /**
     * Gets a managed instance key.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param keyName The name of the managed instance key to be retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, keyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, keyName, options }, getOperationSpec$V);
    }
    /**
     * Creates or updates a managed instance key.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param keyName The name of the managed instance key to be operated on (updated or created).
     * @param parameters The requested managed instance key resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, managedInstanceName, keyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, managedInstanceName, keyName, parameters, options }, createOrUpdateOperationSpec$A);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a managed instance key.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param keyName The name of the managed instance key to be operated on (updated or created).
     * @param parameters The requested managed instance key resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, managedInstanceName, keyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, managedInstanceName, keyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the managed instance key with the given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param keyName The name of the managed instance key to be deleted.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, managedInstanceName, keyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, managedInstanceName, keyName, options }, deleteOperationSpec$l);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes the managed instance key with the given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param keyName The name of the managed instance key to be deleted.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, managedInstanceName, keyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, managedInstanceName, keyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListByInstance method.
     * @param options The options parameters.
     */
    _listByInstanceNext(resourceGroupName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, nextLink, options }, listByInstanceNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$11 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByInstanceOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/keys",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceKeyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const getOperationSpec$V = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/keys/{keyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceKey
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        keyName
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const createOrUpdateOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/keys/{keyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedInstanceKey
        },
        201: {
            bodyMapper: ManagedInstanceKey
        },
        202: {
            bodyMapper: ManagedInstanceKey
        },
        204: {
            bodyMapper: ManagedInstanceKey
        },
        default: {}
    },
    requestBody: parameters50,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        keyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$11
};
const deleteOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/keys/{keyName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        keyName
    ],
    serializer: serializer$11
};
const listByInstanceNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceKeyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$11
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedInstanceLongTermRetentionPolicies operations. */
class ManagedInstanceLongTermRetentionPoliciesImpl {
    /**
     * Initialize a new instance of the class ManagedInstanceLongTermRetentionPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a database's long term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, managedInstanceName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, managedInstanceName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a managed database's long term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param policyName The policy name. Should always be Default.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, databaseName, policyName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            policyName,
            options
        }, getOperationSpec$W);
    }
    /**
     * Sets a managed database's long term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param policyName The policy name. Should always be Default.
     * @param parameters The long term retention policy info.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, managedInstanceName, databaseName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                databaseName,
                policyName,
                parameters,
                options
            }, createOrUpdateOperationSpec$B);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Sets a managed database's long term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param policyName The policy name. Should always be Default.
     * @param parameters The long term retention policy info.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, managedInstanceName, databaseName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, managedInstanceName, databaseName, policyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a database's long term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, managedInstanceName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, databaseName, options }, listByDatabaseOperationSpec$l);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, managedInstanceName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            databaseName,
            nextLink,
            options
        }, listByDatabaseNextOperationSpec$i);
    }
}
// Operation Specifications
const serializer$12 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$W = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/backupLongTermRetentionPolicies/{policyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName,
        policyName2
    ],
    headerParameters: [accept],
    serializer: serializer$12
};
const createOrUpdateOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/backupLongTermRetentionPolicies/{policyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionPolicy
        },
        201: {
            bodyMapper: ManagedInstanceLongTermRetentionPolicy
        },
        202: {
            bodyMapper: ManagedInstanceLongTermRetentionPolicy
        },
        204: {
            bodyMapper: ManagedInstanceLongTermRetentionPolicy
        },
        default: {}
    },
    requestBody: parameters51,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName,
        policyName2
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$12
};
const listByDatabaseOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/databases/{databaseName}/backupLongTermRetentionPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$12
};
const listByDatabaseNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$12
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedInstanceOperations operations. */
class ManagedInstanceOperationsImpl {
    /**
     * Initialize a new instance of the class ManagedInstanceOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of operations performed on the managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listByManagedInstance(resourceGroupName, managedInstanceName, options) {
        const iter = this.listByManagedInstancePagingAll(resourceGroupName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByManagedInstancePagingPage(resourceGroupName, managedInstanceName, options);
            }
        };
    }
    listByManagedInstancePagingPage(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByManagedInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByManagedInstance(resourceGroupName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByManagedInstanceNext(resourceGroupName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByManagedInstancePagingAll(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByManagedInstancePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByManagedInstancePagingPage(resourceGroupName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of operations performed on the managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listByManagedInstance(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, listByManagedInstanceOperationSpec);
    }
    /**
     * Gets a management operation on a managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param operationId
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, operationId, options }, getOperationSpec$X);
    }
    /**
     * Cancels the asynchronous operation on the managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param operationId
     * @param options The options parameters.
     */
    cancel(resourceGroupName, managedInstanceName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, operationId, options }, cancelOperationSpec$2);
    }
    /**
     * ListByManagedInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListByManagedInstance method.
     * @param options The options parameters.
     */
    _listByManagedInstanceNext(resourceGroupName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, nextLink, options }, listByManagedInstanceNextOperationSpec);
    }
}
// Operation Specifications
const serializer$13 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByManagedInstanceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceOperationListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$13
};
const getOperationSpec$X = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/operations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceOperation
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        operationId,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$13
};
const cancelOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/operations/{operationId}/cancel",
    httpMethod: "POST",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        operationId,
        managedInstanceName
    ],
    serializer: serializer$13
};
const listByManagedInstanceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceOperationListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$13
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedInstancePrivateEndpointConnections operations. */
class ManagedInstancePrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class ManagedInstancePrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all private endpoint connections on a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listByManagedInstance(resourceGroupName, managedInstanceName, options) {
        const iter = this.listByManagedInstancePagingAll(resourceGroupName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByManagedInstancePagingPage(resourceGroupName, managedInstanceName, options);
            }
        };
    }
    listByManagedInstancePagingPage(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByManagedInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByManagedInstance(resourceGroupName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByManagedInstanceNext(resourceGroupName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByManagedInstancePagingAll(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByManagedInstancePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByManagedInstancePagingPage(resourceGroupName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a private endpoint connection.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            privateEndpointConnectionName,
            options
        }, getOperationSpec$Y);
    }
    /**
     * Approve or reject a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param privateEndpointConnectionName
     * @param parameters A private endpoint connection
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, managedInstanceName, privateEndpointConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                privateEndpointConnectionName,
                parameters,
                options
            }, createOrUpdateOperationSpec$C);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Approve or reject a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param privateEndpointConnectionName
     * @param parameters A private endpoint connection
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, managedInstanceName, privateEndpointConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, managedInstanceName, privateEndpointConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param privateEndpointConnectionName
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, managedInstanceName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                privateEndpointConnectionName,
                options
            }, deleteOperationSpec$m);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param privateEndpointConnectionName
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, managedInstanceName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, managedInstanceName, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all private endpoint connections on a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listByManagedInstance(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, listByManagedInstanceOperationSpec$1);
    }
    /**
     * ListByManagedInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListByManagedInstance method.
     * @param options The options parameters.
     */
    _listByManagedInstanceNext(resourceGroupName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, nextLink, options }, listByManagedInstanceNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$14 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$Y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstancePrivateEndpointConnection
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$14
};
const createOrUpdateOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedInstancePrivateEndpointConnection
        },
        201: {
            bodyMapper: ManagedInstancePrivateEndpointConnection
        },
        202: {
            bodyMapper: ManagedInstancePrivateEndpointConnection
        },
        204: {
            bodyMapper: ManagedInstancePrivateEndpointConnection
        },
        default: {}
    },
    requestBody: parameters52,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$14
};
const deleteOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        privateEndpointConnectionName
    ],
    serializer: serializer$14
};
const listByManagedInstanceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstancePrivateEndpointConnectionListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$14
};
const listByManagedInstanceNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstancePrivateEndpointConnectionListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$14
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedInstancePrivateLinkResources operations. */
class ManagedInstancePrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class ManagedInstancePrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the private link resources for SQL server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listByManagedInstance(resourceGroupName, managedInstanceName, options) {
        const iter = this.listByManagedInstancePagingAll(resourceGroupName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByManagedInstancePagingPage(resourceGroupName, managedInstanceName, options);
            }
        };
    }
    listByManagedInstancePagingPage(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByManagedInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByManagedInstance(resourceGroupName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByManagedInstanceNext(resourceGroupName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByManagedInstancePagingAll(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByManagedInstancePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByManagedInstancePagingPage(resourceGroupName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the private link resources for SQL server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listByManagedInstance(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, listByManagedInstanceOperationSpec$2);
    }
    /**
     * Gets a private link resource for SQL server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param groupName The name of the private link resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, groupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, groupName, options }, getOperationSpec$Z);
    }
    /**
     * ListByManagedInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListByManagedInstance method.
     * @param options The options parameters.
     */
    _listByManagedInstanceNext(resourceGroupName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, nextLink, options }, listByManagedInstanceNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$15 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByManagedInstanceOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstancePrivateLinkListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const getOperationSpec$Z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/privateLinkResources/{groupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstancePrivateLink
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        groupName
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const listByManagedInstanceNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstancePrivateLinkListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$15
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ManagedInstanceTdeCertificates operations. */
class ManagedInstanceTdeCertificatesImpl {
    /**
     * Initialize a new instance of the class ManagedInstanceTdeCertificates class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a TDE certificate for a given server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param parameters The requested TDE certificate to be created or updated.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, managedInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, managedInstanceName, parameters, options }, createOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates a TDE certificate for a given server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param parameters The requested TDE certificate to be created or updated.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, managedInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, managedInstanceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$16 = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/tdeCertificates",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    requestBody: parameters53,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$16
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedInstanceVulnerabilityAssessments operations. */
class ManagedInstanceVulnerabilityAssessmentsImpl {
    /**
     * Initialize a new instance of the class ManagedInstanceVulnerabilityAssessments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the managed instance's vulnerability assessment policies.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance for which the vulnerability assessments
     *                            is defined.
     * @param options The options parameters.
     */
    listByInstance(resourceGroupName, managedInstanceName, options) {
        const iter = this.listByInstancePagingAll(resourceGroupName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options);
            }
        };
    }
    listByInstancePagingPage(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByInstance(resourceGroupName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByInstanceNext(resourceGroupName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByInstancePagingAll(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the managed instance's vulnerability assessment.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance for which the vulnerability assessment
     *                            is defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, vulnerabilityAssessmentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            vulnerabilityAssessmentName,
            options
        }, getOperationSpec$_);
    }
    /**
     * Creates or updates the managed instance's vulnerability assessment. Learn more about setting SQL
     * vulnerability assessment with managed identity -
     * https://docs.microsoft.com/azure/azure-sql/database/sql-database-vulnerability-assessment-storage
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance for which the vulnerability assessment
     *                            is defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param parameters The requested resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, managedInstanceName, vulnerabilityAssessmentName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            vulnerabilityAssessmentName,
            parameters,
            options
        }, createOrUpdateOperationSpec$D);
    }
    /**
     * Removes the managed instance's vulnerability assessment.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance for which the vulnerability assessment
     *                            is defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    delete(resourceGroupName, managedInstanceName, vulnerabilityAssessmentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            vulnerabilityAssessmentName,
            options
        }, deleteOperationSpec$n);
    }
    /**
     * Gets the managed instance's vulnerability assessment policies.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance for which the vulnerability assessments
     *                            is defined.
     * @param options The options parameters.
     */
    _listByInstance(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, listByInstanceOperationSpec$5);
    }
    /**
     * ListByInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance for which the vulnerability assessments
     *                            is defined.
     * @param nextLink The nextLink from the previous successful call to the ListByInstance method.
     * @param options The options parameters.
     */
    _listByInstanceNext(resourceGroupName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, nextLink, options }, listByInstanceNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$17 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$_ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceVulnerabilityAssessment
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vulnerabilityAssessmentName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$17
};
const createOrUpdateOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedInstanceVulnerabilityAssessment
        },
        201: {
            bodyMapper: ManagedInstanceVulnerabilityAssessment
        },
        default: {}
    },
    requestBody: parameters54,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vulnerabilityAssessmentName,
        managedInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$17
};
const deleteOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "DELETE",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vulnerabilityAssessmentName,
        managedInstanceName
    ],
    serializer: serializer$17
};
const listByInstanceOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/vulnerabilityAssessments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceVulnerabilityAssessmentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$17
};
const listByInstanceNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceVulnerabilityAssessmentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$17
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedRestorableDroppedDatabaseBackupShortTermRetentionPolicies operations. */
class ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesImpl {
    /**
     * Initialize a new instance of the class ManagedRestorableDroppedDatabaseBackupShortTermRetentionPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a dropped database's short term retention policy list.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param restorableDroppedDatabaseId
     * @param options The options parameters.
     */
    listByRestorableDroppedDatabase(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, options) {
        const iter = this.listByRestorableDroppedDatabasePagingAll(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByRestorableDroppedDatabasePagingPage(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, options);
            }
        };
    }
    listByRestorableDroppedDatabasePagingPage(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByRestorableDroppedDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByRestorableDroppedDatabase(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByRestorableDroppedDatabaseNext(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByRestorableDroppedDatabasePagingAll(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByRestorableDroppedDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByRestorableDroppedDatabasePagingPage(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a dropped database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param restorableDroppedDatabaseId
     * @param policyName The policy name.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, policyName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            restorableDroppedDatabaseId,
            policyName,
            options
        }, getOperationSpec$$);
    }
    /**
     * Sets a database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param restorableDroppedDatabaseId
     * @param policyName The policy name. Should always be "default".
     * @param parameters The short term retention policy info.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                restorableDroppedDatabaseId,
                policyName,
                parameters,
                options
            }, createOrUpdateOperationSpec$E);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Sets a database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param restorableDroppedDatabaseId
     * @param policyName The policy name. Should always be "default".
     * @param parameters The short term retention policy info.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, policyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Sets a database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param restorableDroppedDatabaseId
     * @param policyName The policy name. Should always be "default".
     * @param parameters The short term retention policy info.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                restorableDroppedDatabaseId,
                policyName,
                parameters,
                options
            }, updateOperationSpec$c);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Sets a database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param restorableDroppedDatabaseId
     * @param policyName The policy name. Should always be "default".
     * @param parameters The short term retention policy info.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, policyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a dropped database's short term retention policy list.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param restorableDroppedDatabaseId
     * @param options The options parameters.
     */
    _listByRestorableDroppedDatabase(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            restorableDroppedDatabaseId,
            options
        }, listByRestorableDroppedDatabaseOperationSpec);
    }
    /**
     * ListByRestorableDroppedDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param restorableDroppedDatabaseId
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListByRestorableDroppedDatabase method.
     * @param options The options parameters.
     */
    _listByRestorableDroppedDatabaseNext(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            restorableDroppedDatabaseId,
            nextLink,
            options
        }, listByRestorableDroppedDatabaseNextOperationSpec);
    }
}
// Operation Specifications
const serializer$18 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$$ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/restorableDroppedDatabases/{restorableDroppedDatabaseId}/backupShortTermRetentionPolicies/{policyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        policyName1,
        restorableDroppedDatabaseId
    ],
    headerParameters: [accept],
    serializer: serializer$18
};
const createOrUpdateOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/restorableDroppedDatabases/{restorableDroppedDatabaseId}/backupShortTermRetentionPolicies/{policyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        201: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        202: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        204: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        default: {}
    },
    requestBody: parameters38,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        policyName1,
        restorableDroppedDatabaseId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$18
};
const updateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/restorableDroppedDatabases/{restorableDroppedDatabaseId}/backupShortTermRetentionPolicies/{policyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        201: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        202: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        204: {
            bodyMapper: ManagedBackupShortTermRetentionPolicy
        },
        default: {}
    },
    requestBody: parameters38,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        policyName1,
        restorableDroppedDatabaseId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$18
};
const listByRestorableDroppedDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/restorableDroppedDatabases/{restorableDroppedDatabaseId}/backupShortTermRetentionPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedBackupShortTermRetentionPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        restorableDroppedDatabaseId
    ],
    headerParameters: [accept],
    serializer: serializer$18
};
const listByRestorableDroppedDatabaseNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedBackupShortTermRetentionPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName,
        restorableDroppedDatabaseId
    ],
    headerParameters: [accept],
    serializer: serializer$18
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedServerSecurityAlertPolicies operations. */
class ManagedServerSecurityAlertPoliciesImpl {
    /**
     * Initialize a new instance of the class ManagedServerSecurityAlertPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the managed server's threat detection policies.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listByInstance(resourceGroupName, managedInstanceName, options) {
        const iter = this.listByInstancePagingAll(resourceGroupName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options);
            }
        };
    }
    listByInstancePagingPage(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByInstance(resourceGroupName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByInstanceNext(resourceGroupName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByInstancePagingAll(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a managed server's threat detection policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param securityAlertPolicyName The name of the security alert policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, securityAlertPolicyName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            securityAlertPolicyName,
            options
        }, getOperationSpec$10);
    }
    /**
     * Creates or updates a threat detection policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param securityAlertPolicyName The name of the security alert policy.
     * @param parameters The managed server security alert policy.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, managedInstanceName, securityAlertPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                managedInstanceName,
                securityAlertPolicyName,
                parameters,
                options
            }, createOrUpdateOperationSpec$F);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a threat detection policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param securityAlertPolicyName The name of the security alert policy.
     * @param parameters The managed server security alert policy.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, managedInstanceName, securityAlertPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, managedInstanceName, securityAlertPolicyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the managed server's threat detection policies.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listByInstance(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, listByInstanceOperationSpec$6);
    }
    /**
     * ListByInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListByInstance method.
     * @param options The options parameters.
     */
    _listByInstanceNext(resourceGroupName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, nextLink, options }, listByInstanceNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$19 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$10 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/securityAlertPolicies/{securityAlertPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedServerSecurityAlertPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        securityAlertPolicyName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$19
};
const createOrUpdateOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/securityAlertPolicies/{securityAlertPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedServerSecurityAlertPolicy
        },
        201: {
            bodyMapper: ManagedServerSecurityAlertPolicy
        },
        202: {
            bodyMapper: ManagedServerSecurityAlertPolicy
        },
        204: {
            bodyMapper: ManagedServerSecurityAlertPolicy
        },
        default: {}
    },
    requestBody: parameters55,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        securityAlertPolicyName,
        managedInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$19
};
const listByInstanceOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/securityAlertPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedServerSecurityAlertPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$19
};
const listByInstanceNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedServerSecurityAlertPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$19
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available SQL Rest API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available SQL Rest API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$1a = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/providers/Microsoft.Sql/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$1a
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$1a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing OperationsHealthOperations operations. */
class OperationsHealthOperationsImpl {
    /**
     * Initialize a new instance of the class OperationsHealthOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a service operation health status.
     * @param locationName The name of the region where the resource is located.
     * @param options The options parameters.
     */
    listByLocation(locationName, options) {
        const iter = this.listByLocationPagingAll(locationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByLocationPagingPage(locationName, options);
            }
        };
    }
    listByLocationPagingPage(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingPage_1() {
            let result = yield tslib.__await(this._listByLocation(locationName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByLocationNext(locationName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByLocationPagingAll(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLocationPagingPage(locationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a service operation health status.
     * @param locationName The name of the region where the resource is located.
     * @param options The options parameters.
     */
    _listByLocation(locationName, options) {
        return this.client.sendOperationRequest({ locationName, options }, listByLocationOperationSpec$3);
    }
    /**
     * ListByLocationNext
     * @param locationName The name of the region where the resource is located.
     * @param nextLink The nextLink from the previous successful call to the ListByLocation method.
     * @param options The options parameters.
     */
    _listByLocationNext(locationName, nextLink, options) {
        return this.client.sendOperationRequest({ locationName, nextLink, options }, listByLocationNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$1b = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByLocationOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/operationsHealth",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationsHealthListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1b
};
const listByLocationNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationsHealthListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all private endpoint connections on a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a private endpoint connection.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, privateEndpointConnectionName, options }, getOperationSpec$11);
    }
    /**
     * Approve or reject a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param privateEndpointConnectionName
     * @param parameters A private endpoint connection
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, privateEndpointConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                privateEndpointConnectionName,
                parameters,
                options
            }, createOrUpdateOperationSpec$G);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Approve or reject a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param privateEndpointConnectionName
     * @param parameters A private endpoint connection
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, privateEndpointConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, privateEndpointConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param privateEndpointConnectionName
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, privateEndpointConnectionName, options }, deleteOperationSpec$o);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param privateEndpointConnectionName
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all private endpoint connections on a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$d);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$1c = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$11 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1c
};
const createOrUpdateOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        201: {
            bodyMapper: PrivateEndpointConnection
        },
        202: {
            bodyMapper: PrivateEndpointConnection
        },
        204: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {}
    },
    requestBody: parameters56,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1c
};
const deleteOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        privateEndpointConnectionName
    ],
    serializer: serializer$1c
};
const listByServerOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1c
};
const listByServerNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateLinkResources operations. */
class PrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the private link resources for SQL server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the private link resources for SQL server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$e);
    }
    /**
     * Gets a private link resource for SQL server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param groupName The name of the private link resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, groupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, groupName, options }, getOperationSpec$12);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$a);
    }
}
// Operation Specifications
const serializer$1d = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByServerOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1d
};
const getOperationSpec$12 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/privateLinkResources/{groupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResource
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        groupName
    ],
    headerParameters: [accept],
    serializer: serializer$1d
};
const listByServerNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RecoverableManagedDatabases operations. */
class RecoverableManagedDatabasesImpl {
    /**
     * Initialize a new instance of the class RecoverableManagedDatabases class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of recoverable managed databases.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listByInstance(resourceGroupName, managedInstanceName, options) {
        const iter = this.listByInstancePagingAll(resourceGroupName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options);
            }
        };
    }
    listByInstancePagingPage(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByInstance(resourceGroupName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByInstanceNext(resourceGroupName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByInstancePagingAll(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of recoverable managed databases.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listByInstance(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, listByInstanceOperationSpec$7);
    }
    /**
     * Gets a recoverable managed database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param recoverableDatabaseName
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, recoverableDatabaseName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            recoverableDatabaseName,
            options
        }, getOperationSpec$13);
    }
    /**
     * ListByInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListByInstance method.
     * @param options The options parameters.
     */
    _listByInstanceNext(resourceGroupName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, nextLink, options }, listByInstanceNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$1e = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByInstanceOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/recoverableDatabases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecoverableManagedDatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1e
};
const getOperationSpec$13 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/recoverableDatabases/{recoverableDatabaseName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecoverableManagedDatabase
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        recoverableDatabaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1e
};
const listByInstanceNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RecoverableManagedDatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorePoints operations. */
class RestorePointsImpl {
    /**
     * Initialize a new instance of the class RestorePoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of database restore points.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of database restore points.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$m);
    }
    /**
     * Creates a restore point for a data warehouse.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters The definition for creating the restore point of this database.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, serverName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, databaseName, parameters, options }, createOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates a restore point for a data warehouse.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters The definition for creating the restore point of this database.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, serverName, databaseName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, serverName, databaseName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a restore point.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param restorePointName The name of the restore point.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, restorePointName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            restorePointName,
            options
        }, getOperationSpec$14);
    }
    /**
     * Deletes a restore point.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param restorePointName The name of the restore point.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serverName, databaseName, restorePointName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            restorePointName,
            options
        }, deleteOperationSpec$p);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$j);
    }
}
// Operation Specifications
const serializer$1f = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByDatabaseOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/restorePoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorePointListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1f
};
const createOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/restorePoints",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RestorePoint
        },
        201: {
            bodyMapper: RestorePoint
        },
        202: {
            bodyMapper: RestorePoint
        },
        204: {
            bodyMapper: RestorePoint
        },
        default: {}
    },
    requestBody: parameters57,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1f
};
const getOperationSpec$14 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/restorePoints/{restorePointName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorePoint
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        restorePointName
    ],
    headerParameters: [accept],
    serializer: serializer$1f
};
const deleteOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/restorePoints/{restorePointName}",
    httpMethod: "DELETE",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        restorePointName
    ],
    serializer: serializer$1f
};
const listByDatabaseNextOperationSpec$j = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorePointListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SensitivityLabels operations. */
class SensitivityLabelsImpl {
    /**
     * Initialize a new instance of the class SensitivityLabels class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the sensitivity labels of a given database
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listCurrentByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listCurrentByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listCurrentByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listCurrentByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCurrentByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listCurrentByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listCurrentByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listCurrentByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCurrentByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCurrentByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the sensitivity labels of a given database
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listRecommendedByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listRecommendedByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listRecommendedByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listRecommendedByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendedByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listRecommendedByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listRecommendedByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listRecommendedByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRecommendedByDatabasePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listRecommendedByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the sensitivity labels of a given database
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listCurrentByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listCurrentByDatabaseOperationSpec$1);
    }
    /**
     * Update sensitivity labels of a given database using an operations batch.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters A list of sensitivity label update operations.
     * @param options The options parameters.
     */
    update(resourceGroupName, serverName, databaseName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, parameters, options }, updateOperationSpec$d);
    }
    /**
     * Gets the sensitivity labels of a given database
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listRecommendedByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listRecommendedByDatabaseOperationSpec$1);
    }
    /**
     * Enables sensitivity recommendations on a given column (recommendations are enabled by default on all
     * columns)
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param options The options parameters.
     */
    enableRecommendation(resourceGroupName, serverName, databaseName, schemaName, tableName, columnName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            schemaName,
            tableName,
            columnName,
            options
        }, enableRecommendationOperationSpec$1);
    }
    /**
     * Disables sensitivity recommendations on a given column
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param options The options parameters.
     */
    disableRecommendation(resourceGroupName, serverName, databaseName, schemaName, tableName, columnName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            schemaName,
            tableName,
            columnName,
            options
        }, disableRecommendationOperationSpec$1);
    }
    /**
     * Gets the sensitivity label of a given column
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param sensitivityLabelSource The source of the sensitivity label.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, schemaName, tableName, columnName, sensitivityLabelSource, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            schemaName,
            tableName,
            columnName,
            sensitivityLabelSource,
            options
        }, getOperationSpec$15);
    }
    /**
     * Creates or updates the sensitivity label of a given column
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param parameters The column sensitivity label resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, databaseName, schemaName, tableName, columnName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            schemaName,
            tableName,
            columnName,
            parameters,
            options
        }, createOrUpdateOperationSpec$H);
    }
    /**
     * Deletes the sensitivity label of a given column
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param schemaName The name of the schema.
     * @param tableName The name of the table.
     * @param columnName The name of the column.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serverName, databaseName, schemaName, tableName, columnName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            schemaName,
            tableName,
            columnName,
            options
        }, deleteOperationSpec$q);
    }
    /**
     * ListCurrentByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListCurrentByDatabase method.
     * @param options The options parameters.
     */
    _listCurrentByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listCurrentByDatabaseNextOperationSpec$1);
    }
    /**
     * ListRecommendedByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListRecommendedByDatabase
     *                 method.
     * @param options The options parameters.
     */
    _listRecommendedByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listRecommendedByDatabaseNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1g = coreClient.createSerializer(Mappers, /* isXml */ false);
const listCurrentByDatabaseOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/currentSensitivityLabels",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SensitivityLabelListResult
        },
        default: {}
    },
    queryParameters: [
        skipToken,
        apiVersion2,
        filter1,
        count
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1g
};
const updateOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/currentSensitivityLabels",
    httpMethod: "PATCH",
    responses: { 200: {}, default: {} },
    requestBody: parameters44,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$1g
};
const listRecommendedByDatabaseOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/recommendedSensitivityLabels",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SensitivityLabelListResult
        },
        default: {}
    },
    queryParameters: [
        skipToken,
        apiVersion2,
        filter1,
        includeDisabledRecommendations
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1g
};
const enableRecommendationOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}/sensitivityLabels/{sensitivityLabelSource}/enable",
    httpMethod: "POST",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        schemaName,
        tableName,
        columnName,
        sensitivityLabelSource2
    ],
    serializer: serializer$1g
};
const disableRecommendationOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}/sensitivityLabels/{sensitivityLabelSource}/disable",
    httpMethod: "POST",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        schemaName,
        tableName,
        columnName,
        sensitivityLabelSource2
    ],
    serializer: serializer$1g
};
const getOperationSpec$15 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}/sensitivityLabels/{sensitivityLabelSource}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SensitivityLabel
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        schemaName,
        tableName,
        columnName,
        sensitivityLabelSource
    ],
    headerParameters: [accept],
    serializer: serializer$1g
};
const createOrUpdateOperationSpec$H = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}/sensitivityLabels/{sensitivityLabelSource}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SensitivityLabel
        },
        201: {
            bodyMapper: SensitivityLabel
        },
        default: {}
    },
    requestBody: parameters43,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        schemaName,
        tableName,
        columnName,
        sensitivityLabelSource1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1g
};
const deleteOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/columns/{columnName}/sensitivityLabels/{sensitivityLabelSource}",
    httpMethod: "DELETE",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        schemaName,
        tableName,
        columnName,
        sensitivityLabelSource1
    ],
    serializer: serializer$1g
};
const listCurrentByDatabaseNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SensitivityLabelListResult
        },
        default: {}
    },
    queryParameters: [
        skipToken,
        apiVersion2,
        filter1,
        count
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1g
};
const listRecommendedByDatabaseNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SensitivityLabelListResult
        },
        default: {}
    },
    queryParameters: [
        skipToken,
        apiVersion2,
        filter1,
        includeDisabledRecommendations
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing RecommendedSensitivityLabels operations. */
class RecommendedSensitivityLabelsImpl {
    /**
     * Initialize a new instance of the class RecommendedSensitivityLabels class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Update recommended sensitivity labels states of a given database using an operations batch.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param parameters A list of recommended sensitivity label update operations.
     * @param options The options parameters.
     */
    update(resourceGroupName, serverName, databaseName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, parameters, options }, updateOperationSpec$e);
    }
}
// Operation Specifications
const serializer$1h = coreClient.createSerializer(Mappers, /* isXml */ false);
const updateOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/recommendedSensitivityLabels",
    httpMethod: "PATCH",
    responses: { 200: {}, default: {} },
    requestBody: parameters45,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$1h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ServerAdvisors operations. */
class ServerAdvisorsImpl {
    /**
     * Initialize a new instance of the class ServerAdvisors class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of server advisors.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$f);
    }
    /**
     * Gets a server advisor.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param advisorName The name of the Server Advisor.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, advisorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, advisorName, options }, getOperationSpec$16);
    }
    /**
     * Updates a server advisor.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param advisorName The name of the Server Advisor.
     * @param parameters The requested advisor resource state.
     * @param options The options parameters.
     */
    update(resourceGroupName, serverName, advisorName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, advisorName, parameters, options }, updateOperationSpec$f);
    }
}
// Operation Specifications
const serializer$1i = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByServerOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/advisors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "Advisor" } }
                }
            }
        },
        default: {}
    },
    queryParameters: [apiVersion2, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const getOperationSpec$16 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/advisors/{advisorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Advisor
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        advisorName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const updateOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/advisors/{advisorName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Advisor
        },
        default: {}
    },
    requestBody: parameters16,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        advisorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ServerAutomaticTuningOperations operations. */
class ServerAutomaticTuningOperationsImpl {
    /**
     * Initialize a new instance of the class ServerAutomaticTuningOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves server automatic tuning options.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, getOperationSpec$17);
    }
    /**
     * Update automatic tuning options on server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param parameters The requested automatic tuning resource state.
     * @param options The options parameters.
     */
    update(resourceGroupName, serverName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, parameters, options }, updateOperationSpec$g);
    }
}
// Operation Specifications
const serializer$1j = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$17 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/automaticTuning/current",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerAutomaticTuning
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1j
};
const updateOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/automaticTuning/current",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ServerAutomaticTuning
        },
        default: {}
    },
    requestBody: parameters58,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServerAzureADAdministrators operations. */
class ServerAzureADAdministratorsImpl {
    /**
     * Initialize a new instance of the class ServerAzureADAdministrators class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of Azure Active Directory administrators in a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a Azure Active Directory administrator.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param administratorName The name of server active directory administrator.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, administratorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, administratorName, options }, getOperationSpec$18);
    }
    /**
     * Creates or updates an existing Azure Active Directory administrator.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param administratorName The name of server active directory administrator.
     * @param parameters The requested Azure Active Directory administrator Resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, administratorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, administratorName, parameters, options }, createOrUpdateOperationSpec$I);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates an existing Azure Active Directory administrator.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param administratorName The name of server active directory administrator.
     * @param parameters The requested Azure Active Directory administrator Resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, administratorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, administratorName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the Azure Active Directory administrator with the given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param administratorName The name of server active directory administrator.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, administratorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, administratorName, options }, deleteOperationSpec$r);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes the Azure Active Directory administrator with the given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param administratorName The name of server active directory administrator.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, administratorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, administratorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of Azure Active Directory administrators in a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$g);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$b);
    }
}
// Operation Specifications
const serializer$1k = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$18 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/administrators/{administratorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerAzureADAdministrator
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        administratorName
    ],
    headerParameters: [accept],
    serializer: serializer$1k
};
const createOrUpdateOperationSpec$I = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/administrators/{administratorName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServerAzureADAdministrator
        },
        201: {
            bodyMapper: ServerAzureADAdministrator
        },
        202: {
            bodyMapper: ServerAzureADAdministrator
        },
        204: {
            bodyMapper: ServerAzureADAdministrator
        },
        default: {}
    },
    requestBody: parameters59,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        administratorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1k
};
const deleteOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/administrators/{administratorName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        administratorName
    ],
    serializer: serializer$1k
};
const listByServerOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/administrators",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AdministratorListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1k
};
const listByServerNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AdministratorListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServerAzureADOnlyAuthentications operations. */
class ServerAzureADOnlyAuthenticationsImpl {
    /**
     * Initialize a new instance of the class ServerAzureADOnlyAuthentications class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of server Azure Active Directory only authentications.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a specific Azure Active Directory only authentication property.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param authenticationName The name of server azure active directory only authentication.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, authenticationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, authenticationName, options }, getOperationSpec$19);
    }
    /**
     * Sets Server Active Directory only authentication property or updates an existing server Active
     * Directory only authentication property.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param authenticationName The name of server azure active directory only authentication.
     * @param parameters The required parameters for creating or updating an Active Directory only
     *                   authentication property.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, authenticationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                authenticationName,
                parameters,
                options
            }, createOrUpdateOperationSpec$J);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Sets Server Active Directory only authentication property or updates an existing server Active
     * Directory only authentication property.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param authenticationName The name of server azure active directory only authentication.
     * @param parameters The required parameters for creating or updating an Active Directory only
     *                   authentication property.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, authenticationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, authenticationName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing server Active Directory only authentication property.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param authenticationName The name of server azure active directory only authentication.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, authenticationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, authenticationName, options }, deleteOperationSpec$s);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes an existing server Active Directory only authentication property.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param authenticationName The name of server azure active directory only authentication.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, authenticationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, authenticationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of server Azure Active Directory only authentications.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$h);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$c);
    }
}
// Operation Specifications
const serializer$1l = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$19 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/azureADOnlyAuthentications/{authenticationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerAzureADOnlyAuthentication
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        authenticationName
    ],
    headerParameters: [accept],
    serializer: serializer$1l
};
const createOrUpdateOperationSpec$J = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/azureADOnlyAuthentications/{authenticationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServerAzureADOnlyAuthentication
        },
        201: {
            bodyMapper: ServerAzureADOnlyAuthentication
        },
        202: {
            bodyMapper: ServerAzureADOnlyAuthentication
        },
        204: {
            bodyMapper: ServerAzureADOnlyAuthentication
        },
        default: {}
    },
    requestBody: parameters60,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        authenticationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1l
};
const deleteOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/azureADOnlyAuthentications/{authenticationName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        authenticationName
    ],
    serializer: serializer$1l
};
const listByServerOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/azureADOnlyAuthentications",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureADOnlyAuthListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1l
};
const listByServerNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureADOnlyAuthListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServerDevOpsAuditSettings operations. */
class ServerDevOpsAuditSettingsImpl {
    /**
     * Initialize a new instance of the class ServerDevOpsAuditSettings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists DevOps audit settings of a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a server's DevOps audit settings.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param devOpsAuditingSettingsName The name of the devops audit settings. This should always be
     *                                   'default'.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, devOpsAuditingSettingsName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, devOpsAuditingSettingsName, options }, getOperationSpec$1a);
    }
    /**
     * Creates or updates a server's DevOps audit settings.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param devOpsAuditingSettingsName The name of the devops audit settings. This should always be
     *                                   'default'.
     * @param parameters Properties of DevOps audit settings
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, devOpsAuditingSettingsName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                devOpsAuditingSettingsName,
                parameters,
                options
            }, createOrUpdateOperationSpec$K);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
        });
    }
    /**
     * Creates or updates a server's DevOps audit settings.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param devOpsAuditingSettingsName The name of the devops audit settings. This should always be
     *                                   'default'.
     * @param parameters Properties of DevOps audit settings
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, devOpsAuditingSettingsName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, devOpsAuditingSettingsName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists DevOps audit settings of a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$i);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$d);
    }
}
// Operation Specifications
const serializer$1m = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/devOpsAuditingSettings/{devOpsAuditingSettingsName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerDevOpsAuditingSettings
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        devOpsAuditingSettingsName
    ],
    headerParameters: [accept],
    serializer: serializer$1m
};
const createOrUpdateOperationSpec$K = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/devOpsAuditingSettings/{devOpsAuditingSettingsName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServerDevOpsAuditingSettings
        },
        201: {
            bodyMapper: ServerDevOpsAuditingSettings
        },
        202: {
            bodyMapper: ServerDevOpsAuditingSettings
        },
        204: {
            bodyMapper: ServerDevOpsAuditingSettings
        },
        default: {}
    },
    requestBody: parameters61,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        devOpsAuditingSettingsName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1m
};
const listByServerOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/devOpsAuditingSettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerDevOpsAuditSettingsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1m
};
const listByServerNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerDevOpsAuditSettingsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServerDnsAliases operations. */
class ServerDnsAliasesImpl {
    /**
     * Initialize a new instance of the class ServerDnsAliases class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of server DNS aliases for a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server that the alias is pointing to.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a server DNS alias.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server that the alias is pointing to.
     * @param dnsAliasName The name of the server dns alias.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, dnsAliasName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, dnsAliasName, options }, getOperationSpec$1b);
    }
    /**
     * Creates a server DNS alias.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server that the alias is pointing to.
     * @param dnsAliasName The name of the server dns alias.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, dnsAliasName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, dnsAliasName, options }, createOrUpdateOperationSpec$L);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates a server DNS alias.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server that the alias is pointing to.
     * @param dnsAliasName The name of the server dns alias.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, dnsAliasName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, dnsAliasName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the server DNS alias with the given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server that the alias is pointing to.
     * @param dnsAliasName The name of the server dns alias.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, dnsAliasName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, dnsAliasName, options }, deleteOperationSpec$t);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes the server DNS alias with the given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server that the alias is pointing to.
     * @param dnsAliasName The name of the server dns alias.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, dnsAliasName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, dnsAliasName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of server DNS aliases for a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server that the alias is pointing to.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$j);
    }
    /**
     * Acquires server DNS alias from another server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server that the alias is pointing to.
     * @param dnsAliasName The name of the server dns alias.
     * @param parameters A server dns alias acquisition request.
     * @param options The options parameters.
     */
    beginAcquire(resourceGroupName, serverName, dnsAliasName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, dnsAliasName, parameters, options }, acquireOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Acquires server DNS alias from another server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server that the alias is pointing to.
     * @param dnsAliasName The name of the server dns alias.
     * @param parameters A server dns alias acquisition request.
     * @param options The options parameters.
     */
    beginAcquireAndWait(resourceGroupName, serverName, dnsAliasName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginAcquire(resourceGroupName, serverName, dnsAliasName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server that the alias is pointing to.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$e);
    }
}
// Operation Specifications
const serializer$1n = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/dnsAliases/{dnsAliasName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerDnsAlias
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        dnsAliasName
    ],
    headerParameters: [accept],
    serializer: serializer$1n
};
const createOrUpdateOperationSpec$L = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/dnsAliases/{dnsAliasName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServerDnsAlias
        },
        201: {
            bodyMapper: ServerDnsAlias
        },
        202: {
            bodyMapper: ServerDnsAlias
        },
        204: {
            bodyMapper: ServerDnsAlias
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        dnsAliasName
    ],
    headerParameters: [accept],
    serializer: serializer$1n
};
const deleteOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/dnsAliases/{dnsAliasName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        dnsAliasName
    ],
    serializer: serializer$1n
};
const listByServerOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/dnsAliases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerDnsAliasListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1n
};
const acquireOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/dnsAliases/{dnsAliasName}/acquire",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ServerDnsAlias
        },
        201: {
            bodyMapper: ServerDnsAlias
        },
        202: {
            bodyMapper: ServerDnsAlias
        },
        204: {
            bodyMapper: ServerDnsAlias
        },
        default: {}
    },
    requestBody: parameters62,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        dnsAliasName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1n
};
const listByServerNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerDnsAliasListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServerKeys operations. */
class ServerKeysImpl {
    /**
     * Initialize a new instance of the class ServerKeys class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of server keys.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of server keys.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$k);
    }
    /**
     * Gets a server key.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param keyName The name of the server key to be retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, keyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, keyName, options }, getOperationSpec$1c);
    }
    /**
     * Creates or updates a server key.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param keyName The name of the server key to be operated on (updated or created). The key name is
     *                required to be in the format of 'vault_key_version'. For example, if the keyId is
     *                https://YourVaultName.vault.azure.net/keys/YourKeyName/YourKeyVersion, then the server key name
     *                should be formatted as: YourVaultName_YourKeyName_YourKeyVersion
     * @param parameters The requested server key resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, keyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, keyName, parameters, options }, createOrUpdateOperationSpec$M);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a server key.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param keyName The name of the server key to be operated on (updated or created). The key name is
     *                required to be in the format of 'vault_key_version'. For example, if the keyId is
     *                https://YourVaultName.vault.azure.net/keys/YourKeyName/YourKeyVersion, then the server key name
     *                should be formatted as: YourVaultName_YourKeyName_YourKeyVersion
     * @param parameters The requested server key resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, keyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, keyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the server key with the given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param keyName The name of the server key to be deleted.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, keyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, keyName, options }, deleteOperationSpec$u);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes the server key with the given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param keyName The name of the server key to be deleted.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, keyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, keyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$f);
    }
}
// Operation Specifications
const serializer$1o = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByServerOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/keys",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerKeyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1o
};
const getOperationSpec$1c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/keys/{keyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerKey
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        keyName
    ],
    headerParameters: [accept],
    serializer: serializer$1o
};
const createOrUpdateOperationSpec$M = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/keys/{keyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServerKey
        },
        201: {
            bodyMapper: ServerKey
        },
        202: {
            bodyMapper: ServerKey
        },
        204: {
            bodyMapper: ServerKey
        },
        default: {}
    },
    requestBody: parameters63,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        keyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1o
};
const deleteOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/keys/{keyName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        keyName
    ],
    serializer: serializer$1o
};
const listByServerNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerKeyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1o
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServerOperations operations. */
class ServerOperationsImpl {
    /**
     * Initialize a new instance of the class ServerOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of operations performed on the server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of operations performed on the server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$l);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$g);
    }
}
// Operation Specifications
const serializer$1p = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByServerOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerOperationListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1p
};
const listByServerNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerOperationListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1p
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServerSecurityAlertPolicies operations. */
class ServerSecurityAlertPoliciesImpl {
    /**
     * Initialize a new instance of the class ServerSecurityAlertPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the server's threat detection policies.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a server's security alert policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param securityAlertPolicyName The name of the security alert policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, securityAlertPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, securityAlertPolicyName, options }, getOperationSpec$1d);
    }
    /**
     * Creates or updates a threat detection policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param securityAlertPolicyName The name of the threat detection policy.
     * @param parameters The server security alert policy.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, securityAlertPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                securityAlertPolicyName,
                parameters,
                options
            }, createOrUpdateOperationSpec$N);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a threat detection policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param securityAlertPolicyName The name of the threat detection policy.
     * @param parameters The server security alert policy.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, securityAlertPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, securityAlertPolicyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the server's threat detection policies.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$m);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$h);
    }
}
// Operation Specifications
const serializer$1q = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/securityAlertPolicies/{securityAlertPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerSecurityAlertPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        securityAlertPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$1q
};
const createOrUpdateOperationSpec$N = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/securityAlertPolicies/{securityAlertPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServerSecurityAlertPolicy
        },
        201: {
            bodyMapper: ServerSecurityAlertPolicy
        },
        202: {
            bodyMapper: ServerSecurityAlertPolicy
        },
        204: {
            bodyMapper: ServerSecurityAlertPolicy
        },
        default: {}
    },
    requestBody: parameters64,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        securityAlertPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1q
};
const listByServerOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/securityAlertPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LogicalServerSecurityAlertPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1q
};
const listByServerNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LogicalServerSecurityAlertPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServerTrustGroups operations. */
class ServerTrustGroupsImpl {
    /**
     * Initialize a new instance of the class ServerTrustGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists a server trust group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param options The options parameters.
     */
    listByLocation(resourceGroupName, locationName, options) {
        const iter = this.listByLocationPagingAll(resourceGroupName, locationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByLocationPagingPage(resourceGroupName, locationName, options);
            }
        };
    }
    listByLocationPagingPage(resourceGroupName, locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingPage_1() {
            let result = yield tslib.__await(this._listByLocation(resourceGroupName, locationName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByLocationNext(resourceGroupName, locationName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByLocationPagingAll(resourceGroupName, locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLocationPagingPage(resourceGroupName, locationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a server trust groups by instance name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listByInstance(resourceGroupName, managedInstanceName, options) {
        const iter = this.listByInstancePagingAll(resourceGroupName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options);
            }
        };
    }
    listByInstancePagingPage(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByInstance(resourceGroupName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByInstanceNext(resourceGroupName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByInstancePagingAll(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a server trust group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param serverTrustGroupName The name of the server trust group.
     * @param options The options parameters.
     */
    get(resourceGroupName, locationName, serverTrustGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, locationName, serverTrustGroupName, options }, getOperationSpec$1e);
    }
    /**
     * Creates or updates a server trust group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param serverTrustGroupName The name of the server trust group.
     * @param parameters The server trust group parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, locationName, serverTrustGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                locationName,
                serverTrustGroupName,
                parameters,
                options
            }, createOrUpdateOperationSpec$O);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a server trust group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param serverTrustGroupName The name of the server trust group.
     * @param parameters The server trust group parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, locationName, serverTrustGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, locationName, serverTrustGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a server trust group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param serverTrustGroupName The name of the server trust group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, locationName, serverTrustGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, locationName, serverTrustGroupName, options }, deleteOperationSpec$v);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a server trust group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param serverTrustGroupName The name of the server trust group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, locationName, serverTrustGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, locationName, serverTrustGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists a server trust group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param options The options parameters.
     */
    _listByLocation(resourceGroupName, locationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, locationName, options }, listByLocationOperationSpec$4);
    }
    /**
     * Gets a server trust groups by instance name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listByInstance(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, listByInstanceOperationSpec$8);
    }
    /**
     * ListByLocationNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The name of the region where the resource is located.
     * @param nextLink The nextLink from the previous successful call to the ListByLocation method.
     * @param options The options parameters.
     */
    _listByLocationNext(resourceGroupName, locationName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, locationName, nextLink, options }, listByLocationNextOperationSpec$3);
    }
    /**
     * ListByInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListByInstance method.
     * @param options The options parameters.
     */
    _listByInstanceNext(resourceGroupName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, nextLink, options }, listByInstanceNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$1r = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/serverTrustGroups/{serverTrustGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerTrustGroup
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName,
        serverTrustGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1r
};
const createOrUpdateOperationSpec$O = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/serverTrustGroups/{serverTrustGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServerTrustGroup
        },
        201: {
            bodyMapper: ServerTrustGroup
        },
        202: {
            bodyMapper: ServerTrustGroup
        },
        204: {
            bodyMapper: ServerTrustGroup
        },
        default: {}
    },
    requestBody: parameters65,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName,
        serverTrustGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1r
};
const deleteOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/serverTrustGroups/{serverTrustGroupName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName,
        serverTrustGroupName
    ],
    serializer: serializer$1r
};
const listByLocationOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/serverTrustGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerTrustGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1r
};
const listByInstanceOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/serverTrustGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerTrustGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1r
};
const listByLocationNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerTrustGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1r
};
const listByInstanceNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerTrustGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1r
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServerVulnerabilityAssessments operations. */
class ServerVulnerabilityAssessmentsImpl {
    /**
     * Initialize a new instance of the class ServerVulnerabilityAssessments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the vulnerability assessment policies associated with a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the server's vulnerability assessment.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server for which the vulnerability assessment is defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, vulnerabilityAssessmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, vulnerabilityAssessmentName, options }, getOperationSpec$1f);
    }
    /**
     * Creates or updates the server's vulnerability assessment. Learn more about setting SQL vulnerability
     * assessment with managed identity -
     * https://docs.microsoft.com/azure/azure-sql/database/sql-database-vulnerability-assessment-storage
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server for which the vulnerability assessment is defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param parameters The requested resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, vulnerabilityAssessmentName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            vulnerabilityAssessmentName,
            parameters,
            options
        }, createOrUpdateOperationSpec$P);
    }
    /**
     * Removes the server's vulnerability assessment.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server for which the vulnerability assessment is defined.
     * @param vulnerabilityAssessmentName The name of the vulnerability assessment.
     * @param options The options parameters.
     */
    delete(resourceGroupName, serverName, vulnerabilityAssessmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, vulnerabilityAssessmentName, options }, deleteOperationSpec$w);
    }
    /**
     * Lists the vulnerability assessment policies associated with a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$n);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$i);
    }
}
// Operation Specifications
const serializer$1s = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerVulnerabilityAssessment
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        vulnerabilityAssessmentName
    ],
    headerParameters: [accept],
    serializer: serializer$1s
};
const createOrUpdateOperationSpec$P = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServerVulnerabilityAssessment
        },
        201: {
            bodyMapper: ServerVulnerabilityAssessment
        },
        default: {}
    },
    requestBody: parameters66,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        vulnerabilityAssessmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1s
};
const deleteOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/vulnerabilityAssessments/{vulnerabilityAssessmentName}",
    httpMethod: "DELETE",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        vulnerabilityAssessmentName
    ],
    serializer: serializer$1s
};
const listByServerOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/vulnerabilityAssessments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerVulnerabilityAssessmentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1s
};
const listByServerNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerVulnerabilityAssessmentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1s
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SqlAgent operations. */
class SqlAgentImpl {
    /**
     * Initialize a new instance of the class SqlAgent class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets current instance sql agent configuration.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, getOperationSpec$1g);
    }
    /**
     * Puts new sql agent configuration to instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param parameters A recoverable managed database resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, managedInstanceName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, parameters, options }, createOrUpdateOperationSpec$Q);
    }
}
// Operation Specifications
const serializer$1t = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/sqlAgent/current",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlAgentConfiguration
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1t
};
const createOrUpdateOperationSpec$Q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/sqlAgent/current",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SqlAgentConfiguration
        },
        default: {}
    },
    requestBody: parameters67,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1t
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SubscriptionUsages operations. */
class SubscriptionUsagesImpl {
    /**
     * Initialize a new instance of the class SubscriptionUsages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all subscription usage metrics in a given location.
     * @param locationName The name of the region where the resource is located.
     * @param options The options parameters.
     */
    listByLocation(locationName, options) {
        const iter = this.listByLocationPagingAll(locationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByLocationPagingPage(locationName, options);
            }
        };
    }
    listByLocationPagingPage(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingPage_1() {
            let result = yield tslib.__await(this._listByLocation(locationName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByLocationNext(locationName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByLocationPagingAll(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLocationPagingPage(locationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all subscription usage metrics in a given location.
     * @param locationName The name of the region where the resource is located.
     * @param options The options parameters.
     */
    _listByLocation(locationName, options) {
        return this.client.sendOperationRequest({ locationName, options }, listByLocationOperationSpec$5);
    }
    /**
     * Gets a subscription usage metric.
     * @param locationName The name of the region where the resource is located.
     * @param usageName Name of usage metric to return.
     * @param options The options parameters.
     */
    get(locationName, usageName, options) {
        return this.client.sendOperationRequest({ locationName, usageName, options }, getOperationSpec$1h);
    }
    /**
     * ListByLocationNext
     * @param locationName The name of the region where the resource is located.
     * @param nextLink The nextLink from the previous successful call to the ListByLocation method.
     * @param options The options parameters.
     */
    _listByLocationNext(locationName, nextLink, options) {
        return this.client.sendOperationRequest({ locationName, nextLink, options }, listByLocationNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$1u = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByLocationOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubscriptionUsageListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1u
};
const getOperationSpec$1h = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/usages/{usageName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubscriptionUsage
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        locationName,
        usageName
    ],
    headerParameters: [accept],
    serializer: serializer$1u
};
const listByLocationNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubscriptionUsageListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1u
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SyncAgents operations. */
class SyncAgentsImpl {
    /**
     * Initialize a new instance of the class SyncAgents class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists sync agents in a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server on which the sync agent is hosted.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists databases linked to a sync agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server on which the sync agent is hosted.
     * @param syncAgentName The name of the sync agent.
     * @param options The options parameters.
     */
    listLinkedDatabases(resourceGroupName, serverName, syncAgentName, options) {
        const iter = this.listLinkedDatabasesPagingAll(resourceGroupName, serverName, syncAgentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listLinkedDatabasesPagingPage(resourceGroupName, serverName, syncAgentName, options);
            }
        };
    }
    listLinkedDatabasesPagingPage(resourceGroupName, serverName, syncAgentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listLinkedDatabasesPagingPage_1() {
            let result = yield tslib.__await(this._listLinkedDatabases(resourceGroupName, serverName, syncAgentName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listLinkedDatabasesNext(resourceGroupName, serverName, syncAgentName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listLinkedDatabasesPagingAll(resourceGroupName, serverName, syncAgentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listLinkedDatabasesPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listLinkedDatabasesPagingPage(resourceGroupName, serverName, syncAgentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a sync agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server on which the sync agent is hosted.
     * @param syncAgentName The name of the sync agent.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, syncAgentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, syncAgentName, options }, getOperationSpec$1i);
    }
    /**
     * Creates or updates a sync agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server on which the sync agent is hosted.
     * @param syncAgentName The name of the sync agent.
     * @param parameters The requested sync agent resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, syncAgentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, syncAgentName, parameters, options }, createOrUpdateOperationSpec$R);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a sync agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server on which the sync agent is hosted.
     * @param syncAgentName The name of the sync agent.
     * @param parameters The requested sync agent resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, syncAgentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, syncAgentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a sync agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server on which the sync agent is hosted.
     * @param syncAgentName The name of the sync agent.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, syncAgentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, syncAgentName, options }, deleteOperationSpec$x);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a sync agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server on which the sync agent is hosted.
     * @param syncAgentName The name of the sync agent.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, syncAgentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, syncAgentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists sync agents in a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server on which the sync agent is hosted.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$o);
    }
    /**
     * Generates a sync agent key.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server on which the sync agent is hosted.
     * @param syncAgentName The name of the sync agent.
     * @param options The options parameters.
     */
    generateKey(resourceGroupName, serverName, syncAgentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, syncAgentName, options }, generateKeyOperationSpec);
    }
    /**
     * Lists databases linked to a sync agent.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server on which the sync agent is hosted.
     * @param syncAgentName The name of the sync agent.
     * @param options The options parameters.
     */
    _listLinkedDatabases(resourceGroupName, serverName, syncAgentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, syncAgentName, options }, listLinkedDatabasesOperationSpec);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server on which the sync agent is hosted.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$j);
    }
    /**
     * ListLinkedDatabasesNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server on which the sync agent is hosted.
     * @param syncAgentName The name of the sync agent.
     * @param nextLink The nextLink from the previous successful call to the ListLinkedDatabases method.
     * @param options The options parameters.
     */
    _listLinkedDatabasesNext(resourceGroupName, serverName, syncAgentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, syncAgentName, nextLink, options }, listLinkedDatabasesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1v = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/syncAgents/{syncAgentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncAgent
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        syncAgentName
    ],
    headerParameters: [accept],
    serializer: serializer$1v
};
const createOrUpdateOperationSpec$R = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/syncAgents/{syncAgentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SyncAgent
        },
        201: {
            bodyMapper: SyncAgent
        },
        202: {
            bodyMapper: SyncAgent
        },
        204: {
            bodyMapper: SyncAgent
        },
        default: {}
    },
    requestBody: parameters68,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        syncAgentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1v
};
const deleteOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/syncAgents/{syncAgentName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        syncAgentName
    ],
    serializer: serializer$1v
};
const listByServerOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/syncAgents",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncAgentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1v
};
const generateKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/syncAgents/{syncAgentName}/generateKey",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SyncAgentKeyProperties
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        syncAgentName
    ],
    headerParameters: [accept],
    serializer: serializer$1v
};
const listLinkedDatabasesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/syncAgents/{syncAgentName}/linkedDatabases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncAgentLinkedDatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        syncAgentName
    ],
    headerParameters: [accept],
    serializer: serializer$1v
};
const listByServerNextOperationSpec$j = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncAgentListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1v
};
const listLinkedDatabasesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncAgentLinkedDatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink,
        syncAgentName
    ],
    headerParameters: [accept],
    serializer: serializer$1v
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SyncGroups operations. */
class SyncGroupsImpl {
    /**
     * Initialize a new instance of the class SyncGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a collection of sync database ids.
     * @param locationName The name of the region where the resource is located.
     * @param options The options parameters.
     */
    listSyncDatabaseIds(locationName, options) {
        const iter = this.listSyncDatabaseIdsPagingAll(locationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSyncDatabaseIdsPagingPage(locationName, options);
            }
        };
    }
    listSyncDatabaseIdsPagingPage(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSyncDatabaseIdsPagingPage_1() {
            let result = yield tslib.__await(this._listSyncDatabaseIds(locationName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSyncDatabaseIdsNext(locationName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSyncDatabaseIdsPagingAll(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSyncDatabaseIdsPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSyncDatabaseIdsPagingPage(locationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a collection of hub database schemas.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param options The options parameters.
     */
    listHubSchemas(resourceGroupName, serverName, databaseName, syncGroupName, options) {
        const iter = this.listHubSchemasPagingAll(resourceGroupName, serverName, databaseName, syncGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listHubSchemasPagingPage(resourceGroupName, serverName, databaseName, syncGroupName, options);
            }
        };
    }
    listHubSchemasPagingPage(resourceGroupName, serverName, databaseName, syncGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHubSchemasPagingPage_1() {
            let result = yield tslib.__await(this._listHubSchemas(resourceGroupName, serverName, databaseName, syncGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listHubSchemasNext(resourceGroupName, serverName, databaseName, syncGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listHubSchemasPagingAll(resourceGroupName, serverName, databaseName, syncGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listHubSchemasPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listHubSchemasPagingPage(resourceGroupName, serverName, databaseName, syncGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a collection of sync group logs.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param startTime Get logs generated after this time.
     * @param endTime Get logs generated before this time.
     * @param typeParam The types of logs to retrieve.
     * @param options The options parameters.
     */
    listLogs(resourceGroupName, serverName, databaseName, syncGroupName, startTime, endTime, typeParam, options) {
        const iter = this.listLogsPagingAll(resourceGroupName, serverName, databaseName, syncGroupName, startTime, endTime, typeParam, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listLogsPagingPage(resourceGroupName, serverName, databaseName, syncGroupName, startTime, endTime, typeParam, options);
            }
        };
    }
    listLogsPagingPage(resourceGroupName, serverName, databaseName, syncGroupName, startTime, endTime, typeParam, options) {
        return tslib.__asyncGenerator(this, arguments, function* listLogsPagingPage_1() {
            let result = yield tslib.__await(this._listLogs(resourceGroupName, serverName, databaseName, syncGroupName, startTime, endTime, typeParam, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listLogsNext(resourceGroupName, serverName, databaseName, syncGroupName, startTime, endTime, continuationToken, typeParam, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listLogsPagingAll(resourceGroupName, serverName, databaseName, syncGroupName, startTime, endTime, typeParam, options) {
        return tslib.__asyncGenerator(this, arguments, function* listLogsPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listLogsPagingPage(resourceGroupName, serverName, databaseName, syncGroupName, startTime, endTime, typeParam, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Lists sync groups under a hub database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Gets a collection of sync database ids.
     * @param locationName The name of the region where the resource is located.
     * @param options The options parameters.
     */
    _listSyncDatabaseIds(locationName, options) {
        return this.client.sendOperationRequest({ locationName, options }, listSyncDatabaseIdsOperationSpec);
    }
    /**
     * Refreshes a hub database schema.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param options The options parameters.
     */
    beginRefreshHubSchema(resourceGroupName, serverName, databaseName, syncGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, databaseName, syncGroupName, options }, refreshHubSchemaOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Refreshes a hub database schema.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param options The options parameters.
     */
    beginRefreshHubSchemaAndWait(resourceGroupName, serverName, databaseName, syncGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRefreshHubSchema(resourceGroupName, serverName, databaseName, syncGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a collection of hub database schemas.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param options The options parameters.
     */
    _listHubSchemas(resourceGroupName, serverName, databaseName, syncGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, syncGroupName, options }, listHubSchemasOperationSpec);
    }
    /**
     * Gets a collection of sync group logs.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param startTime Get logs generated after this time.
     * @param endTime Get logs generated before this time.
     * @param typeParam The types of logs to retrieve.
     * @param options The options parameters.
     */
    _listLogs(resourceGroupName, serverName, databaseName, syncGroupName, startTime, endTime, typeParam, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            syncGroupName,
            startTime,
            endTime,
            typeParam,
            options
        }, listLogsOperationSpec);
    }
    /**
     * Cancels a sync group synchronization.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param options The options parameters.
     */
    cancelSync(resourceGroupName, serverName, databaseName, syncGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, syncGroupName, options }, cancelSyncOperationSpec);
    }
    /**
     * Triggers a sync group synchronization.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param options The options parameters.
     */
    triggerSync(resourceGroupName, serverName, databaseName, syncGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, syncGroupName, options }, triggerSyncOperationSpec);
    }
    /**
     * Gets a sync group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, syncGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, syncGroupName, options }, getOperationSpec$1j);
    }
    /**
     * Creates or updates a sync group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param parameters The requested sync group resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, databaseName, syncGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                syncGroupName,
                parameters,
                options
            }, createOrUpdateOperationSpec$S);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a sync group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param parameters The requested sync group resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, databaseName, syncGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, databaseName, syncGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a sync group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, databaseName, syncGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, databaseName, syncGroupName, options }, deleteOperationSpec$y);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a sync group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, databaseName, syncGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, databaseName, syncGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a sync group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param parameters The requested sync group resource state.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, serverName, databaseName, syncGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                syncGroupName,
                parameters,
                options
            }, updateOperationSpec$h);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a sync group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param parameters The requested sync group resource state.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, serverName, databaseName, syncGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, serverName, databaseName, syncGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists sync groups under a hub database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$n);
    }
    /**
     * ListSyncDatabaseIdsNext
     * @param locationName The name of the region where the resource is located.
     * @param nextLink The nextLink from the previous successful call to the ListSyncDatabaseIds method.
     * @param options The options parameters.
     */
    _listSyncDatabaseIdsNext(locationName, nextLink, options) {
        return this.client.sendOperationRequest({ locationName, nextLink, options }, listSyncDatabaseIdsNextOperationSpec);
    }
    /**
     * ListHubSchemasNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param nextLink The nextLink from the previous successful call to the ListHubSchemas method.
     * @param options The options parameters.
     */
    _listHubSchemasNext(resourceGroupName, serverName, databaseName, syncGroupName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            syncGroupName,
            nextLink,
            options
        }, listHubSchemasNextOperationSpec);
    }
    /**
     * ListLogsNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param startTime Get logs generated after this time.
     * @param endTime Get logs generated before this time.
     * @param nextLink The nextLink from the previous successful call to the ListLogs method.
     * @param typeParam The types of logs to retrieve.
     * @param options The options parameters.
     */
    _listLogsNext(resourceGroupName, serverName, databaseName, syncGroupName, startTime, endTime, nextLink, typeParam, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            syncGroupName,
            startTime,
            endTime,
            nextLink,
            typeParam,
            options
        }, listLogsNextOperationSpec);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$k);
    }
}
// Operation Specifications
const serializer$1w = coreClient.createSerializer(Mappers, /* isXml */ false);
const listSyncDatabaseIdsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/syncDatabaseIds",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncDatabaseIdListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const refreshHubSchemaOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}/refreshHubSchema",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName
    ],
    serializer: serializer$1w
};
const listHubSchemasOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}/hubSchemas",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncFullSchemaPropertiesListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const listLogsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}/logs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncGroupLogListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion2,
        startTime1,
        endTime1,
        typeParam,
        continuationToken
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const cancelSyncOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}/cancelSync",
    httpMethod: "POST",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName
    ],
    serializer: serializer$1w
};
const triggerSyncOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}/triggerSync",
    httpMethod: "POST",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName
    ],
    serializer: serializer$1w
};
const getOperationSpec$1j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncGroup
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const createOrUpdateOperationSpec$S = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SyncGroup
        },
        201: {
            bodyMapper: SyncGroup
        },
        202: {
            bodyMapper: SyncGroup
        },
        204: {
            bodyMapper: SyncGroup
        },
        default: {}
    },
    requestBody: parameters69,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1w
};
const deleteOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName
    ],
    serializer: serializer$1w
};
const updateOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SyncGroup
        },
        201: {
            bodyMapper: SyncGroup
        },
        202: {
            bodyMapper: SyncGroup
        },
        204: {
            bodyMapper: SyncGroup
        },
        default: {}
    },
    requestBody: parameters69,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1w
};
const listByDatabaseOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const listSyncDatabaseIdsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncDatabaseIdListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const listHubSchemasNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncFullSchemaPropertiesListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink,
        syncGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const listLogsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncGroupLogListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion2,
        startTime1,
        endTime1,
        typeParam,
        continuationToken
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink,
        syncGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const listByDatabaseNextOperationSpec$k = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SyncMembers operations. */
class SyncMembersImpl {
    /**
     * Initialize a new instance of the class SyncMembers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists sync members in the given sync group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param options The options parameters.
     */
    listBySyncGroup(resourceGroupName, serverName, databaseName, syncGroupName, options) {
        const iter = this.listBySyncGroupPagingAll(resourceGroupName, serverName, databaseName, syncGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySyncGroupPagingPage(resourceGroupName, serverName, databaseName, syncGroupName, options);
            }
        };
    }
    listBySyncGroupPagingPage(resourceGroupName, serverName, databaseName, syncGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySyncGroupPagingPage_1() {
            let result = yield tslib.__await(this._listBySyncGroup(resourceGroupName, serverName, databaseName, syncGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySyncGroupNext(resourceGroupName, serverName, databaseName, syncGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySyncGroupPagingAll(resourceGroupName, serverName, databaseName, syncGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySyncGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySyncGroupPagingPage(resourceGroupName, serverName, databaseName, syncGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a sync member database schema.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group on which the sync member is hosted.
     * @param syncMemberName The name of the sync member.
     * @param options The options parameters.
     */
    listMemberSchemas(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, options) {
        const iter = this.listMemberSchemasPagingAll(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listMemberSchemasPagingPage(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, options);
            }
        };
    }
    listMemberSchemasPagingPage(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMemberSchemasPagingPage_1() {
            let result = yield tslib.__await(this._listMemberSchemas(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listMemberSchemasNext(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listMemberSchemasPagingAll(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMemberSchemasPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listMemberSchemasPagingPage(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a sync member.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group on which the sync member is hosted.
     * @param syncMemberName The name of the sync member.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            syncGroupName,
            syncMemberName,
            options
        }, getOperationSpec$1k);
    }
    /**
     * Creates or updates a sync member.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group on which the sync member is hosted.
     * @param syncMemberName The name of the sync member.
     * @param parameters The requested sync member resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                syncGroupName,
                syncMemberName,
                parameters,
                options
            }, createOrUpdateOperationSpec$T);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a sync member.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group on which the sync member is hosted.
     * @param syncMemberName The name of the sync member.
     * @param parameters The requested sync member resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a sync member.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group on which the sync member is hosted.
     * @param syncMemberName The name of the sync member.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                syncGroupName,
                syncMemberName,
                options
            }, deleteOperationSpec$z);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a sync member.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group on which the sync member is hosted.
     * @param syncMemberName The name of the sync member.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing sync member.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group on which the sync member is hosted.
     * @param syncMemberName The name of the sync member.
     * @param parameters The requested sync member resource state.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                syncGroupName,
                syncMemberName,
                parameters,
                options
            }, updateOperationSpec$i);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates an existing sync member.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group on which the sync member is hosted.
     * @param syncMemberName The name of the sync member.
     * @param parameters The requested sync member resource state.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists sync members in the given sync group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param options The options parameters.
     */
    _listBySyncGroup(resourceGroupName, serverName, databaseName, syncGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, syncGroupName, options }, listBySyncGroupOperationSpec);
    }
    /**
     * Gets a sync member database schema.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group on which the sync member is hosted.
     * @param syncMemberName The name of the sync member.
     * @param options The options parameters.
     */
    _listMemberSchemas(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            syncGroupName,
            syncMemberName,
            options
        }, listMemberSchemasOperationSpec);
    }
    /**
     * Refreshes a sync member database schema.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group on which the sync member is hosted.
     * @param syncMemberName The name of the sync member.
     * @param options The options parameters.
     */
    beginRefreshMemberSchema(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                syncGroupName,
                syncMemberName,
                options
            }, refreshMemberSchemaOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Refreshes a sync member database schema.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group on which the sync member is hosted.
     * @param syncMemberName The name of the sync member.
     * @param options The options parameters.
     */
    beginRefreshMemberSchemaAndWait(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRefreshMemberSchema(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListBySyncGroupNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group.
     * @param nextLink The nextLink from the previous successful call to the ListBySyncGroup method.
     * @param options The options parameters.
     */
    _listBySyncGroupNext(resourceGroupName, serverName, databaseName, syncGroupName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            syncGroupName,
            nextLink,
            options
        }, listBySyncGroupNextOperationSpec);
    }
    /**
     * ListMemberSchemasNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database on which the sync group is hosted.
     * @param syncGroupName The name of the sync group on which the sync member is hosted.
     * @param syncMemberName The name of the sync member.
     * @param nextLink The nextLink from the previous successful call to the ListMemberSchemas method.
     * @param options The options parameters.
     */
    _listMemberSchemasNext(resourceGroupName, serverName, databaseName, syncGroupName, syncMemberName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            syncGroupName,
            syncMemberName,
            nextLink,
            options
        }, listMemberSchemasNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1x = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}/syncMembers/{syncMemberName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncMember
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName,
        syncMemberName
    ],
    headerParameters: [accept],
    serializer: serializer$1x
};
const createOrUpdateOperationSpec$T = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}/syncMembers/{syncMemberName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SyncMember
        },
        201: {
            bodyMapper: SyncMember
        },
        202: {
            bodyMapper: SyncMember
        },
        204: {
            bodyMapper: SyncMember
        },
        default: {}
    },
    requestBody: parameters70,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName,
        syncMemberName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1x
};
const deleteOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}/syncMembers/{syncMemberName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName,
        syncMemberName
    ],
    serializer: serializer$1x
};
const updateOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}/syncMembers/{syncMemberName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SyncMember
        },
        201: {
            bodyMapper: SyncMember
        },
        202: {
            bodyMapper: SyncMember
        },
        204: {
            bodyMapper: SyncMember
        },
        default: {}
    },
    requestBody: parameters70,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName,
        syncMemberName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1x
};
const listBySyncGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}/syncMembers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncMemberListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1x
};
const listMemberSchemasOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}/syncMembers/{syncMemberName}/schemas",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncFullSchemaPropertiesListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName,
        syncMemberName
    ],
    headerParameters: [accept],
    serializer: serializer$1x
};
const refreshMemberSchemaOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/syncGroups/{syncGroupName}/syncMembers/{syncMemberName}/refreshSchema",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        syncGroupName,
        syncMemberName
    ],
    serializer: serializer$1x
};
const listBySyncGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncMemberListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink,
        syncGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1x
};
const listMemberSchemasNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SyncFullSchemaPropertiesListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink,
        syncGroupName,
        syncMemberName
    ],
    headerParameters: [accept],
    serializer: serializer$1x
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing TdeCertificates operations. */
class TdeCertificatesImpl {
    /**
     * Initialize a new instance of the class TdeCertificates class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a TDE certificate for a given server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param parameters The requested TDE certificate to be created or updated.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, serverName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, parameters, options }, createOperationSpec$3);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates a TDE certificate for a given server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param parameters The requested TDE certificate to be created or updated.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, serverName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, serverName, parameters, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$1y = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/tdeCertificates",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    requestBody: parameters53,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$1y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing TimeZones operations. */
class TimeZonesImpl {
    /**
     * Initialize a new instance of the class TimeZones class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of managed instance time zones by location.
     * @param locationName
     * @param options The options parameters.
     */
    listByLocation(locationName, options) {
        const iter = this.listByLocationPagingAll(locationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByLocationPagingPage(locationName, options);
            }
        };
    }
    listByLocationPagingPage(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingPage_1() {
            let result = yield tslib.__await(this._listByLocation(locationName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByLocationNext(locationName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByLocationPagingAll(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLocationPagingPage(locationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of managed instance time zones by location.
     * @param locationName
     * @param options The options parameters.
     */
    _listByLocation(locationName, options) {
        return this.client.sendOperationRequest({ locationName, options }, listByLocationOperationSpec$6);
    }
    /**
     * Gets a managed instance time zone.
     * @param locationName
     * @param timeZoneId
     * @param options The options parameters.
     */
    get(locationName, timeZoneId, options) {
        return this.client.sendOperationRequest({ locationName, timeZoneId, options }, getOperationSpec$1l);
    }
    /**
     * ListByLocationNext
     * @param locationName
     * @param nextLink The nextLink from the previous successful call to the ListByLocation method.
     * @param options The options parameters.
     */
    _listByLocationNext(locationName, nextLink, options) {
        return this.client.sendOperationRequest({ locationName, nextLink, options }, listByLocationNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$1z = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByLocationOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/timeZones",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TimeZoneListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1z
};
const getOperationSpec$1l = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/timeZones/{timeZoneId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TimeZone
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        locationName,
        timeZoneId
    ],
    headerParameters: [accept],
    serializer: serializer$1z
};
const listByLocationNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TimeZoneListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualClusters operations. */
class VirtualClustersImpl {
    /**
     * Initialize a new instance of the class VirtualClusters class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all virtualClusters in the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of virtual clusters in a resource group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Synchronizes the DNS server settings used by the managed instances inside the given virtual cluster.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param virtualClusterName The name of the virtual cluster.
     * @param options The options parameters.
     */
    updateDnsServers(resourceGroupName, virtualClusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualClusterName, options }, updateDnsServersOperationSpec);
    }
    /**
     * Gets a list of all virtualClusters in the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$3);
    }
    /**
     * Gets a list of virtual clusters in a resource group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Gets a virtual cluster.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param virtualClusterName The name of the virtual cluster.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualClusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualClusterName, options }, getOperationSpec$1m);
    }
    /**
     * Deletes a virtual cluster.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param virtualClusterName The name of the virtual cluster.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualClusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualClusterName, options }, deleteOperationSpec$A);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a virtual cluster.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param virtualClusterName The name of the virtual cluster.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualClusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualClusterName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a virtual cluster.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param virtualClusterName The name of the virtual cluster.
     * @param parameters The requested virtual cluster resource state.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, virtualClusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualClusterName, parameters, options }, updateOperationSpec$j);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a virtual cluster.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param virtualClusterName The name of the virtual cluster.
     * @param parameters The requested virtual cluster resource state.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, virtualClusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, virtualClusterName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$3);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1A = coreClient.createSerializer(Mappers, /* isXml */ false);
const updateDnsServersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/virtualClusters/{virtualClusterName}/updateManagedInstanceDnsServers",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: UpdateManagedInstanceDnsServersOperation
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualClusterName
    ],
    headerParameters: [accept],
    serializer: serializer$1A
};
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/virtualClusters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualClusterListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1A
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/virtualClusters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualClusterListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1A
};
const getOperationSpec$1m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/virtualClusters/{virtualClusterName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualCluster
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualClusterName
    ],
    headerParameters: [accept],
    serializer: serializer$1A
};
const deleteOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/virtualClusters/{virtualClusterName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualClusterName
    ],
    serializer: serializer$1A
};
const updateOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/virtualClusters/{virtualClusterName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualCluster
        },
        201: {
            bodyMapper: VirtualCluster
        },
        202: {
            bodyMapper: VirtualCluster
        },
        204: {
            bodyMapper: VirtualCluster
        },
        default: {}
    },
    requestBody: parameters71,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualClusterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1A
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualClusterListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1A
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualClusterListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1A
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworkRules operations. */
class VirtualNetworkRulesImpl {
    /**
     * Initialize a new instance of the class VirtualNetworkRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of virtual network rules in a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a virtual network rule.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param virtualNetworkRuleName The name of the virtual network rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, virtualNetworkRuleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, virtualNetworkRuleName, options }, getOperationSpec$1n);
    }
    /**
     * Creates or updates an existing virtual network rule.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param virtualNetworkRuleName The name of the virtual network rule.
     * @param parameters The requested virtual Network Rule Resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, virtualNetworkRuleName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                virtualNetworkRuleName,
                parameters,
                options
            }, createOrUpdateOperationSpec$U);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates an existing virtual network rule.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param virtualNetworkRuleName The name of the virtual network rule.
     * @param parameters The requested virtual Network Rule Resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, virtualNetworkRuleName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, virtualNetworkRuleName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the virtual network rule with the given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param virtualNetworkRuleName The name of the virtual network rule.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, virtualNetworkRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, virtualNetworkRuleName, options }, deleteOperationSpec$B);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes the virtual network rule with the given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param virtualNetworkRuleName The name of the virtual network rule.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, virtualNetworkRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, virtualNetworkRuleName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of virtual network rules in a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$p);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$k);
    }
}
// Operation Specifications
const serializer$1B = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/virtualNetworkRules/{virtualNetworkRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkRule
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        virtualNetworkRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$1B
};
const createOrUpdateOperationSpec$U = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/virtualNetworkRules/{virtualNetworkRuleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetworkRule
        },
        201: {
            bodyMapper: VirtualNetworkRule
        },
        202: {
            bodyMapper: VirtualNetworkRule
        },
        204: {
            bodyMapper: VirtualNetworkRule
        },
        default: {}
    },
    requestBody: parameters72,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        virtualNetworkRuleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1B
};
const deleteOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/virtualNetworkRules/{virtualNetworkRuleName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        virtualNetworkRuleName
    ],
    serializer: serializer$1B
};
const listByServerOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/virtualNetworkRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkRuleListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1B
};
const listByServerNextOperationSpec$k = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkRuleListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1B
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkloadClassifiers operations. */
class WorkloadClassifiersImpl {
    /**
     * Initialize a new instance of the class WorkloadClassifiers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the list of workload classifiers for a workload group
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param workloadGroupName The name of the workload group from which to receive the classifiers from.
     * @param options The options parameters.
     */
    listByWorkloadGroup(resourceGroupName, serverName, databaseName, workloadGroupName, options) {
        const iter = this.listByWorkloadGroupPagingAll(resourceGroupName, serverName, databaseName, workloadGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByWorkloadGroupPagingPage(resourceGroupName, serverName, databaseName, workloadGroupName, options);
            }
        };
    }
    listByWorkloadGroupPagingPage(resourceGroupName, serverName, databaseName, workloadGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkloadGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByWorkloadGroup(resourceGroupName, serverName, databaseName, workloadGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByWorkloadGroupNext(resourceGroupName, serverName, databaseName, workloadGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByWorkloadGroupPagingAll(resourceGroupName, serverName, databaseName, workloadGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkloadGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByWorkloadGroupPagingPage(resourceGroupName, serverName, databaseName, workloadGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a workload classifier
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param workloadGroupName The name of the workload group from which to receive the classifier from.
     * @param workloadClassifierName The name of the workload classifier.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, workloadGroupName, workloadClassifierName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            workloadGroupName,
            workloadClassifierName,
            options
        }, getOperationSpec$1o);
    }
    /**
     * Creates or updates a workload classifier.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param workloadGroupName The name of the workload group from which to receive the classifier from.
     * @param workloadClassifierName The name of the workload classifier to create/update.
     * @param parameters The properties of the workload classifier.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, databaseName, workloadGroupName, workloadClassifierName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                workloadGroupName,
                workloadClassifierName,
                parameters,
                options
            }, createOrUpdateOperationSpec$V);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a workload classifier.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param workloadGroupName The name of the workload group from which to receive the classifier from.
     * @param workloadClassifierName The name of the workload classifier to create/update.
     * @param parameters The properties of the workload classifier.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, databaseName, workloadGroupName, workloadClassifierName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, databaseName, workloadGroupName, workloadClassifierName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a workload classifier.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param workloadGroupName The name of the workload group from which to receive the classifier from.
     * @param workloadClassifierName The name of the workload classifier to delete.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, databaseName, workloadGroupName, workloadClassifierName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                workloadGroupName,
                workloadClassifierName,
                options
            }, deleteOperationSpec$C);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a workload classifier.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param workloadGroupName The name of the workload group from which to receive the classifier from.
     * @param workloadClassifierName The name of the workload classifier to delete.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, databaseName, workloadGroupName, workloadClassifierName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, databaseName, workloadGroupName, workloadClassifierName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the list of workload classifiers for a workload group
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param workloadGroupName The name of the workload group from which to receive the classifiers from.
     * @param options The options parameters.
     */
    _listByWorkloadGroup(resourceGroupName, serverName, databaseName, workloadGroupName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            workloadGroupName,
            options
        }, listByWorkloadGroupOperationSpec);
    }
    /**
     * ListByWorkloadGroupNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param workloadGroupName The name of the workload group from which to receive the classifiers from.
     * @param nextLink The nextLink from the previous successful call to the ListByWorkloadGroup method.
     * @param options The options parameters.
     */
    _listByWorkloadGroupNext(resourceGroupName, serverName, databaseName, workloadGroupName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            workloadGroupName,
            nextLink,
            options
        }, listByWorkloadGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1C = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/workloadGroups/{workloadGroupName}/workloadClassifiers/{workloadClassifierName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadClassifier
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        workloadGroupName,
        workloadClassifierName
    ],
    headerParameters: [accept],
    serializer: serializer$1C
};
const createOrUpdateOperationSpec$V = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/workloadGroups/{workloadGroupName}/workloadClassifiers/{workloadClassifierName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkloadClassifier
        },
        201: {
            bodyMapper: WorkloadClassifier
        },
        202: {
            bodyMapper: WorkloadClassifier
        },
        204: {
            bodyMapper: WorkloadClassifier
        },
        default: {}
    },
    requestBody: parameters73,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        workloadGroupName,
        workloadClassifierName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1C
};
const deleteOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/workloadGroups/{workloadGroupName}/workloadClassifiers/{workloadClassifierName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        workloadGroupName,
        workloadClassifierName
    ],
    serializer: serializer$1C
};
const listByWorkloadGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/workloadGroups/{workloadGroupName}/workloadClassifiers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadClassifierListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        workloadGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1C
};
const listByWorkloadGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadClassifierListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink,
        workloadGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1C
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkloadGroups operations. */
class WorkloadGroupsImpl {
    /**
     * Initialize a new instance of the class WorkloadGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the list of workload groups
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a workload group
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param workloadGroupName The name of the workload group.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, workloadGroupName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            workloadGroupName,
            options
        }, getOperationSpec$1p);
    }
    /**
     * Creates or updates a workload group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param workloadGroupName The name of the workload group.
     * @param parameters The requested workload group state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, databaseName, workloadGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                workloadGroupName,
                parameters,
                options
            }, createOrUpdateOperationSpec$W);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a workload group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param workloadGroupName The name of the workload group.
     * @param parameters The requested workload group state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, databaseName, workloadGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, databaseName, workloadGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a workload group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param workloadGroupName The name of the workload group to delete.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, databaseName, workloadGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                workloadGroupName,
                options
            }, deleteOperationSpec$D);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a workload group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param workloadGroupName The name of the workload group to delete.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, databaseName, workloadGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, databaseName, workloadGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the list of workload groups
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$o);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$l);
    }
}
// Operation Specifications
const serializer$1D = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/workloadGroups/{workloadGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadGroup
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        workloadGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1D
};
const createOrUpdateOperationSpec$W = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/workloadGroups/{workloadGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkloadGroup
        },
        201: {
            bodyMapper: WorkloadGroup
        },
        202: {
            bodyMapper: WorkloadGroup
        },
        204: {
            bodyMapper: WorkloadGroup
        },
        default: {}
    },
    requestBody: parameters74,
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        workloadGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1D
};
const deleteOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/workloadGroups/{workloadGroupName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        workloadGroupName
    ],
    serializer: serializer$1D
};
const listByDatabaseOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/workloadGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1D
};
const listByDatabaseNextOperationSpec$l = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadGroupListResult
        },
        default: {}
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1D
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing TransparentDataEncryptions operations. */
class TransparentDataEncryptionsImpl {
    /**
     * Initialize a new instance of the class TransparentDataEncryptions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of the logical database's transparent data encryption.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the logical database for which the transparent data encryption is
     *                     defined.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a logical database's transparent data encryption.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the logical database for which the transparent data encryption is
     *                     defined.
     * @param tdeName The name of the transparent data encryption configuration.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, tdeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, tdeName, options }, getOperationSpec$1q);
    }
    /**
     * Updates a logical database's transparent data encryption configuration.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the logical database for which the security alert policy is defined.
     * @param tdeName The name of the transparent data encryption configuration.
     * @param parameters The database transparent data encryption.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, serverName, databaseName, tdeName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            tdeName,
            parameters,
            options
        }, createOrUpdateOperationSpec$X);
    }
    /**
     * Gets a list of the logical database's transparent data encryption.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the logical database for which the transparent data encryption is
     *                     defined.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$p);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the logical database for which the transparent data encryption is
     *                     defined.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$m);
    }
}
// Operation Specifications
const serializer$1E = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/transparentDataEncryption/{tdeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LogicalDatabaseTransparentDataEncryption
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        tdeName
    ],
    headerParameters: [accept],
    serializer: serializer$1E
};
const createOrUpdateOperationSpec$X = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/transparentDataEncryption/{tdeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: LogicalDatabaseTransparentDataEncryption
        },
        201: {
            bodyMapper: LogicalDatabaseTransparentDataEncryption
        },
        202: {},
        default: {}
    },
    requestBody: parameters75,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        tdeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1E
};
const listByDatabaseOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/transparentDataEncryption",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LogicalDatabaseTransparentDataEncryptionListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1E
};
const listByDatabaseNextOperationSpec$m = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LogicalDatabaseTransparentDataEncryptionListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1E
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BackupShortTermRetentionPolicies operations. */
class BackupShortTermRetentionPoliciesImpl {
    /**
     * Initialize a new instance of the class BackupShortTermRetentionPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param policyName The policy name. Should always be "default".
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, policyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, policyName, options }, getOperationSpec$1r);
    }
    /**
     * Updates a database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param policyName The policy name. Should always be "default".
     * @param parameters The short term retention policy info.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, databaseName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                policyName,
                parameters,
                options
            }, createOrUpdateOperationSpec$Y);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param policyName The policy name. Should always be "default".
     * @param parameters The short term retention policy info.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, databaseName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, databaseName, policyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param policyName The policy name. Should always be "default".
     * @param parameters The short term retention policy info.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, serverName, databaseName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                policyName,
                parameters,
                options
            }, updateOperationSpec$k);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param policyName The policy name. Should always be "default".
     * @param parameters The short term retention policy info.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, serverName, databaseName, policyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, serverName, databaseName, policyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a database's short term retention policy.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$q);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$n);
    }
}
// Operation Specifications
const serializer$1F = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/backupShortTermRetentionPolicies/{policyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupShortTermRetentionPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        policyName3
    ],
    headerParameters: [accept],
    serializer: serializer$1F
};
const createOrUpdateOperationSpec$Y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/backupShortTermRetentionPolicies/{policyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BackupShortTermRetentionPolicy
        },
        201: {
            bodyMapper: BackupShortTermRetentionPolicy
        },
        202: {
            bodyMapper: BackupShortTermRetentionPolicy
        },
        204: {
            bodyMapper: BackupShortTermRetentionPolicy
        },
        default: {}
    },
    requestBody: parameters76,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        policyName3
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1F
};
const updateOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/backupShortTermRetentionPolicies/{policyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: BackupShortTermRetentionPolicy
        },
        201: {
            bodyMapper: BackupShortTermRetentionPolicy
        },
        202: {
            bodyMapper: BackupShortTermRetentionPolicy
        },
        204: {
            bodyMapper: BackupShortTermRetentionPolicy
        },
        default: {}
    },
    requestBody: parameters76,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        policyName3
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1F
};
const listByDatabaseOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/backupShortTermRetentionPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupShortTermRetentionPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1F
};
const listByDatabaseNextOperationSpec$n = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupShortTermRetentionPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1F
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DatabaseExtensionsOperations operations. */
class DatabaseExtensionsOperationsImpl {
    /**
     * Initialize a new instance of the class DatabaseExtensionsOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List database extension. This will return an empty list as it is not supported.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a database extension. This will return resource not found as it is not supported.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param extensionName
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, extensionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, extensionName, options }, getOperationSpec$1s);
    }
    /**
     * Perform a database extension operation, like polybase import
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param extensionName
     * @param parameters The database import request parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, databaseName, extensionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                extensionName,
                parameters,
                options
            }, createOrUpdateOperationSpec$Z);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Perform a database extension operation, like polybase import
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param extensionName
     * @param parameters The database import request parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, databaseName, extensionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, databaseName, extensionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List database extension. This will return an empty list as it is not supported.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$r);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$o);
    }
}
// Operation Specifications
const serializer$1G = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/extensions/{extensionName}",
    httpMethod: "GET",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        extensionName
    ],
    serializer: serializer$1G
};
const createOrUpdateOperationSpec$Z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/extensions/{extensionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ImportExportExtensionsOperationResult
        },
        201: {
            bodyMapper: ImportExportExtensionsOperationResult
        },
        202: {
            bodyMapper: ImportExportExtensionsOperationResult
        },
        204: {
            bodyMapper: ImportExportExtensionsOperationResult
        },
        default: {}
    },
    requestBody: parameters77,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        extensionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1G
};
const listByDatabaseOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/extensions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ImportExportExtensionsOperationListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1G
};
const listByDatabaseNextOperationSpec$o = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ImportExportExtensionsOperationListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1G
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DatabaseOperations operations. */
class DatabaseOperationsImpl {
    /**
     * Initialize a new instance of the class DatabaseOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of operations performed on the database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Cancels the asynchronous operation on the database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param operationId The operation identifier.
     * @param options The options parameters.
     */
    cancel(resourceGroupName, serverName, databaseName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, operationId, options }, cancelOperationSpec$3);
    }
    /**
     * Gets a list of operations performed on the database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$s);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$p);
    }
}
// Operation Specifications
const serializer$1H = coreClient.createSerializer(Mappers, /* isXml */ false);
const cancelOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/operations/{operationId}/cancel",
    httpMethod: "POST",
    responses: { 200: {}, default: {} },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        operationId
    ],
    serializer: serializer$1H
};
const listByDatabaseOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseOperationListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1H
};
const listByDatabaseNextOperationSpec$p = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseOperationListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1H
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DatabaseUsages operations. */
class DatabaseUsagesImpl {
    /**
     * Initialize a new instance of the class DatabaseUsages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets database usages.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets database usages.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$t);
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$q);
    }
}
// Operation Specifications
const serializer$1I = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByDatabaseOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseUsageListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1I
};
const listByDatabaseNextOperationSpec$q = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseUsageListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1I
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LedgerDigestUploadsOperations operations. */
class LedgerDigestUploadsOperationsImpl {
    /**
     * Initialize a new instance of the class LedgerDigestUploadsOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all ledger digest upload settings on a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    listByDatabase(resourceGroupName, serverName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(resourceGroupName, serverName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(resourceGroupName, serverName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(resourceGroupName, serverName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(resourceGroupName, serverName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the current ledger digest upload configuration for a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param ledgerDigestUploads
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, databaseName, ledgerDigestUploads, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serverName,
            databaseName,
            ledgerDigestUploads,
            options
        }, getOperationSpec$1t);
    }
    /**
     * Enables upload ledger digests to an Azure Storage account or an Azure Confidential Ledger instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param ledgerDigestUploads
     * @param parameters Azure SQL Database ledger digest upload settings.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, databaseName, ledgerDigestUploads, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                ledgerDigestUploads,
                parameters,
                options
            }, createOrUpdateOperationSpec$_);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Enables upload ledger digests to an Azure Storage account or an Azure Confidential Ledger instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param ledgerDigestUploads
     * @param parameters Azure SQL Database ledger digest upload settings.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, databaseName, ledgerDigestUploads, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, databaseName, ledgerDigestUploads, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all ledger digest upload settings on a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param options The options parameters.
     */
    _listByDatabase(resourceGroupName, serverName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, options }, listByDatabaseOperationSpec$u);
    }
    /**
     * Disables uploading ledger digests to an Azure Storage account or an Azure Confidential Ledger
     * instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param ledgerDigestUploads
     * @param options The options parameters.
     */
    beginDisable(resourceGroupName, serverName, databaseName, ledgerDigestUploads, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                databaseName,
                ledgerDigestUploads,
                options
            }, disableOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Disables uploading ledger digests to an Azure Storage account or an Azure Confidential Ledger
     * instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param ledgerDigestUploads
     * @param options The options parameters.
     */
    beginDisableAndWait(resourceGroupName, serverName, databaseName, ledgerDigestUploads, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDisable(resourceGroupName, serverName, databaseName, ledgerDigestUploads, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param databaseName The name of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(resourceGroupName, serverName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$r);
    }
}
// Operation Specifications
const serializer$1J = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/ledgerDigestUploads/{ledgerDigestUploads}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LedgerDigestUploads
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        ledgerDigestUploads
    ],
    headerParameters: [accept],
    serializer: serializer$1J
};
const createOrUpdateOperationSpec$_ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/ledgerDigestUploads/{ledgerDigestUploads}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: LedgerDigestUploads
        },
        201: {
            bodyMapper: LedgerDigestUploads
        },
        202: {
            bodyMapper: LedgerDigestUploads
        },
        204: {
            bodyMapper: LedgerDigestUploads
        },
        default: {}
    },
    requestBody: parameters78,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        ledgerDigestUploads
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1J
};
const listByDatabaseOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/ledgerDigestUploads",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LedgerDigestUploadsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1J
};
const disableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/ledgerDigestUploads/{ledgerDigestUploads}/disable",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LedgerDigestUploads
        },
        201: {
            bodyMapper: LedgerDigestUploads
        },
        202: {
            bodyMapper: LedgerDigestUploads
        },
        204: {
            bodyMapper: LedgerDigestUploads
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        ledgerDigestUploads
    ],
    headerParameters: [accept],
    serializer: serializer$1J
};
const listByDatabaseNextOperationSpec$r = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LedgerDigestUploadsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        databaseName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1J
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing OutboundFirewallRules operations. */
class OutboundFirewallRulesImpl {
    /**
     * Initialize a new instance of the class OutboundFirewallRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all outbound firewall rules on a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets an outbound firewall rule.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param outboundRuleFqdn
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, outboundRuleFqdn, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, outboundRuleFqdn, options }, getOperationSpec$1u);
    }
    /**
     * Create a outbound firewall rule with a given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param outboundRuleFqdn
     * @param parameters An Azure SQL DB Server Outbound Firewall Rule.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, outboundRuleFqdn, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, outboundRuleFqdn, parameters, options }, createOrUpdateOperationSpec$$);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Create a outbound firewall rule with a given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param outboundRuleFqdn
     * @param parameters An Azure SQL DB Server Outbound Firewall Rule.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, outboundRuleFqdn, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, outboundRuleFqdn, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a outbound firewall rule with a given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param outboundRuleFqdn
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, outboundRuleFqdn, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, outboundRuleFqdn, options }, deleteOperationSpec$E);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a outbound firewall rule with a given name.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param outboundRuleFqdn
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, outboundRuleFqdn, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, outboundRuleFqdn, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all outbound firewall rules on a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$q);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$l);
    }
}
// Operation Specifications
const serializer$1K = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/outboundFirewallRules/{outboundRuleFqdn}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutboundFirewallRule
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        outboundRuleFqdn
    ],
    headerParameters: [accept],
    serializer: serializer$1K
};
const createOrUpdateOperationSpec$$ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/outboundFirewallRules/{outboundRuleFqdn}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: OutboundFirewallRule
        },
        201: {
            bodyMapper: OutboundFirewallRule
        },
        202: {
            bodyMapper: OutboundFirewallRule
        },
        204: {
            bodyMapper: OutboundFirewallRule
        },
        default: {}
    },
    requestBody: parameters79,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        outboundRuleFqdn
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1K
};
const deleteOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/outboundFirewallRules/{outboundRuleFqdn}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        outboundRuleFqdn
    ],
    serializer: serializer$1K
};
const listByServerOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/outboundFirewallRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutboundFirewallRuleListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1K
};
const listByServerNextOperationSpec$l = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutboundFirewallRuleListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1K
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Servers operations. */
class ServersImpl {
    /**
     * Initialize a new instance of the class Servers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of servers in a resource groups.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of all servers in the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of servers in a resource groups.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$2);
    }
    /**
     * Gets a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, getOperationSpec$1v);
    }
    /**
     * Creates or updates a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param parameters The requested server resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, parameters, options }, createOrUpdateOperationSpec$10);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param parameters The requested server resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serverName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, options }, deleteOperationSpec$F);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serverName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serverName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param parameters The requested server resource state.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, serverName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, parameters, options }, updateOperationSpec$l);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param parameters The requested server resource state.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, serverName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, serverName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of all servers in the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$4);
    }
    /**
     * Imports a bacpac into a new database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param parameters The database import request parameters.
     * @param options The options parameters.
     */
    beginImportDatabase(resourceGroupName, serverName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, serverName, parameters, options }, importDatabaseOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Imports a bacpac into a new database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param parameters The database import request parameters.
     * @param options The options parameters.
     */
    beginImportDatabaseAndWait(resourceGroupName, serverName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginImportDatabase(resourceGroupName, serverName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Determines whether a resource can be created with the specified name.
     * @param parameters The name availability request parameters.
     * @param options The options parameters.
     */
    checkNameAvailability(parameters, options) {
        return this.client.sendOperationRequest({ parameters, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$2);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$1L = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByResourceGroupOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1L
};
const getOperationSpec$1v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Server
        },
        default: {}
    },
    queryParameters: [apiVersion3, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1L
};
const createOrUpdateOperationSpec$10 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Server
        },
        201: {
            bodyMapper: Server
        },
        202: {
            bodyMapper: Server
        },
        204: {
            bodyMapper: Server
        },
        default: {}
    },
    requestBody: parameters80,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1L
};
const deleteOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    serializer: serializer$1L
};
const updateOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Server
        },
        201: {
            bodyMapper: Server
        },
        202: {
            bodyMapper: Server
        },
        204: {
            bodyMapper: Server
        },
        default: {}
    },
    requestBody: parameters81,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1L
};
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/servers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3, expand],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1L
};
const importDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/import",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ImportExportOperationResult
        },
        201: {
            bodyMapper: ImportExportOperationResult
        },
        202: {
            bodyMapper: ImportExportOperationResult
        },
        204: {
            bodyMapper: ImportExportOperationResult
        },
        default: {}
    },
    requestBody: parameters82,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1L
};
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityResponse
        },
        default: {}
    },
    requestBody: parameters83,
    queryParameters: [apiVersion3],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1L
};
const listByResourceGroupNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1L
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3, expand],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1L
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Usages operations. */
class UsagesImpl {
    /**
     * Initialize a new instance of the class Usages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all instance pool usage metrics
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param instancePoolName The name of the instance pool to be retrieved.
     * @param options The options parameters.
     */
    listByInstancePool(resourceGroupName, instancePoolName, options) {
        const iter = this.listByInstancePoolPagingAll(resourceGroupName, instancePoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByInstancePoolPagingPage(resourceGroupName, instancePoolName, options);
            }
        };
    }
    listByInstancePoolPagingPage(resourceGroupName, instancePoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePoolPagingPage_1() {
            let result = yield tslib.__await(this._listByInstancePool(resourceGroupName, instancePoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByInstancePoolNext(resourceGroupName, instancePoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByInstancePoolPagingAll(resourceGroupName, instancePoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePoolPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByInstancePoolPagingPage(resourceGroupName, instancePoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all instance pool usage metrics
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param instancePoolName The name of the instance pool to be retrieved.
     * @param options The options parameters.
     */
    _listByInstancePool(resourceGroupName, instancePoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, instancePoolName, options }, listByInstancePoolOperationSpec);
    }
    /**
     * ListByInstancePoolNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param instancePoolName The name of the instance pool to be retrieved.
     * @param nextLink The nextLink from the previous successful call to the ListByInstancePool method.
     * @param options The options parameters.
     */
    _listByInstancePoolNext(resourceGroupName, instancePoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, instancePoolName, nextLink, options }, listByInstancePoolNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1M = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByInstancePoolOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/instancePools/{instancePoolName}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3, expandChildren],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        instancePoolName
    ],
    headerParameters: [accept],
    serializer: serializer$1M
};
const listByInstancePoolNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageListResult
        },
        default: {}
    },
    queryParameters: [apiVersion3, expandChildren],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        instancePoolName
    ],
    headerParameters: [accept],
    serializer: serializer$1M
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LongTermRetentionBackups operations. */
class LongTermRetentionBackupsImpl {
    /**
     * Initialize a new instance of the class LongTermRetentionBackups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all long term retention backups for a database.
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param options The options parameters.
     */
    listByDatabase(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options) {
        const iter = this.listByDatabasePagingAll(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options);
            }
        };
    }
    listByDatabasePagingPage(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the long term retention backups for a given location.
     * @param locationName The location of the database
     * @param options The options parameters.
     */
    listByLocation(locationName, options) {
        const iter = this.listByLocationPagingAll(locationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByLocationPagingPage(locationName, options);
            }
        };
    }
    listByLocationPagingPage(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingPage_1() {
            let result = yield tslib.__await(this._listByLocation(locationName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByLocationNext(locationName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByLocationPagingAll(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLocationPagingPage(locationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists the long term retention backups for a given server.
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param options The options parameters.
     */
    listByServer(locationName, longTermRetentionServerName, options) {
        const iter = this.listByServerPagingAll(locationName, longTermRetentionServerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(locationName, longTermRetentionServerName, options);
            }
        };
    }
    listByServerPagingPage(locationName, longTermRetentionServerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(locationName, longTermRetentionServerName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(locationName, longTermRetentionServerName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(locationName, longTermRetentionServerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(locationName, longTermRetentionServerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Lists all long term retention backups for a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param options The options parameters.
     */
    listByResourceGroupDatabase(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options) {
        const iter = this.listByResourceGroupDatabasePagingAll(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupDatabasePagingPage(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options);
            }
        };
    }
    listByResourceGroupDatabasePagingPage(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroupDatabase(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupDatabaseNext(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupDatabasePagingAll(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupDatabasePagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupDatabasePagingPage(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Lists the long term retention backups for a given location.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param options The options parameters.
     */
    listByResourceGroupLocation(resourceGroupName, locationName, options) {
        const iter = this.listByResourceGroupLocationPagingAll(resourceGroupName, locationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupLocationPagingPage(resourceGroupName, locationName, options);
            }
        };
    }
    listByResourceGroupLocationPagingPage(resourceGroupName, locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupLocationPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroupLocation(resourceGroupName, locationName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupLocationNext(resourceGroupName, locationName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupLocationPagingAll(resourceGroupName, locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupLocationPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupLocationPagingPage(resourceGroupName, locationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Lists the long term retention backups for a given server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param options The options parameters.
     */
    listByResourceGroupServer(resourceGroupName, locationName, longTermRetentionServerName, options) {
        const iter = this.listByResourceGroupServerPagingAll(resourceGroupName, locationName, longTermRetentionServerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupServerPagingPage(resourceGroupName, locationName, longTermRetentionServerName, options);
            }
        };
    }
    listByResourceGroupServerPagingPage(resourceGroupName, locationName, longTermRetentionServerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupServerPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroupServer(resourceGroupName, locationName, longTermRetentionServerName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupServerNext(resourceGroupName, locationName, longTermRetentionServerName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupServerPagingAll(resourceGroupName, locationName, longTermRetentionServerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupServerPagingAll_1() {
            var e_6, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupServerPagingPage(resourceGroupName, locationName, longTermRetentionServerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Copy an existing long term retention backup.
     * @param locationName The location of the database.
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param backupName The backup name.
     * @param parameters The parameters needed for long term retention copy request
     * @param options The options parameters.
     */
    beginCopy(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                locationName,
                longTermRetentionServerName,
                longTermRetentionDatabaseName,
                backupName,
                parameters,
                options
            }, copyOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Copy an existing long term retention backup.
     * @param locationName The location of the database.
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param backupName The backup name.
     * @param parameters The parameters needed for long term retention copy request
     * @param options The options parameters.
     */
    beginCopyAndWait(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCopy(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing long term retention backup.
     * @param locationName The location of the database.
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param backupName The backup name.
     * @param parameters The requested backup resource state
     * @param options The options parameters.
     */
    beginUpdate(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                locationName,
                longTermRetentionServerName,
                longTermRetentionDatabaseName,
                backupName,
                parameters,
                options
            }, updateOperationSpec$m);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates an existing long term retention backup.
     * @param locationName The location of the database.
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param backupName The backup name.
     * @param parameters The requested backup resource state
     * @param options The options parameters.
     */
    beginUpdateAndWait(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a long term retention backup.
     * @param locationName The location of the database.
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param backupName The backup name.
     * @param options The options parameters.
     */
    get(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, options) {
        return this.client.sendOperationRequest({
            locationName,
            longTermRetentionServerName,
            longTermRetentionDatabaseName,
            backupName,
            options
        }, getOperationSpec$1w);
    }
    /**
     * Deletes a long term retention backup.
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param backupName The backup name.
     * @param options The options parameters.
     */
    beginDelete(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                locationName,
                longTermRetentionServerName,
                longTermRetentionDatabaseName,
                backupName,
                options
            }, deleteOperationSpec$G);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a long term retention backup.
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param backupName The backup name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all long term retention backups for a database.
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param options The options parameters.
     */
    _listByDatabase(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options) {
        return this.client.sendOperationRequest({
            locationName,
            longTermRetentionServerName,
            longTermRetentionDatabaseName,
            options
        }, listByDatabaseOperationSpec$v);
    }
    /**
     * Lists the long term retention backups for a given location.
     * @param locationName The location of the database
     * @param options The options parameters.
     */
    _listByLocation(locationName, options) {
        return this.client.sendOperationRequest({ locationName, options }, listByLocationOperationSpec$7);
    }
    /**
     * Lists the long term retention backups for a given server.
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param options The options parameters.
     */
    _listByServer(locationName, longTermRetentionServerName, options) {
        return this.client.sendOperationRequest({ locationName, longTermRetentionServerName, options }, listByServerOperationSpec$r);
    }
    /**
     * Copy an existing long term retention backup to a different server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database.
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param backupName The backup name.
     * @param parameters The parameters needed for long term retention copy request
     * @param options The options parameters.
     */
    beginCopyByResourceGroup(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                locationName,
                longTermRetentionServerName,
                longTermRetentionDatabaseName,
                backupName,
                parameters,
                options
            }, copyByResourceGroupOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Copy an existing long term retention backup to a different server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database.
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param backupName The backup name.
     * @param parameters The parameters needed for long term retention copy request
     * @param options The options parameters.
     */
    beginCopyByResourceGroupAndWait(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCopyByResourceGroup(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing long term retention backup.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database.
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param backupName The backup name.
     * @param parameters The requested backup resource state
     * @param options The options parameters.
     */
    beginUpdateByResourceGroup(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                locationName,
                longTermRetentionServerName,
                longTermRetentionDatabaseName,
                backupName,
                parameters,
                options
            }, updateByResourceGroupOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates an existing long term retention backup.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database.
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param backupName The backup name.
     * @param parameters The requested backup resource state
     * @param options The options parameters.
     */
    beginUpdateByResourceGroupAndWait(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateByResourceGroup(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a long term retention backup.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database.
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param backupName The backup name.
     * @param options The options parameters.
     */
    getByResourceGroup(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            locationName,
            longTermRetentionServerName,
            longTermRetentionDatabaseName,
            backupName,
            options
        }, getByResourceGroupOperationSpec);
    }
    /**
     * Deletes a long term retention backup.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param backupName The backup name.
     * @param options The options parameters.
     */
    beginDeleteByResourceGroup(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                locationName,
                longTermRetentionServerName,
                longTermRetentionDatabaseName,
                backupName,
                options
            }, deleteByResourceGroupOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a long term retention backup.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param backupName The backup name.
     * @param options The options parameters.
     */
    beginDeleteByResourceGroupAndWait(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteByResourceGroup(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, backupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all long term retention backups for a database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param options The options parameters.
     */
    _listByResourceGroupDatabase(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            locationName,
            longTermRetentionServerName,
            longTermRetentionDatabaseName,
            options
        }, listByResourceGroupDatabaseOperationSpec);
    }
    /**
     * Lists the long term retention backups for a given location.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param options The options parameters.
     */
    _listByResourceGroupLocation(resourceGroupName, locationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, locationName, options }, listByResourceGroupLocationOperationSpec);
    }
    /**
     * Lists the long term retention backups for a given server.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param options The options parameters.
     */
    _listByResourceGroupServer(resourceGroupName, locationName, longTermRetentionServerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, locationName, longTermRetentionServerName, options }, listByResourceGroupServerOperationSpec);
    }
    /**
     * ListByDatabaseNext
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(locationName, longTermRetentionServerName, longTermRetentionDatabaseName, nextLink, options) {
        return this.client.sendOperationRequest({
            locationName,
            longTermRetentionServerName,
            longTermRetentionDatabaseName,
            nextLink,
            options
        }, listByDatabaseNextOperationSpec$s);
    }
    /**
     * ListByLocationNext
     * @param locationName The location of the database
     * @param nextLink The nextLink from the previous successful call to the ListByLocation method.
     * @param options The options parameters.
     */
    _listByLocationNext(locationName, nextLink, options) {
        return this.client.sendOperationRequest({ locationName, nextLink, options }, listByLocationNextOperationSpec$6);
    }
    /**
     * ListByServerNext
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(locationName, longTermRetentionServerName, nextLink, options) {
        return this.client.sendOperationRequest({ locationName, longTermRetentionServerName, nextLink, options }, listByServerNextOperationSpec$m);
    }
    /**
     * ListByResourceGroupDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param longTermRetentionDatabaseName The name of the database
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroupDatabase
     *                 method.
     * @param options The options parameters.
     */
    _listByResourceGroupDatabaseNext(resourceGroupName, locationName, longTermRetentionServerName, longTermRetentionDatabaseName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            locationName,
            longTermRetentionServerName,
            longTermRetentionDatabaseName,
            nextLink,
            options
        }, listByResourceGroupDatabaseNextOperationSpec);
    }
    /**
     * ListByResourceGroupLocationNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroupLocation
     *                 method.
     * @param options The options parameters.
     */
    _listByResourceGroupLocationNext(resourceGroupName, locationName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, locationName, nextLink, options }, listByResourceGroupLocationNextOperationSpec);
    }
    /**
     * ListByResourceGroupServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param longTermRetentionServerName The name of the server
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroupServer
     *                 method.
     * @param options The options parameters.
     */
    _listByResourceGroupServerNext(resourceGroupName, locationName, longTermRetentionServerName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            locationName,
            longTermRetentionServerName,
            nextLink,
            options
        }, listByResourceGroupServerNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1N = coreClient.createSerializer(Mappers, /* isXml */ false);
const copyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionServers/{longTermRetentionServerName}/longTermRetentionDatabases/{longTermRetentionDatabaseName}/longTermRetentionBackups/{backupName}/copy",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        201: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        202: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        204: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        default: {}
    },
    requestBody: parameters84,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        locationName,
        longTermRetentionServerName,
        longTermRetentionDatabaseName,
        backupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1N
};
const updateOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionServers/{longTermRetentionServerName}/longTermRetentionDatabases/{longTermRetentionDatabaseName}/longTermRetentionBackups/{backupName}/update",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        201: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        202: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        204: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        default: {}
    },
    requestBody: parameters85,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        locationName,
        longTermRetentionServerName,
        longTermRetentionDatabaseName,
        backupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1N
};
const getOperationSpec$1w = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionServers/{longTermRetentionServerName}/longTermRetentionDatabases/{longTermRetentionDatabaseName}/longTermRetentionBackups/{backupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackup
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        locationName,
        longTermRetentionServerName,
        longTermRetentionDatabaseName,
        backupName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const deleteOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionServers/{longTermRetentionServerName}/longTermRetentionDatabases/{longTermRetentionDatabaseName}/longTermRetentionBackups/{backupName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        locationName,
        longTermRetentionServerName,
        longTermRetentionDatabaseName,
        backupName
    ],
    serializer: serializer$1N
};
const listByDatabaseOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionServers/{longTermRetentionServerName}/longTermRetentionDatabases/{longTermRetentionDatabaseName}/longTermRetentionBackups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        locationName,
        longTermRetentionServerName,
        longTermRetentionDatabaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const listByLocationOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionBackups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const listByServerOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionServers/{longTermRetentionServerName}/longTermRetentionBackups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        locationName,
        longTermRetentionServerName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const copyByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionServers/{longTermRetentionServerName}/longTermRetentionDatabases/{longTermRetentionDatabaseName}/longTermRetentionBackups/{backupName}/copy",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        201: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        202: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        204: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        default: {}
    },
    requestBody: parameters84,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName,
        longTermRetentionServerName,
        longTermRetentionDatabaseName,
        backupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1N
};
const updateByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionServers/{longTermRetentionServerName}/longTermRetentionDatabases/{longTermRetentionDatabaseName}/longTermRetentionBackups/{backupName}/update",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        201: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        202: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        204: {
            bodyMapper: LongTermRetentionBackupOperationResult
        },
        default: {}
    },
    requestBody: parameters85,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName,
        longTermRetentionServerName,
        longTermRetentionDatabaseName,
        backupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1N
};
const getByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionServers/{longTermRetentionServerName}/longTermRetentionDatabases/{longTermRetentionDatabaseName}/longTermRetentionBackups/{backupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackup
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName,
        longTermRetentionServerName,
        longTermRetentionDatabaseName,
        backupName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const deleteByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionServers/{longTermRetentionServerName}/longTermRetentionDatabases/{longTermRetentionDatabaseName}/longTermRetentionBackups/{backupName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName,
        longTermRetentionServerName,
        longTermRetentionDatabaseName,
        backupName
    ],
    serializer: serializer$1N
};
const listByResourceGroupDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionServers/{longTermRetentionServerName}/longTermRetentionDatabases/{longTermRetentionDatabaseName}/longTermRetentionBackups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName,
        longTermRetentionServerName,
        longTermRetentionDatabaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const listByResourceGroupLocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionBackups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const listByResourceGroupServerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionServers/{longTermRetentionServerName}/longTermRetentionBackups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName,
        longTermRetentionServerName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const listByDatabaseNextOperationSpec$s = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        locationName,
        longTermRetentionServerName,
        longTermRetentionDatabaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const listByLocationNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const listByServerNextOperationSpec$m = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        locationName,
        longTermRetentionServerName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const listByResourceGroupDatabaseNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        locationName,
        longTermRetentionServerName,
        longTermRetentionDatabaseName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const listByResourceGroupLocationNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const listByResourceGroupServerNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        locationName,
        longTermRetentionServerName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LongTermRetentionManagedInstanceBackups operations. */
class LongTermRetentionManagedInstanceBackupsImpl {
    /**
     * Initialize a new instance of the class LongTermRetentionManagedInstanceBackups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all long term retention backups for a managed database.
     * @param locationName The location of the database.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database.
     * @param options The options parameters.
     */
    listByDatabase(locationName, managedInstanceName, databaseName, options) {
        const iter = this.listByDatabasePagingAll(locationName, managedInstanceName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByDatabasePagingPage(locationName, managedInstanceName, databaseName, options);
            }
        };
    }
    listByDatabasePagingPage(locationName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByDatabase(locationName, managedInstanceName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByDatabaseNext(locationName, managedInstanceName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByDatabasePagingAll(locationName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabasePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDatabasePagingPage(locationName, managedInstanceName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the long term retention backups for a given managed instance.
     * @param locationName The location of the database
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listByInstance(locationName, managedInstanceName, options) {
        const iter = this.listByInstancePagingAll(locationName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByInstancePagingPage(locationName, managedInstanceName, options);
            }
        };
    }
    listByInstancePagingPage(locationName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByInstance(locationName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByInstanceNext(locationName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByInstancePagingAll(locationName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByInstancePagingPage(locationName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists the long term retention backups for managed databases in a given location.
     * @param locationName The location of the database.
     * @param options The options parameters.
     */
    listByLocation(locationName, options) {
        const iter = this.listByLocationPagingAll(locationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByLocationPagingPage(locationName, options);
            }
        };
    }
    listByLocationPagingPage(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingPage_1() {
            let result = yield tslib.__await(this._listByLocation(locationName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByLocationNext(locationName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByLocationPagingAll(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLocationPagingPage(locationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Lists all long term retention backups for a managed database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database.
     * @param options The options parameters.
     */
    listByResourceGroupDatabase(resourceGroupName, locationName, managedInstanceName, databaseName, options) {
        const iter = this.listByResourceGroupDatabasePagingAll(resourceGroupName, locationName, managedInstanceName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupDatabasePagingPage(resourceGroupName, locationName, managedInstanceName, databaseName, options);
            }
        };
    }
    listByResourceGroupDatabasePagingPage(resourceGroupName, locationName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupDatabasePagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroupDatabase(resourceGroupName, locationName, managedInstanceName, databaseName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupDatabaseNext(resourceGroupName, locationName, managedInstanceName, databaseName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupDatabasePagingAll(resourceGroupName, locationName, managedInstanceName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupDatabasePagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupDatabasePagingPage(resourceGroupName, locationName, managedInstanceName, databaseName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Lists the long term retention backups for a given managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listByResourceGroupInstance(resourceGroupName, locationName, managedInstanceName, options) {
        const iter = this.listByResourceGroupInstancePagingAll(resourceGroupName, locationName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupInstancePagingPage(resourceGroupName, locationName, managedInstanceName, options);
            }
        };
    }
    listByResourceGroupInstancePagingPage(resourceGroupName, locationName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroupInstance(resourceGroupName, locationName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupInstanceNext(resourceGroupName, locationName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupInstancePagingAll(resourceGroupName, locationName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupInstancePagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupInstancePagingPage(resourceGroupName, locationName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Lists the long term retention backups for managed databases in a given location.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database.
     * @param options The options parameters.
     */
    listByResourceGroupLocation(resourceGroupName, locationName, options) {
        const iter = this.listByResourceGroupLocationPagingAll(resourceGroupName, locationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupLocationPagingPage(resourceGroupName, locationName, options);
            }
        };
    }
    listByResourceGroupLocationPagingPage(resourceGroupName, locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupLocationPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroupLocation(resourceGroupName, locationName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupLocationNext(resourceGroupName, locationName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupLocationPagingAll(resourceGroupName, locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupLocationPagingAll_1() {
            var e_6, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupLocationPagingPage(resourceGroupName, locationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Gets a long term retention backup for a managed database.
     * @param locationName The location of the database.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database.
     * @param backupName The backup name.
     * @param options The options parameters.
     */
    get(locationName, managedInstanceName, databaseName, backupName, options) {
        return this.client.sendOperationRequest({ locationName, managedInstanceName, databaseName, backupName, options }, getOperationSpec$1x);
    }
    /**
     * Deletes a long term retention backup.
     * @param locationName The location of the database.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database.
     * @param backupName The backup name.
     * @param options The options parameters.
     */
    beginDelete(locationName, managedInstanceName, databaseName, backupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { locationName, managedInstanceName, databaseName, backupName, options }, deleteOperationSpec$H);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a long term retention backup.
     * @param locationName The location of the database.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database.
     * @param backupName The backup name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(locationName, managedInstanceName, databaseName, backupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(locationName, managedInstanceName, databaseName, backupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all long term retention backups for a managed database.
     * @param locationName The location of the database.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database.
     * @param options The options parameters.
     */
    _listByDatabase(locationName, managedInstanceName, databaseName, options) {
        return this.client.sendOperationRequest({ locationName, managedInstanceName, databaseName, options }, listByDatabaseOperationSpec$w);
    }
    /**
     * Lists the long term retention backups for a given managed instance.
     * @param locationName The location of the database
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listByInstance(locationName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ locationName, managedInstanceName, options }, listByInstanceOperationSpec$9);
    }
    /**
     * Lists the long term retention backups for managed databases in a given location.
     * @param locationName The location of the database.
     * @param options The options parameters.
     */
    _listByLocation(locationName, options) {
        return this.client.sendOperationRequest({ locationName, options }, listByLocationOperationSpec$8);
    }
    /**
     * Gets a long term retention backup for a managed database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database.
     * @param backupName The backup name.
     * @param options The options parameters.
     */
    getByResourceGroup(resourceGroupName, locationName, managedInstanceName, databaseName, backupName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            locationName,
            managedInstanceName,
            databaseName,
            backupName,
            options
        }, getByResourceGroupOperationSpec$1);
    }
    /**
     * Deletes a long term retention backup.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database.
     * @param backupName The backup name.
     * @param options The options parameters.
     */
    beginDeleteByResourceGroup(resourceGroupName, locationName, managedInstanceName, databaseName, backupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                locationName,
                managedInstanceName,
                databaseName,
                backupName,
                options
            }, deleteByResourceGroupOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a long term retention backup.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database.
     * @param backupName The backup name.
     * @param options The options parameters.
     */
    beginDeleteByResourceGroupAndWait(resourceGroupName, locationName, managedInstanceName, databaseName, backupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteByResourceGroup(resourceGroupName, locationName, managedInstanceName, databaseName, backupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all long term retention backups for a managed database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database.
     * @param options The options parameters.
     */
    _listByResourceGroupDatabase(resourceGroupName, locationName, managedInstanceName, databaseName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            locationName,
            managedInstanceName,
            databaseName,
            options
        }, listByResourceGroupDatabaseOperationSpec$1);
    }
    /**
     * Lists the long term retention backups for a given managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listByResourceGroupInstance(resourceGroupName, locationName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, locationName, managedInstanceName, options }, listByResourceGroupInstanceOperationSpec);
    }
    /**
     * Lists the long term retention backups for managed databases in a given location.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database.
     * @param options The options parameters.
     */
    _listByResourceGroupLocation(resourceGroupName, locationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, locationName, options }, listByResourceGroupLocationOperationSpec$1);
    }
    /**
     * ListByDatabaseNext
     * @param locationName The location of the database.
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database.
     * @param nextLink The nextLink from the previous successful call to the ListByDatabase method.
     * @param options The options parameters.
     */
    _listByDatabaseNext(locationName, managedInstanceName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({ locationName, managedInstanceName, databaseName, nextLink, options }, listByDatabaseNextOperationSpec$t);
    }
    /**
     * ListByInstanceNext
     * @param locationName The location of the database
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListByInstance method.
     * @param options The options parameters.
     */
    _listByInstanceNext(locationName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ locationName, managedInstanceName, nextLink, options }, listByInstanceNextOperationSpec$9);
    }
    /**
     * ListByLocationNext
     * @param locationName The location of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByLocation method.
     * @param options The options parameters.
     */
    _listByLocationNext(locationName, nextLink, options) {
        return this.client.sendOperationRequest({ locationName, nextLink, options }, listByLocationNextOperationSpec$7);
    }
    /**
     * ListByResourceGroupDatabaseNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database
     * @param managedInstanceName The name of the managed instance.
     * @param databaseName The name of the managed database.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroupDatabase
     *                 method.
     * @param options The options parameters.
     */
    _listByResourceGroupDatabaseNext(resourceGroupName, locationName, managedInstanceName, databaseName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            locationName,
            managedInstanceName,
            databaseName,
            nextLink,
            options
        }, listByResourceGroupDatabaseNextOperationSpec$1);
    }
    /**
     * ListByResourceGroupInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database.
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroupInstance
     *                 method.
     * @param options The options parameters.
     */
    _listByResourceGroupInstanceNext(resourceGroupName, locationName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            locationName,
            managedInstanceName,
            nextLink,
            options
        }, listByResourceGroupInstanceNextOperationSpec);
    }
    /**
     * ListByResourceGroupLocationNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param locationName The location of the database.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroupLocation
     *                 method.
     * @param options The options parameters.
     */
    _listByResourceGroupLocationNext(resourceGroupName, locationName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, locationName, nextLink, options }, listByResourceGroupLocationNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1O = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1x = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionManagedInstances/{managedInstanceName}/longTermRetentionDatabases/{databaseName}/longTermRetentionManagedInstanceBackups/{backupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionBackup
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        databaseName,
        locationName,
        managedInstanceName,
        backupName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};
const deleteOperationSpec$H = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionManagedInstances/{managedInstanceName}/longTermRetentionDatabases/{databaseName}/longTermRetentionManagedInstanceBackups/{backupName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        databaseName,
        locationName,
        managedInstanceName,
        backupName
    ],
    serializer: serializer$1O
};
const listByDatabaseOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionManagedInstances/{managedInstanceName}/longTermRetentionDatabases/{databaseName}/longTermRetentionManagedInstanceBackups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        databaseName,
        locationName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};
const listByInstanceOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionManagedInstances/{managedInstanceName}/longTermRetentionManagedInstanceBackups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        locationName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};
const listByLocationOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionManagedInstanceBackups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};
const getByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionManagedInstances/{managedInstanceName}/longTermRetentionDatabases/{databaseName}/longTermRetentionManagedInstanceBackups/{backupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionBackup
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        locationName,
        managedInstanceName,
        backupName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};
const deleteByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionManagedInstances/{managedInstanceName}/longTermRetentionDatabases/{databaseName}/longTermRetentionManagedInstanceBackups/{backupName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        locationName,
        managedInstanceName,
        backupName
    ],
    serializer: serializer$1O
};
const listByResourceGroupDatabaseOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionManagedInstances/{managedInstanceName}/longTermRetentionDatabases/{databaseName}/longTermRetentionManagedInstanceBackups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        locationName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};
const listByResourceGroupInstanceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionManagedInstances/{managedInstanceName}/longTermRetentionManagedInstanceBackups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};
const listByResourceGroupLocationOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionManagedInstanceBackups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};
const listByDatabaseNextOperationSpec$t = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        databaseName,
        nextLink,
        locationName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};
const listByInstanceNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        locationName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};
const listByLocationNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};
const listByResourceGroupDatabaseNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        databaseName,
        nextLink,
        locationName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};
const listByResourceGroupInstanceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        locationName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};
const listByResourceGroupLocationNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceLongTermRetentionBackupListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        onlyLatestPerDatabase,
        databaseState
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedInstances operations. */
class ManagedInstancesImpl {
    /**
     * Initialize a new instance of the class ManagedInstances class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all managed instances in an instance pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param instancePoolName The instance pool name.
     * @param options The options parameters.
     */
    listByInstancePool(resourceGroupName, instancePoolName, options) {
        const iter = this.listByInstancePoolPagingAll(resourceGroupName, instancePoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByInstancePoolPagingPage(resourceGroupName, instancePoolName, options);
            }
        };
    }
    listByInstancePoolPagingPage(resourceGroupName, instancePoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePoolPagingPage_1() {
            let result = yield tslib.__await(this._listByInstancePool(resourceGroupName, instancePoolName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByInstancePoolNext(resourceGroupName, instancePoolName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByInstancePoolPagingAll(resourceGroupName, instancePoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePoolPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByInstancePoolPagingPage(resourceGroupName, instancePoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of all managed instances in the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of managed instances in a resource group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Get top resource consuming queries of a managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listByManagedInstance(resourceGroupName, managedInstanceName, options) {
        const iter = this.listByManagedInstancePagingAll(resourceGroupName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByManagedInstancePagingPage(resourceGroupName, managedInstanceName, options);
            }
        };
    }
    listByManagedInstancePagingPage(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByManagedInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByManagedInstance(resourceGroupName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByManagedInstanceNext(resourceGroupName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByManagedInstancePagingAll(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByManagedInstancePagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByManagedInstancePagingPage(resourceGroupName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Gets a list of all managed instances in an instance pool.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param instancePoolName The instance pool name.
     * @param options The options parameters.
     */
    _listByInstancePool(resourceGroupName, instancePoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, instancePoolName, options }, listByInstancePoolOperationSpec$1);
    }
    /**
     * Gets a list of all managed instances in the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$5);
    }
    /**
     * Gets a list of managed instances in a resource group.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$3);
    }
    /**
     * Gets a managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, getOperationSpec$1y);
    }
    /**
     * Creates or updates a managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param parameters The requested managed instance resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, managedInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, managedInstanceName, parameters, options }, createOrUpdateOperationSpec$11);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Creates or updates a managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param parameters The requested managed instance resource state.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, managedInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, managedInstanceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, managedInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, managedInstanceName, options }, deleteOperationSpec$I);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, managedInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, managedInstanceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param parameters The requested managed instance resource state.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, managedInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, managedInstanceName, parameters, options }, updateOperationSpec$n);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param parameters The requested managed instance resource state.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, managedInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, managedInstanceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get top resource consuming queries of a managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listByManagedInstance(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, listByManagedInstanceOperationSpec$3);
    }
    /**
     * Failovers a managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance to failover.
     * @param options The options parameters.
     */
    beginFailover(resourceGroupName, managedInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, managedInstanceName, options }, failoverOperationSpec$5);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Failovers a managed instance.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance to failover.
     * @param options The options parameters.
     */
    beginFailoverAndWait(resourceGroupName, managedInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginFailover(resourceGroupName, managedInstanceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByInstancePoolNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param instancePoolName The instance pool name.
     * @param nextLink The nextLink from the previous successful call to the ListByInstancePool method.
     * @param options The options parameters.
     */
    _listByInstancePoolNext(resourceGroupName, instancePoolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, instancePoolName, nextLink, options }, listByInstancePoolNextOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$5);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$3);
    }
    /**
     * ListByManagedInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListByManagedInstance method.
     * @param options The options parameters.
     */
    _listByManagedInstanceNext(resourceGroupName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, nextLink, options }, listByManagedInstanceNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$1P = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByInstancePoolOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/instancePools/{instancePoolName}/managedInstances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        instancePoolName
    ],
    headerParameters: [accept],
    serializer: serializer$1P
};
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Sql/managedInstances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1, expand],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1P
};
const listByResourceGroupOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1P
};
const getOperationSpec$1y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstance
        },
        default: {}
    },
    queryParameters: [apiVersion1, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1P
};
const createOrUpdateOperationSpec$11 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedInstance
        },
        201: {
            bodyMapper: ManagedInstance
        },
        202: {
            bodyMapper: ManagedInstance
        },
        204: {
            bodyMapper: ManagedInstance
        },
        default: {}
    },
    requestBody: parameters86,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1P
};
const deleteOperationSpec$I = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    serializer: serializer$1P
};
const updateOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ManagedInstance
        },
        201: {
            bodyMapper: ManagedInstance
        },
        202: {
            bodyMapper: ManagedInstance
        },
        204: {
            bodyMapper: ManagedInstance
        },
        default: {}
    },
    requestBody: parameters87,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1P
};
const listByManagedInstanceOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/topqueries",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopQueriesListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        startTime,
        endTime,
        interval,
        numberOfQueries,
        databases,
        aggregationFunction,
        observationMetric
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1P
};
const failoverOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/failover",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion1, replicaType],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    serializer: serializer$1P
};
const listByInstancePoolNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        instancePoolName
    ],
    headerParameters: [accept],
    serializer: serializer$1P
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1, expand],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1P
};
const listByResourceGroupNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedInstanceListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1P
};
const listByManagedInstanceNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopQueriesListResult
        },
        default: {}
    },
    queryParameters: [
        apiVersion1,
        startTime,
        endTime,
        interval,
        numberOfQueries,
        databases,
        aggregationFunction,
        observationMetric
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1P
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorableDroppedDatabases operations. */
class RestorableDroppedDatabasesImpl {
    /**
     * Initialize a new instance of the class RestorableDroppedDatabases class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of restorable dropped databases.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of restorable dropped databases.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$s);
    }
    /**
     * Gets a restorable dropped database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param restorableDroppedDatabaseId
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, restorableDroppedDatabaseId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, restorableDroppedDatabaseId, options }, getOperationSpec$1z);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$n);
    }
}
// Operation Specifications
const serializer$1Q = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByServerOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/restorableDroppedDatabases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableDroppedDatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1Q
};
const getOperationSpec$1z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/restorableDroppedDatabases/{restorableDroppedDatabaseId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableDroppedDatabase
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        restorableDroppedDatabaseId
    ],
    headerParameters: [accept],
    serializer: serializer$1Q
};
const listByServerNextOperationSpec$n = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableDroppedDatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1Q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorableDroppedManagedDatabases operations. */
class RestorableDroppedManagedDatabasesImpl {
    /**
     * Initialize a new instance of the class RestorableDroppedManagedDatabases class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of restorable dropped managed databases.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    listByInstance(resourceGroupName, managedInstanceName, options) {
        const iter = this.listByInstancePagingAll(resourceGroupName, managedInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options);
            }
        };
    }
    listByInstancePagingPage(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingPage_1() {
            let result = yield tslib.__await(this._listByInstance(resourceGroupName, managedInstanceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByInstanceNext(resourceGroupName, managedInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByInstancePagingAll(resourceGroupName, managedInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByInstancePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByInstancePagingPage(resourceGroupName, managedInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of restorable dropped managed databases.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param options The options parameters.
     */
    _listByInstance(resourceGroupName, managedInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, options }, listByInstanceOperationSpec$a);
    }
    /**
     * Gets a restorable dropped managed database.
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param restorableDroppedDatabaseId
     * @param options The options parameters.
     */
    get(resourceGroupName, managedInstanceName, restorableDroppedDatabaseId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            managedInstanceName,
            restorableDroppedDatabaseId,
            options
        }, getOperationSpec$1A);
    }
    /**
     * ListByInstanceNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param managedInstanceName The name of the managed instance.
     * @param nextLink The nextLink from the previous successful call to the ListByInstance method.
     * @param options The options parameters.
     */
    _listByInstanceNext(resourceGroupName, managedInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, managedInstanceName, nextLink, options }, listByInstanceNextOperationSpec$a);
    }
}
// Operation Specifications
const serializer$1R = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByInstanceOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/restorableDroppedDatabases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableDroppedManagedDatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const getOperationSpec$1A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/managedInstances/{managedInstanceName}/restorableDroppedDatabases/{restorableDroppedDatabaseId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableDroppedManagedDatabase
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        managedInstanceName,
        restorableDroppedDatabaseId
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const listByInstanceNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableDroppedManagedDatabaseListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        managedInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServerConnectionPolicies operations. */
class ServerConnectionPoliciesImpl {
    /**
     * Initialize a new instance of the class ServerConnectionPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists connection policy
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    listByServer(resourceGroupName, serverName, options) {
        const iter = this.listByServerPagingAll(resourceGroupName, serverName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByServerPagingPage(resourceGroupName, serverName, options);
            }
        };
    }
    listByServerPagingPage(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingPage_1() {
            let result = yield tslib.__await(this._listByServer(resourceGroupName, serverName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByServerNext(resourceGroupName, serverName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByServerPagingAll(resourceGroupName, serverName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByServerPagingPage(resourceGroupName, serverName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a server connection policy
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param connectionPolicyName The name of the connection policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, serverName, connectionPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, connectionPolicyName, options }, getOperationSpec$1B);
    }
    /**
     * Updates a server connection policy
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param connectionPolicyName The name of the connection policy.
     * @param parameters The required parameters for updating a server connection policy.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serverName, connectionPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                serverName,
                connectionPolicyName,
                parameters,
                options
            }, createOrUpdateOperationSpec$12);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates a server connection policy
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param connectionPolicyName The name of the connection policy.
     * @param parameters The required parameters for updating a server connection policy.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serverName, connectionPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serverName, connectionPolicyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists connection policy
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param options The options parameters.
     */
    _listByServer(resourceGroupName, serverName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, options }, listByServerOperationSpec$t);
    }
    /**
     * ListByServerNext
     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain
     *                          this value from the Azure Resource Manager API or the portal.
     * @param serverName The name of the server.
     * @param nextLink The nextLink from the previous successful call to the ListByServer method.
     * @param options The options parameters.
     */
    _listByServerNext(resourceGroupName, serverName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serverName, nextLink, options }, listByServerNextOperationSpec$o);
    }
}
// Operation Specifications
const serializer$1S = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/connectionPolicies/{connectionPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerConnectionPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        connectionPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const createOrUpdateOperationSpec$12 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/connectionPolicies/{connectionPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServerConnectionPolicy
        },
        201: {
            bodyMapper: ServerConnectionPolicy
        },
        202: {
            bodyMapper: ServerConnectionPolicy
        },
        204: {
            bodyMapper: ServerConnectionPolicy
        },
        default: {}
    },
    requestBody: parameters88,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        connectionPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1S
};
const listByServerOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/connectionPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerConnectionPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const listByServerNextOperationSpec$o = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerConnectionPolicyListResult
        },
        default: {}
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        serverName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class SqlManagementClient extends coreClient.ServiceClient {
    /**
     * Initializes a new instance of the SqlManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The subscription ID that identifies an Azure subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-sql/9.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        if (!options.credentialScopes) {
            options.credentialScopes = ["https://management.azure.com/.default"];
        }
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "https://management.azure.com" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.recoverableDatabases = new RecoverableDatabasesImpl(this);
        this.dataMaskingPolicies = new DataMaskingPoliciesImpl(this);
        this.dataMaskingRules = new DataMaskingRulesImpl(this);
        this.geoBackupPolicies = new GeoBackupPoliciesImpl(this);
        this.databases = new DatabasesImpl(this);
        this.elasticPools = new ElasticPoolsImpl(this);
        this.replicationLinks = new ReplicationLinksImpl(this);
        this.serverCommunicationLinks = new ServerCommunicationLinksImpl(this);
        this.serviceObjectives = new ServiceObjectivesImpl(this);
        this.elasticPoolActivities = new ElasticPoolActivitiesImpl(this);
        this.elasticPoolDatabaseActivities = new ElasticPoolDatabaseActivitiesImpl(this);
        this.serverUsages = new ServerUsagesImpl(this);
        this.extendedDatabaseBlobAuditingPolicies = new ExtendedDatabaseBlobAuditingPoliciesImpl(this);
        this.extendedServerBlobAuditingPolicies = new ExtendedServerBlobAuditingPoliciesImpl(this);
        this.serverBlobAuditingPolicies = new ServerBlobAuditingPoliciesImpl(this);
        this.databaseBlobAuditingPolicies = new DatabaseBlobAuditingPoliciesImpl(this);
        this.databaseAdvisors = new DatabaseAdvisorsImpl(this);
        this.databaseAutomaticTuningOperations = new DatabaseAutomaticTuningOperationsImpl(this);
        this.databaseColumns = new DatabaseColumnsImpl(this);
        this.databaseRecommendedActions = new DatabaseRecommendedActionsImpl(this);
        this.databaseSchemas = new DatabaseSchemasImpl(this);
        this.databaseSecurityAlertPolicies = new DatabaseSecurityAlertPoliciesImpl(this);
        this.databaseTables = new DatabaseTablesImpl(this);
        this.databaseVulnerabilityAssessmentRuleBaselines = new DatabaseVulnerabilityAssessmentRuleBaselinesImpl(this);
        this.databaseVulnerabilityAssessments = new DatabaseVulnerabilityAssessmentsImpl(this);
        this.databaseVulnerabilityAssessmentScans = new DatabaseVulnerabilityAssessmentScansImpl(this);
        this.dataWarehouseUserActivitiesOperations = new DataWarehouseUserActivitiesOperationsImpl(this);
        this.deletedServers = new DeletedServersImpl(this);
        this.elasticPoolOperations = new ElasticPoolOperationsImpl(this);
        this.encryptionProtectors = new EncryptionProtectorsImpl(this);
        this.failoverGroups = new FailoverGroupsImpl(this);
        this.firewallRules = new FirewallRulesImpl(this);
        this.instanceFailoverGroups = new InstanceFailoverGroupsImpl(this);
        this.instancePools = new InstancePoolsImpl(this);
        this.jobAgents = new JobAgentsImpl(this);
        this.jobCredentials = new JobCredentialsImpl(this);
        this.jobExecutions = new JobExecutionsImpl(this);
        this.jobs = new JobsImpl(this);
        this.jobStepExecutions = new JobStepExecutionsImpl(this);
        this.jobSteps = new JobStepsImpl(this);
        this.jobTargetExecutions = new JobTargetExecutionsImpl(this);
        this.jobTargetGroups = new JobTargetGroupsImpl(this);
        this.jobVersions = new JobVersionsImpl(this);
        this.capabilities = new CapabilitiesImpl(this);
        this.longTermRetentionPolicies = new LongTermRetentionPoliciesImpl(this);
        this.maintenanceWindowOptionsOperations = new MaintenanceWindowOptionsOperationsImpl(this);
        this.maintenanceWindowsOperations = new MaintenanceWindowsOperationsImpl(this);
        this.managedBackupShortTermRetentionPolicies = new ManagedBackupShortTermRetentionPoliciesImpl(this);
        this.managedDatabaseColumns = new ManagedDatabaseColumnsImpl(this);
        this.managedDatabaseQueries = new ManagedDatabaseQueriesImpl(this);
        this.managedDatabaseRestoreDetails = new ManagedDatabaseRestoreDetailsImpl(this);
        this.managedDatabases = new ManagedDatabasesImpl(this);
        this.managedDatabaseSchemas = new ManagedDatabaseSchemasImpl(this);
        this.managedDatabaseSecurityAlertPolicies = new ManagedDatabaseSecurityAlertPoliciesImpl(this);
        this.managedDatabaseSecurityEvents = new ManagedDatabaseSecurityEventsImpl(this);
        this.managedDatabaseSensitivityLabels = new ManagedDatabaseSensitivityLabelsImpl(this);
        this.managedDatabaseRecommendedSensitivityLabels = new ManagedDatabaseRecommendedSensitivityLabelsImpl(this);
        this.managedDatabaseTables = new ManagedDatabaseTablesImpl(this);
        this.managedDatabaseTransparentDataEncryption = new ManagedDatabaseTransparentDataEncryptionImpl(this);
        this.managedDatabaseVulnerabilityAssessmentRuleBaselines = new ManagedDatabaseVulnerabilityAssessmentRuleBaselinesImpl(this);
        this.managedDatabaseVulnerabilityAssessments = new ManagedDatabaseVulnerabilityAssessmentsImpl(this);
        this.managedDatabaseVulnerabilityAssessmentScans = new ManagedDatabaseVulnerabilityAssessmentScansImpl(this);
        this.managedInstanceAdministrators = new ManagedInstanceAdministratorsImpl(this);
        this.managedInstanceAzureADOnlyAuthentications = new ManagedInstanceAzureADOnlyAuthenticationsImpl(this);
        this.managedInstanceEncryptionProtectors = new ManagedInstanceEncryptionProtectorsImpl(this);
        this.managedInstanceKeys = new ManagedInstanceKeysImpl(this);
        this.managedInstanceLongTermRetentionPolicies = new ManagedInstanceLongTermRetentionPoliciesImpl(this);
        this.managedInstanceOperations = new ManagedInstanceOperationsImpl(this);
        this.managedInstancePrivateEndpointConnections = new ManagedInstancePrivateEndpointConnectionsImpl(this);
        this.managedInstancePrivateLinkResources = new ManagedInstancePrivateLinkResourcesImpl(this);
        this.managedInstanceTdeCertificates = new ManagedInstanceTdeCertificatesImpl(this);
        this.managedInstanceVulnerabilityAssessments = new ManagedInstanceVulnerabilityAssessmentsImpl(this);
        this.managedRestorableDroppedDatabaseBackupShortTermRetentionPolicies = new ManagedRestorableDroppedDatabaseBackupShortTermRetentionPoliciesImpl(this);
        this.managedServerSecurityAlertPolicies = new ManagedServerSecurityAlertPoliciesImpl(this);
        this.operations = new OperationsImpl(this);
        this.operationsHealthOperations = new OperationsHealthOperationsImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
        this.privateLinkResources = new PrivateLinkResourcesImpl(this);
        this.recoverableManagedDatabases = new RecoverableManagedDatabasesImpl(this);
        this.restorePoints = new RestorePointsImpl(this);
        this.sensitivityLabels = new SensitivityLabelsImpl(this);
        this.recommendedSensitivityLabels = new RecommendedSensitivityLabelsImpl(this);
        this.serverAdvisors = new ServerAdvisorsImpl(this);
        this.serverAutomaticTuningOperations = new ServerAutomaticTuningOperationsImpl(this);
        this.serverAzureADAdministrators = new ServerAzureADAdministratorsImpl(this);
        this.serverAzureADOnlyAuthentications = new ServerAzureADOnlyAuthenticationsImpl(this);
        this.serverDevOpsAuditSettings = new ServerDevOpsAuditSettingsImpl(this);
        this.serverDnsAliases = new ServerDnsAliasesImpl(this);
        this.serverKeys = new ServerKeysImpl(this);
        this.serverOperations = new ServerOperationsImpl(this);
        this.serverSecurityAlertPolicies = new ServerSecurityAlertPoliciesImpl(this);
        this.serverTrustGroups = new ServerTrustGroupsImpl(this);
        this.serverVulnerabilityAssessments = new ServerVulnerabilityAssessmentsImpl(this);
        this.sqlAgent = new SqlAgentImpl(this);
        this.subscriptionUsages = new SubscriptionUsagesImpl(this);
        this.syncAgents = new SyncAgentsImpl(this);
        this.syncGroups = new SyncGroupsImpl(this);
        this.syncMembers = new SyncMembersImpl(this);
        this.tdeCertificates = new TdeCertificatesImpl(this);
        this.timeZones = new TimeZonesImpl(this);
        this.virtualClusters = new VirtualClustersImpl(this);
        this.virtualNetworkRules = new VirtualNetworkRulesImpl(this);
        this.workloadClassifiers = new WorkloadClassifiersImpl(this);
        this.workloadGroups = new WorkloadGroupsImpl(this);
        this.transparentDataEncryptions = new TransparentDataEncryptionsImpl(this);
        this.backupShortTermRetentionPolicies = new BackupShortTermRetentionPoliciesImpl(this);
        this.databaseExtensionsOperations = new DatabaseExtensionsOperationsImpl(this);
        this.databaseOperations = new DatabaseOperationsImpl(this);
        this.databaseUsages = new DatabaseUsagesImpl(this);
        this.ledgerDigestUploadsOperations = new LedgerDigestUploadsOperationsImpl(this);
        this.outboundFirewallRules = new OutboundFirewallRulesImpl(this);
        this.servers = new ServersImpl(this);
        this.usages = new UsagesImpl(this);
        this.longTermRetentionBackups = new LongTermRetentionBackupsImpl(this);
        this.longTermRetentionManagedInstanceBackups = new LongTermRetentionManagedInstanceBackupsImpl(this);
        this.managedInstances = new ManagedInstancesImpl(this);
        this.restorableDroppedDatabases = new RestorableDroppedDatabasesImpl(this);
        this.restorableDroppedManagedDatabases = new RestorableDroppedManagedDatabasesImpl(this);
        this.serverConnectionPolicies = new ServerConnectionPoliciesImpl(this);
    }
}

exports.SqlManagementClient = SqlManagementClient;
//# sourceMappingURL=index.js.map
